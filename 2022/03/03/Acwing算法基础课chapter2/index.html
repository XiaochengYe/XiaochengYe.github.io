<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Acwing 算法基础课 chapter 2 | HaoSengYee</title><meta name="keywords" content="Acwing算法基础课"><meta name="author" content="xiaochengYe"><meta name="copyright" content="xiaochengYe"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="lecture 2 数据结构模板单链表数组模拟 比 动态分配链表【struct Node {}; new Node();】 快	   &#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;&#x2F;&#x2F; 初始化void init()&amp;#123;    head &#x3D; -1;    idx &#x3D; 0;&amp;#12">
<meta property="og:type" content="article">
<meta property="og:title" content="Acwing 算法基础课 chapter 2">
<meta property="og:url" content="https://xiaochengye.github.io/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/index.html">
<meta property="og:site_name" content="HaoSengYee">
<meta property="og:description" content="lecture 2 数据结构模板单链表数组模拟 比 动态分配链表【struct Node {}; new Node();】 快	   &#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;&#x2F;&#x2F; 初始化void init()&amp;#123;    head &#x3D; -1;    idx &#x3D; 0;&amp;#12">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://xiaochengye.github.io/img/acwing.png">
<meta property="article:published_time" content="2022-03-02T16:01:08.000Z">
<meta property="article:modified_time" content="2022-08-08T02:20:35.556Z">
<meta property="article:author" content="xiaochengYe">
<meta property="article:tag" content="Acwing算法基础课">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiaochengye.github.io/img/acwing.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://xiaochengye.github.io/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Acwing 算法基础课 chapter 2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-08 10:20:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> butterfly主题</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/acwing.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">HaoSengYee</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 关于</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly/"><i class="fa-fw fa fa-heart"></i><span> butterfly主题</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Acwing 算法基础课 chapter 2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-02T16:01:08.000Z" title="发表于 2022-03-03 00:01:08">2022-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-08T02:20:35.556Z" title="更新于 2022-08-08 10:20:35">2022-08-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Acwing 算法基础课 chapter 2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="lecture-2-数据结构"><a href="#lecture-2-数据结构" class="headerlink" title="lecture 2 数据结构"></a>lecture 2 数据结构</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><strong>数组模拟</strong> 比 <strong>动态分配</strong>链表【struct Node {}; new Node();】 快	</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/wpsAFC7.tmp.jpg" alt="单链表"> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大&#x2F;小的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">	stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>常见模型：找出滑动窗口中的最大值&#x2F;最小值</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637721398.png" alt="单调队列"></p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637738675.png" alt="单调队列"></p>
<p>删除，直到它严格单调。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">	<span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">	q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求Next数组：</span><br><span class="line"><span class="comment">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">	<span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">	ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">	<span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">	<span class="keyword">if</span> (j == m)</span><br><span class="line">	&#123;</span><br><span class="line">		j = ne[j];</span><br><span class="line">		<span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h3><p>高效地存储和查找字符串集合的数据结构。</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644760589784.png" alt="Trie树"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx 作用同单链表。 存的是我们当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		p = son[p][u];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><ol>
<li>将两个集合合并；</li>
<li>询问两个元素是否在一个集合当中。</li>
</ol>
<blockquote>
<p>普通暴力的做法：</p>
<p>  belong[x] &#x3D; a  集合编号 </p>
<p>  if(belong[x] &#x3D;&#x3D; belong[y])   </p>
<p>查询是否一个集合易 O(1) ，合并则比较复杂 O(n) 。</p>
<p>并查集可近似 O(1) 完成上述两个操作。</p>
</blockquote>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644832877691.png" alt="基本原理"></p>
<p><strong>基本原理</strong></p>
<p>每个集合用一棵树来表示。树根节点的编号就是当前集合的编号。每个节点存储它的父节点，p[x] 表示 x 的父节点。</p>
<ul>
<li><p>问题1：如何判断树根</p>
<p>if(p[x] &#x3D;&#x3D; x)</p>
</li>
<li><p>问题2：如何求 x 的集合编号</p>
<p>while(p[x] !&#x3D; x) x &#x3D; p[x];</p>
</li>
<li><p>问题3：如何合并两个集合</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644845624459.png" alt="合并集合"> </p>
<p>px 是 x 的集合编号，py 是 y 的集合编号。p[x] &#x3D; y。</p>
</li>
</ul>
<blockquote>
<p>问题 2 的时间复杂度较高，可进行 <strong>路径压缩</strong>(如图) 或 按值合并(让高度小的树接到高度大的树) 优化。</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644844526239.png" alt="路径压缩"></p>
</blockquote>
<h4 id="朴素并查集"><a href="#朴素并查集" class="headerlink" title="朴素并查集"></a>朴素并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure>

<h4 id="维护size的并查集"><a href="#维护size的并查集" class="headerlink" title="维护size的并查集"></a>维护size的并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">size[b] += size[a];</span><br></pre></td></tr></table></figure>

<h4 id="维护到祖宗节点距离的并查集"><a href="#维护到祖宗节点距离的并查集" class="headerlink" title="维护到祖宗节点距离的并查集"></a>维护到祖宗节点距离的并查集</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x] += d[p[x]];</span><br><span class="line">    p[x] = u;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[I] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>



<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>手写堆，STL中形式是优先队列。</p>
<p><strong>形式</strong></p>
<p>完全二叉树；小根堆(根节点 &lt;&#x3D; 左右子节点)；大根堆</p>
<p><strong>存储</strong></p>
<p>一维数组</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917137772.png" alt="存储"></p>
<p><strong>操作</strong></p>
<ul>
<li><p>down(x) {}  往下调   [O(logn)]</p>
<p>使用场景：某一个值变大了，需要下移。</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917379969.png" alt="1644917379969"></p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917390859.png" alt="1644917390859"> </p>
</li>
<li><p>up(x) {}  往上调</p>
<p>使用场景：某一个值变小了，需要上移。</p>
</li>
</ul>
<ol>
<li>插入一个数 &amp;emsp;<code>heap[++size] = x;&amp;emsp;up(size);</code></li>
<li>求集合当中的最小值[O(1)]&amp;emsp;<code>heap[1];</code></li>
<li>删除最小值&amp;emsp;<code>heap[1] = heap[size]; size--; down(1);</code></li>
<li>*删除任意一个元素&amp;emsp;<code>heap[k] = heap[size]; size--; down(k); up(k);</code></li>
<li>*修改任意一个元素&amp;emsp;<code>heap[k] = x; down(k); up(k);</code></li>
</ol>
<p><strong>建堆</strong></p>
<p>有两种建堆的方法:</p>
<ol>
<li>一种是从一个空树开始，每次输入一个数，就按照插入操作插入这个树，时间复杂度 <strong>nlogn</strong> (一共n个元素，每个元素logn)。</li>
<li>还有一种建堆方法是已经把数据都输入到了数组 a[N] ，怎么根据这个数组直接建堆。就是从 n&#x2F;2 开始down()，因为 n&#x2F;2 是倒数第二层，如果是倒数第一层其实每个节点自然成堆了，所以从倒数第二层开始，是最简单的一个二层树结构，down 完形成一个堆。从右下角往左边开始建堆，这样从下往上之后，轮到每个节点他下面的子树肯定已经成堆了，满足 down 的条件。</li>
</ol>
<p>复杂度分析：(以完全二叉树为例)</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644933510031.png" alt="O(n)建堆"></p>
<p>为什么是 n&#x2F;4 * 1 + n&#x2F;8 * 2 +… ？</p>
<p>根据每一层的节点树乘以需要往下down的迭代次数（其实就是往下的层树）。假设一共有n个元素的完全二叉树，那么最后一层有n&#x2F;2个元素(满二叉树情况)，不需要往下down()， 倒数第二层(含)之上总共n&#x2F;2个节点。i &#x3D; n &#x2F; 2是最后一个拥有孩子的节点，n&#x2F;2以下的节点一定是一个子节点，就从非子节点开始向上建立堆。</p>
<p>倒数第二层有n&#x2F;4个元素，每个元素最多往下down一次，倒数第三层有n&#x2F;8个元素，每个元素最多往下down两次……以此类推。最终是一个等差等比混合数列的求和，为**O(n)**的复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">	<span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">	<span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t = u;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (u != t)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">		<span class="built_in">down</span>(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">		u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure>



<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="一般哈希-存储结构"><a href="#一般哈希-存储结构" class="headerlink" title="一般哈希(存储结构)"></a>一般哈希(存储结构)</h4><p>x ∈ (-10^9^,10^9^)，h(x) ∈ (0,10^5^)</p>
<ol>
<li>x mod 10^5^  ∈  [0,10^5^]</li>
<li>冲突问题。</li>
</ol>
<p><strong>方法</strong></p>
<ol>
<li><p>拉链法</p>
<p> <img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646051867837.png" alt="拉链法"></p>
<p> 操作：</p>
<ol>
<li><p>添加(插入)</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646060882466.png" alt="插入"></p>
</li>
<li><p>查找</p>
</li>
<li><p>删除(一般不直接删除)。使用标识符</p>
</li>
</ol>
<p> 关于哈希表长度选取：</p>
<blockquote>
<p>比如大部分是偶数，这时候如果HASH数组容量是偶数，容易使原始数据HASH后不会均匀分布。<br>比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多<br>如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，冲突较小。</p>
<p>同样地，如果数据都是3的倍数，而HASH数组容量是3的倍数，HASH后也容易有冲突。</p>
<p>用一个质数则会减少冲突的概率。</p>
</blockquote>
<p> 选素数操作</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100000</span>;;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j*j &lt;= i;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>)    <span class="comment">//质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 模板代码：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开放寻址法</p>
<p> 开辟长度应为题目给出的 2~3 倍，质数。</p>
<p> 基本思路：</p>
<p> <img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646115363520.png" alt="开放寻址法"></p>
<p> 操作：</p>
<ol>
<li>添加</li>
<li>查找</li>
<li>删除(打标志，同上)，可将之归为查找一种</li>
</ol>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中存在，返回x的所在的位置(下标)；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><p>字符串前缀哈希法：</p>
<ol>
<li><p>先把每一个前缀的哈希值求出来(字符串 –&gt; 数字)。</p>
<ol>
<li><p>&#x3D;&#x3D;将字符串看成 <strong>P进制</strong> 数。&#x3D;&#x3D;</p>
</li>
<li><p>将 P进制 的数转为十进制的数。</p>
<p>小技巧：</p>
</li>
</ol>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646119205933.png" alt="字符串映射"></p>
<p>通过这样的方式，把任何一个字符串映射到从 0 ~ Q - 1 的一个数。</p>
<p>注意：</p>
<ol>
<li>一般情况下不能映射成 0。否则易冲突。   e.g. A 0; AA 0。</li>
<li>此类哈希不考虑冲突。  <ol>
<li>P 的经验值是131或13331，取这两个值的冲突概率低；</li>
<li>取模的数 Q 用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。</li>
</ol>
</li>
</ol>
</li>
<li><p>利用前缀哈希算出任意子串哈希</p>
<ol>
<li><p>将 h[L - 1] 往左移若干位，与 h[R] 对齐。</p>
</li>
<li><p>从 L ~ R 段的哈希值    h[R] - h[L-1] * p^(R-L+1)^</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646154233456.png" alt="L~R段哈希值"></p>
<p>此处用 unsigned long long 存储，便无需对Q(2^64^)取模，溢出即为取模。</p>
</li>
<li><p>关于预处理    h[i] &#x3D; h[i - 1] * p + str[i]</p>
</li>
</ol>
</li>
</ol>
<p>当要 <strong>判断两个字符串是否相等</strong> 的时候可以使用这种方法。</p>
<p>模板代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>能用KMP者大都可以字符串哈希实现，<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/description/4063/">4060. 字符串循环节 - AcWing题库</a> 例外。</p>
<h3 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h3><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>变长数组，倍增思想。</p>
<p>系统为某一程序分配空间时，所需时间与空间大小无关，与申请次数有关。故应减少倍增次数。</p>
<ol>
<li>size() &amp;emsp; 返回元素个数(所有容器都有)</li>
<li>empty() &amp;emsp; 返回是否为空(所有容器都有)</li>
<li>clear()  清空</li>
<li>front()&#x2F;back()</li>
<li>push_back()&#x2F;pop_back()</li>
<li>begin()&#x2F;end()   (end() 最后一个数的下一个位置)</li>
<li>[]</li>
<li>支持比较运算，按字典序(首字母)</li>
</ol>
<h4 id="pair-lt-int-int-gt"><a href="#pair-lt-int-int-gt" class="headerlink" title="pair&lt;int, int&gt;"></a>pair&lt;int, int&gt;</h4><p>存储二元组</p>
<ol>
<li><p>first, 第一个元素</p>
</li>
<li><p>second, 第二个元素</p>
</li>
<li><p>支持<strong>比较</strong>运算，以 <strong>first</strong> 为第一关键字，以 <strong>second</strong> 为第二关键字（字典序）</p>
</li>
<li><p>赋值</p>
<p> p &#x3D; make_pair(10,”abc”);</p>
<p> p &#x3D; {20,”abc”};</p>
</li>
<li><p>可以嵌套</p>
</li>
</ol>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><p>字符串</p>
<ol>
<li>szie()&#x2F;length()  返回字符串长度</li>
<li>empty()</li>
<li>clear()</li>
<li>substr(起始下标(从零开始)，(子串长度))  返回子串</li>
<li>c_str()  返回字符串所在字符数组的起始地址(头指针)</li>
</ol>
<h4 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>队列</p>
<ol>
<li>size()</li>
<li>empty()</li>
<li>push()  向队尾插入一个元素</li>
<li>front()  返回队头元素</li>
<li>back()  返回队尾元素</li>
<li>pop()  弹出队头元素</li>
<li><strong>没有</strong>clear</li>
</ol>
<h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><p>优先队列，默认是大根堆</p>
<ol>
<li><p>push()  插入一个元素</p>
</li>
<li><p>top()  返回堆顶元素</p>
</li>
<li><p>pop()  弹出堆顶元素</p>
</li>
<li><p>定义成 <strong>小根堆</strong> 的方式： </p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></p>
<p>表示优先队列后面的元素都要大于优先队列前面的元素</p>
</li>
<li><p><strong>没有</strong>clear</p>
</li>
</ol>
<h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>栈</p>
<ol>
<li>size()</li>
<li>empty()</li>
<li>push()  向栈顶插入一个元素</li>
<li>top()  返回栈顶元素</li>
<li>pop()  弹出栈顶元素</li>
<li><strong>没有</strong>clear</li>
</ol>
<h4 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>(加强版vector) 双端队列。效率相对低</p>
<ol>
<li>size()</li>
<li>empty()</li>
<li>clear()</li>
<li>front()&#x2F;back()</li>
<li>push_back()&#x2F;pop_back()</li>
<li>push_front()&#x2F;pop_front()</li>
<li>begin()&#x2F;end()</li>
<li>[]</li>
</ol>
<h4 id="set-map-multiset-multimap"><a href="#set-map-multiset-multimap" class="headerlink" title="set, map, multiset, multimap"></a>set, map, multiset, multimap</h4><p>基于平衡二叉树（红黑树），动态维护有序序列</p>
<ul>
<li>size()</li>
<li>empty()</li>
<li>clear()</li>
<li>begin()&#x2F;end()</li>
<li>++, – 返回前驱和后继，时间复杂度 O(logn)</li>
</ul>
<p>multi- ：支持重复元素</p>
<ol>
<li><p>set&#x2F;multiset</p>
<p>insert()  插入一个数<br>find()  查找一个数  (不存在返回end迭代器)<br>count()  返回某一个数的个数<br>erase()</p>
<ol>
<li>输入是一个数x，删除所有x   O(k + logn)     （k为个数)</li>
<li>输入一个迭代器，删除这个迭代器</li>
</ol>
<p><strong>&#x3D;&#x3D;lower_bound()&#x2F;upper_bound()&#x3D;&#x3D;</strong></p>
<ol>
<li><p>lower_bound(x)  返回<strong>大于等于</strong>x的最小的数的迭代器</p>
</li>
<li><p>upper_bound(x)  返回<strong>大于</strong>x的最小的数的迭代器</p>
</li>
<li><p>lower_bound( begin,end,num,greater<type>() ):</type></p>
<p>二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p>
<p>upper_bound( begin,end,num,greater<type>() ):</type></p>
<p>查找第一个小于num的数字</p>
</li>
</ol>
</li>
<li><p>map&#x2F;multimap</p>
<ol>
<li>insert()  插入的数是一个pair</li>
<li>erase()  输入的参数是pair或者迭代器</li>
<li>find()</li>
<li>[]   时间复杂度是 O(logn)      （数组是O(1))</li>
<li>lower_bound()&#x2F;upper_bound()</li>
</ol>
</li>
</ol>
<h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap"><a href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap" class="headerlink" title="unordered_set, unordered_map, unordered_multiset, unordered_multimap"></a>unordered_set, unordered_map, unordered_multiset, unordered_multimap</h4><p>哈希表</p>
<p>和上面类似，增删改查的时间复杂度是 O(1)。</p>
<p>不支持 lower_bound()&#x2F;upper_bound()，迭代器的++，–</p>
<h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><p>圧位</p>
<p>使用情况：bool 存储一个字节，使用压位。能够节省8倍空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>()  等价于~(所有位取反)</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>



<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="单链表-1"><a href="#单链表-1" class="headerlink" title="单链表"></a>单链表</h3><h4 id="AcWing-826-单链表"><a href="#AcWing-826-单链表" class="headerlink" title="AcWing 826. 单链表"></a>AcWing 826. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/828/">单链表</a></h4><p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li><p>向链表头插入一个数；</p>
</li>
<li><p>删除第 k 个插入的数后面的数；</p>
</li>
<li><p>在第 k 个插入的数后插入一个数。</p>
</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标为k点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k点的后一个点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;            </span><br><span class="line">            <span class="keyword">if</span>(!k)  head = ne[head];        <span class="comment">//k为0的情况,删除头结点</span></span><br><span class="line">            <span class="built_in">remove</span>(k<span class="number">-1</span>);        <span class="comment">//第k个插入数字 下标对应k-1	//如果初始化head = 0,idx = 1,则不用k-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(x,k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head;i != <span class="number">-1</span>;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;        <span class="comment">//当前值：e[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双链表-1"><a href="#双链表-1" class="headerlink" title="双链表"></a>双链表</h3><h4 id="AcWing-827-双链表"><a href="#AcWing-827-双链表" class="headerlink" title="AcWing 827. 双链表"></a>AcWing 827. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/829/">双链表</a></h4><p><strong>输入格式</strong></p>
<p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li><code>L x</code>，表示在链表的最左端插入数 x。</li>
<li><code>R x</code>，表示在链表的最右端插入数 x。</li>
<li><code>D k</code>，表示将第 k 个插入的数删除。</li>
<li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li>
<li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li>
</ol>
<p><strong>输出格式</strong></p>
<p>共一行，将整个链表从左到右输出。</p>
<p><strong>解析</strong></p>
<p>实际为<strong>两个</strong>操作。add,remove [ add(k,x),add(left,x),add(right,x) ]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],r[N],l[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>,idx = <span class="number">2</span>;      <span class="comment">//下标的模拟习惯为0与1做首末</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span>   <span class="comment">//节点k右边插入一个数   注意先后顺序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k,r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx,r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span>      <span class="comment">//删除节点k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k+<span class="number">1</span>,x);		<span class="comment">//第 k 个插入的数, 对应 k+1 下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>];i != <span class="number">1</span>;i = r[i])   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);     <span class="comment">//其实点为原首节点右一位，末节点为原末节点左一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈-1"><a href="#栈-1" class="headerlink" title="栈"></a>栈</h3><h4 id="AcWing-828-模拟栈"><a href="#AcWing-828-模拟栈" class="headerlink" title="AcWing 828. 模拟栈"></a>AcWing 828. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/830/">模拟栈</a></h4><p>实现一个栈，栈初始为空，支持四种操作：</p>
<ol>
<li>push x – 向栈顶插入一个数 x；</li>
<li>pop – 从栈顶弹出一个数；</li>
<li>empty – 判断栈是否为空；</li>
<li>query – 查询栈顶元素。</li>
</ol>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; stk[tt] &lt;&lt; endl;            <span class="comment">//插入时为 stk[++tt] = x ，直接输出 stk[tt];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AcWing-3302-表达式求值"><a href="#AcWing-3302-表达式求值" class="headerlink" title="AcWing 3302. 表达式求值"></a>AcWing 3302. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/3305/">表达式求值</a></h4><p>给定一个表达式，其中运算符仅包含 +,-,*,&#x2F;（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2+2)*(1+1)</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<p><strong>中间节点</strong>都是运算符，<strong>叶节点</strong>都是数字。<br><strong>中缀</strong>表达 		&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; <strong>后缀</strong>表达<br><img src="https://cdn.acwing.com/media/article/image/2021/11/21/95860_a66013284a-112101.png" alt="表达式.png"></p>
<img src="https://s2.loli.net/2022/02/07/hERxkJM9DwtKjOX.jpg" style="zoom:30%">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();                 <span class="comment">//注意a,b顺序</span></span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>() ; op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)    x = a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)   x = a-b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)   x = a*b;</span><br><span class="line">    <span class="keyword">else</span> x = a/b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))                                  <span class="comment">//数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>,j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                x = x*<span class="number">10</span> + str[j++] - <span class="string">&#x27;0&#x27;</span>;              <span class="comment">//注意要 - &#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)                                  </span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)  <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">//符号情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c])    <span class="built_in">eval</span>();     <span class="comment">//如果当前符号优先级高于栈顶，则入栈</span></span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>())  <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h3><h4 id="AcWing-829-模拟队列"><a href="#AcWing-829-模拟队列" class="headerlink" title="AcWing 829. 模拟队列"></a>AcWing 829. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/831/">模拟队列</a></h4><p>实现一个队列，队列初始为空，支持四种操作：</p>
<ol>
<li>push x – 向队尾插入一个数 x；</li>
<li>pop – 从队头弹出一个数；</li>
<li>empty – 判断队列是否为空；</li>
<li>query – 查询队头元素。</li>
</ol>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> que[N],hh,tt = <span class="number">-1</span>;		<span class="comment">//hh = 0，tt = -1 更方便操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh &lt;= tt)    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; que[hh] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="AcWing-830-单调栈"><a href="#AcWing-830-单调栈" class="headerlink" title="AcWing 830. 单调栈"></a>AcWing 830. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/832/">单调栈</a></h4><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<p>每一个元素只进栈一次，每一个元素最多只会出栈一次。总操作2n，复杂度为**O(n)**。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,skt[N],tt;   <span class="comment">//全局变量会自动初始化为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/king9666/article/details/103949090</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; skt[tt] &gt;= x)  tt--;    <span class="comment">//while     没 = 则错误</span></span><br><span class="line">        <span class="keyword">if</span>(tt)  cout &lt;&lt; skt[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        skt[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度：</p>
<p>内层循环每循环一次，tt-1；外层循环每循环一次，tt+1。</p>
<p>最多 +n 次，最多 -n 次。</p>
<p>整个时间复杂度是O(n)。</p>
<p>单调栈应用 —— <strong>Acwing 131. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/133/">直方图中最大的矩形</a></strong></p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/19_eac6c46017-2559_1.jpg" alt="直方图"></p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> l[N],r[N],h[N],q[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) , n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line"></span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)       <span class="comment">//第i个矩形的高度可向两侧扩展的左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            l[i] = i - q[tt];</span><br><span class="line">            q[++tt] = i;                <span class="comment">//q[tt]作为栈顶元素下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tt = <span class="number">0</span>,q[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>;--i)       <span class="comment">//第i个矩形的高度可向两侧扩展的右边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            r[i] = q[tt] - i;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  res = <span class="built_in">max</span>(res, (LL)h[i] * (l[i] + r[i] - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644674377127.png" alt="模拟过程"></p>
<h3 id="单调队列-1"><a href="#单调队列-1" class="headerlink" title="单调队列"></a>单调队列</h3><h4 id="AcWing-154-滑动窗口"><a href="#AcWing-154-滑动窗口" class="headerlink" title="AcWing 154. 滑动窗口"></a>AcWing 154. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/156/">滑动窗口</a></h4><p>给定一个大小为 n≤106 的数组。有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 k 个数字。每次滑动窗口向右移动一个位置。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3		//两个整数 n 和 k，分别代表数组长度和滑动窗口的长度</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3		//从左至右，每个位置滑动窗口中的最小值。</span><br><span class="line">3 3 5 5 6 7			//从左至右，每个位置滑动窗口中的最大值。</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;   	<span class="comment">//视情况，或while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;	<span class="comment">//注意是q[tt]而不是q[hh]</span></span><br><span class="line">        q[++tt] = i;                            	<span class="comment">//当前可能为最小值，故应在输出前插入</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);		<span class="comment">//注意等于号	</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];      </span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;     <span class="comment">//hh队列头 tt队列尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//维持滑动窗口的大小  判断队头是否已经划出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;           <span class="comment">//while亦可，但此题只有一次。不确定可使用while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;       <span class="comment">//单调队列</span></span><br><span class="line">        <span class="comment">//当队列不为空(hh &lt;= tt) 且 当队列队尾元素&gt;=当前元素时,那么队尾元素一定不是当前窗口最小值,删去队尾元素,加入当前元素</span></span><br><span class="line">        q[++tt] = i;            <span class="comment">//q[i]保存的是下标</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);     <span class="comment">//个数&gt;=k时才输出		</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;       <span class="comment">//大----&gt;小</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);			<span class="comment">//队头就是最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP-1"><a href="#KMP-1" class="headerlink" title="KMP"></a>KMP</h3><h4 id="AcWing-831-KMP字符串"><a href="#AcWing-831-KMP字符串" class="headerlink" title="AcWing 831. KMP字符串"></a>AcWing 831. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/833/">KMP字符串</a></h4><p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串 P 在模式串 S 中多次作为子串出现。求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">1000010</span>;</span><br><span class="line"><span class="comment">// int p[N],s[M];</span></span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];                  <span class="comment">//重新开始匹配时，可以把j最多移动多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">-1</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n - <span class="number">1</span>)				<span class="comment">//全往前挪了一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n + <span class="number">1</span>);</span><br><span class="line">            j = ne[j];                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>j &#x3D; ne[j];————重新开始匹配时，可以把j最多移动多少<br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_9b4e5e4a48-111804.png" alt="KMP"><br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_86296c8048-111802.png" alt="KMP"> </p>
<p>时间复杂度是O(n)。以第二个循环的j为例。j最多加m次,最多减m次.O(2m)—–&gt;O(m)。</p>
<p>上述方法所得下标：</p>
<table>
<thead>
<tr>
<th align="left">字符串</th>
<th align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp; a  b  a</th>
<th align="left">&amp;nbsp;&amp;nbsp;&amp;nbsp; a  b  a  b  a</th>
</tr>
</thead>
<tbody><tr>
<td align="left">下标</td>
<td align="left">0  1  2  3</td>
<td align="left">0  1  2  3  4  5</td>
</tr>
<tr>
<td align="left">next[]</td>
<td align="left">0  0  1</td>
<td align="left">0  0  1  2  3</td>
</tr>
</tbody></table>
<hr>
<p><strong>法二</strong></p>
<p>严版KMP字符串匹配算法 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16X4y137qw?from=search&seid=16643420370716168727&spm_id_from=333.337.0.0">求next数组</a>（单次匹配）<br><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/95860_5b7ce5f648-111801.png" alt="KMP"> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(String T,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(String S,String T,<span class="type">int</span> next[],<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.<span class="built_in">size</span>() &amp;&amp; j &lt;= T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;            <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];        <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i-T.<span class="built_in">size</span>();  <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法对应next数组</p>
<table>
<thead>
<tr>
<th>字符串</th>
<th>a  b  a  a  b  c  a  c</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>1  2  3  4  5  6  7  8</td>
</tr>
<tr>
<td>next[]</td>
<td>0  1  1  2  2  3  1  2</td>
</tr>
</tbody></table>
<p>推荐 <strong>法一</strong> 。</p>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><h4 id="AcWing-835-Trie字符串统计"><a href="#AcWing-835-Trie字符串统计" class="headerlink" title="AcWing 835. Trie字符串统计"></a>AcWing 835. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></h4><p>维护一个字符串集合，支持两种操作：</p>
<ol>
<li>I x 向集合中插入一个字符串 x；</li>
<li>Q x 询问一个字符串在集合中出现了多少次。</li>
</ol>
<p>共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;  <span class="comment">//下标是0的点，既是根节点，也是空节点</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>],str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)    <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="AcWing-143-最大异或对"><a href="#AcWing-143-最大异或对" class="headerlink" title="AcWing 143. 最大异或对"></a>AcWing 143. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/145/">最大异或对</a></h4><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<ol>
<li><p>暴力&amp;emsp;O(n) * n</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)	<span class="comment">//枚举第一个数</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;++j)	<span class="comment">//枚举第二个数</span></span><br><span class="line">    	res = <span class="built_in">max</span>(res,a[i] ^ a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Trie树  O(31) * n(十万) ≈ nlogn</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645087093192.png" alt="保存与筛选"></p>
<p>思路：从前往后枚举，先 <strong>插入</strong> 再 <strong>查询</strong> (也可先查询再插入，但开始空要加判断)。</p>
<p>​	查询：查询 ai 前面和 ai 异或最大的值。</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645103981023.png" alt="思路"></p>
</li>
</ol>
<p>整体代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"><span class="type">int</span> n,a[N],son[M][<span class="number">2</span>],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])             </span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">        <span class="comment">/* 循环之内的内容也可以写为</span></span><br><span class="line"><span class="comment">        int &amp;s = son[p][x &gt;&gt; i &amp; 1];</span></span><br><span class="line"><span class="comment">        if (!s) s = ++ idx;</span></span><br><span class="line"><span class="comment">        p = s;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    </span><br><span class="line">        res = <span class="built_in">max</span>(res,<span class="built_in">search2</span>(a[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h3><h4 id="AcWing-836-合并集合"><a href="#AcWing-836-合并集合" class="headerlink" title="AcWing 836. 合并集合"></a>AcWing 836. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/838/">合并集合</a></h4><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p>
<p>现在要进行 m 个操作，操作共有两种：</p>
<ol>
<li>M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li>
<li>Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中。</li>
</ol>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">//返回 x 的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;a, &amp;b);		<span class="comment">//同时输入字符串和数字的最合适方法</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)  <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911891583.png" alt="优化过程"></p>
<p>find() 函数 <code>p[x] = find(p[x])</code> 在回溯过程中路径压缩优化</p>
</blockquote>
<h4 id="AcWing-837-连通块中点的数量"><a href="#AcWing-837-连通块中点的数量" class="headerlink" title="AcWing 837. 连通块中点的数量"></a>AcWing 837. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h4><p>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p>
<p>现在要进行 m 个操作，操作共有三种：</p>
<ol>
<li>C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li>
<li>Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li>
<li>Q2 a，询问点 a 所在连通块中点的数量。</li>
</ol>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<blockquote>
<p>同一个连通块之意：从 a 可以走到 b ，从 b 可以走到 a。</p>
</blockquote>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911365103.png" alt="所给样例"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="keyword">continue</span>;</span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);	</span><br><span class="line">            <span class="comment">//若不使用下面的 a = find(a), b = find(b); 上面两个语句次序不能兑换。否则 p[find(a)] 改变值会影响到 cnt[find(a)] 的值。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line">            <span class="comment">// a = find(a), b = find(b);</span></span><br><span class="line">            <span class="comment">// if (a != b)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     p[a] = b;</span></span><br><span class="line">            <span class="comment">//     cnt[b] += cnt[a];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="AcWing-240-食物链"><a href="#AcWing-240-食物链" class="headerlink" title="AcWing 240. 食物链"></a>AcWing 240. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/242/">食物链</a></h4><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p>
<p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p>
<p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p>
<p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p>
<p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p>
<ol>
<li>当前的话与前面的某些真的话冲突，就是假话；</li>
<li>当前的话中 X 或 Y 比 N 大，就是假话；</li>
<li>当前的话表示 X 吃 X，就是假话。</li>
</ol>
<p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<p>样例图示</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645199664162.png" alt="样例图示"></p>
<p><strong>思路</strong>：</p>
<p>并查集中，维护每个点到根节点的 <strong>距离</strong> 。将距离分为三大类：</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250329339.png" alt="三类距离"></p>
<ol>
<li>何为距离，即是 <code>关于代的关系</code> ，对 <strong>3</strong> 取模以示之。</li>
</ol>
<p>  <img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250388289.png" alt="关于代的关系"></p>
<ol start="2">
<li><p>每个点到父节点距离如何维护？</p>
<p>存的时候存其对父节点距离。在做 <strong>路径压缩</strong> 时，将每个点到 <strong>父节点</strong> 的距离更新成对 <strong>根节点</strong> 的距离。</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250849185.png" alt="距离维护"></p>
</li>
<li><p>只需要知道每个点与根的关系，即可判断两个点之间的关系。</p>
</li>
<li><p>关于find</p>
</li>
<li><p>存下父节点的根节点；</p>
<p>再加上父节点到其根节点的距离(把d[x]更新成到根节点的距离)；</p>
<p>把当前节点的根节点指向最终根节点。</p>
<p><strong>d[i]：第 i 个节点到其父节点距离</strong> <a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/15938/">ref：find()函数调用过程</a></p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/41774_bd485030c0-JIE.jpg" alt="find函数"></p>
</li>
</ol>
<p>整体代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,x,y;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; x &gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)  res++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x),py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y]) % <span class="number">3</span> )  res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span> )    res ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h3 id="堆-1"><a href="#堆-1" class="headerlink" title="堆"></a>堆</h3><h4 id="AcWing-838-堆排序"><a href="#AcWing-838-堆排序" class="headerlink" title="AcWing 838. 堆排序"></a>AcWing 838. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/840/">堆排序</a></h4><p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>] &lt; a[t]) t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>+<span class="number">1</span>] &lt; a[t]) t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u],a[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; a[u/<span class="number">2</span>] &gt; a[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u/<span class="number">2</span>],a[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i ;--i)    <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= n ;++i)    up(i);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        a[<span class="number">1</span>] = a[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="AcWing-839-模拟堆"><a href="#AcWing-839-模拟堆" class="headerlink" title="AcWing 839. 模拟堆"></a>AcWing 839. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/841/">模拟堆</a></h4><p>维护一个集合，初始时集合为空，支持如下几种操作：</p>
<ol>
<li><code>I x</code>，插入一个数 x；</li>
<li><code>PM</code>，输出当前集合中的最小值；</li>
<li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li>
<li><code>D k</code>，删除第 k 个插入的数；</li>
<li><code>C k x</code>，修改第 k 个插入的数，将其变为 x；</li>
</ol>
<p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">I -10</span><br><span class="line">PM</span><br><span class="line">I -10</span><br><span class="line">D 1</span><br><span class="line">C 2 8</span><br><span class="line">I 6</span><br><span class="line">PM</span><br><span class="line">DM</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<ul>
<li><p>难点</p>
<p>从第 k 个插入点找到对应元素，又要从堆里的元素找回来。</p>
<p>ph[k] 与 hp[j] ：<code>第 k 个插入点的对应下标</code> 与 <code>堆中下标为j的点对应的k</code>。(两者如反函数关系)</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645004854237.png" alt="交换第k个插入数"></p>
<p>[如何理解模拟堆中的heap_swap，hp<a target="_blank" rel="noopener" href="https://www.acwing.com/solution/content/5661/">N], ph[N]？ - AcWing</a></p>
<ol>
<li><p>idx</p>
<p><code>h[k] = x</code>, h数组存的是节点的值，按理来说应该<code>h[idx]</code>来存，但是节点<strong>位置</strong>总是在变的，因此需维护k和idx的映射关系。</p>
<p>用<code>ph数组</code>来表示<code>ph[idx] = k</code>(idx到下标), 那么结点值为<code>h[ph[idx]]</code>, 儿子为<code>ph[idx] * 2</code>和<code>ph[idx] * 2 + 1</code>, 这样值和儿子结点通过idx联系在一起。</p>
</li>
<li><p>hp与ph数组</p>
<ol>
<li><p><strong>ph数组</strong> 主要用于帮助从idx映射到下标k；</p>
</li>
<li><p>在<code>swap</code>操作中我们输入是堆数组的下标，需要hp数组方便查找idx。即：</p>
<p><strong>hp数组</strong> 查找每个<strong>堆数组的k下标</strong> 对应idx（第idx个<strong>插入</strong>）</p>
</li>
</ol>
</li>
<li><p>操作实例</p>
<p>交换函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    size ++ ;</span><br><span class="line">    idx ++ ; 						<span class="comment">//记录第几次插入（设置新的idx）</span></span><br><span class="line">    ph[idx] = size, hp[size] = idx;	<span class="comment">//每次插入都是在堆尾插入（设置ph与hp）</span></span><br><span class="line">    h[ph[idx]] = x; 				<span class="comment">//记录插入的值 </span></span><br><span class="line">    <span class="built_in">up</span>(ph[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除</p>
<ol>
<li>找到第idx个插入元素在堆数组中的位置（堆数组下标）</li>
<li>与堆尾元素交换</li>
<li>在原来第idx个元素所在的位置进行down和up操作。（up，down，swap操作的都输入都是<strong>下标</strong>）</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    k = ph[idx]; 		<span class="comment">//必须要保存当前被删除结点的下标</span></span><br><span class="line">    <span class="built_in">heap_swap</span>(k, size);	<span class="comment">//第idx个插入的元素移到了堆尾，此时ph[idx]指向堆尾 </span></span><br><span class="line">    size --;  			<span class="comment">//删除堆尾</span></span><br><span class="line">    <span class="built_in">up</span>(k);				<span class="comment">//k是之前记录被删除的结点的下标</span></span><br><span class="line">    <span class="built_in">down</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>整体代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t])   t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t])   t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt,hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// scanf(&quot;%d&quot;, &amp;k);</span></span><br><span class="line">            <span class="comment">// heap_swap(ph[k],idx);</span></span><br><span class="line">            <span class="comment">// idx --;</span></span><br><span class="line">            <span class="comment">// down(ph[k]),up(ph[k]);	//0223这么做错误,k已经改变</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];              	<span class="comment">//0216遗漏</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);				<span class="comment">//这两个函数有且只有一个执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="哈希表-1"><a href="#哈希表-1" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="AcWing-840-模拟散列表"><a href="#AcWing-840-模拟散列表" class="headerlink" title="AcWing 840. 模拟散列表"></a>AcWing 840. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/842/">模拟散列表</a></h4><p>维护一个集合，支持如下几种操作：</p>
<ol>
<li><code>I x</code>，插入一个数 x；</li>
<li>Q x，询问数 x 是否在集合中出现过；</li>
</ol>
<p>现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<ol>
<li><p>拉链法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;		<span class="comment">//此处 e 和 ne 同单链表是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N ) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k];i != <span class="number">-1</span>;i = ne[i])			</span><br><span class="line">    <span class="comment">//h[k]存的链表第一个节点下标，e[i]为当前点的值；做完操作后，ne[i]为下一个点的下标。空指针的下标为 -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>开放寻址法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="type">int</span> h[N],null = <span class="number">0x3f3f3f3f</span>;		<span class="comment">//null 不在 x 范围内的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N)  k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);		<span class="comment">//memset函数按字节，h为int，四个字节，每个皆是0x3f(8位)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            h[k] = x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="AcWing-841-字符串哈希"><a href="#AcWing-841-字符串哈希" class="headerlink" title="AcWing 841. 字符串哈希"></a>AcWing 841. <a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/843/">字符串哈希</a></h4><p>给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。</p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<p>p 数组的意义，便是用来存储 p 的次方。因为公式内有 p 的次方，故先将 p 预处理出来。</p>
<p>h 数组：某一个前缀的哈希值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,P = <span class="number">131</span>;</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>] * p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    cin &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] * P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>] * P + str[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2))    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用：<a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/141/">139. 回文子串的最大长度 - AcWing题库</a></p>
<p><strong>输入样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p><strong>输出样例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure>

<p><strong>解析</strong></p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646209987825.png" alt="回文子串的最大长度"></p>
<p>前期步骤同上，而后</p>
<ul>
<li>长度是奇数</li>
</ul>
<ol>
<li><p>枚举中点；</p>
</li>
<li><p>二分半径。</p>
<p>每次二分一个长度，判断左右两边的哈希值是否一样。若同，扩长度；否，缩。</p>
</li>
</ol>
<ul>
<li><p>长度是偶数</p>
<pre><code>  在每一个字母之间插入符号 ，将其化为奇数。
</code></pre>
</li>
</ul>
<p>下标的计算</p>
<p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646213451004.png" alt="逆序下标转换"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hl 正序字符串所有前缀的哈希值；hr 逆序字符串所有前缀的哈希值。</span></span><br><span class="line"><span class="comment">//逗号表达式返回值为最后一式的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>,P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL hl[N],hr[N],p[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(ULL h[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s+<span class="number">1</span> , <span class="built_in">strcmp</span>(s+<span class="number">1</span>,<span class="string">&quot;END&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);                    </span><br><span class="line">        <span class="comment">//size_t strlen(const char *str)</span></span><br><span class="line">        <span class="comment">//从str开始到第一个&#x27;\0&#x27;为止的字符串的长度，长度不包括&#x27;\0&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n*<span class="number">2</span>;i &gt; <span class="number">0</span>;i -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i/<span class="number">2</span>];</span><br><span class="line">            s[i<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">        <span class="comment">//a b c b a</span></span><br><span class="line">        <span class="comment">//# a # b # c # b # a</span></span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = n;i &lt;= n,j &gt; <span class="number">0</span>;++i,--j)</span><br><span class="line">        &#123;</span><br><span class="line">            hl[i] = hl[i<span class="number">-1</span>]*P + s[i];</span><br><span class="line">            hr[i] = hr[i<span class="number">-1</span>]*P + s[j];</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求以s[i]为对称中心的回文串的最大半径。 二分回文串的半径</span></span><br><span class="line">        <span class="comment">//mid为回文串半径[...]S[i][...]  --&gt;  [长度mid][长度1][长度mid]  --&gt;  s[i-mid]...s[i-1] s[i] s[i+1]...s[i+mid]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)           <span class="comment">//扩容后的字符串起始下标应为 2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(i<span class="number">-2</span>,n-i);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;                               <span class="comment">//注意 + 1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(hl,i-mid,i<span class="number">-1</span>) == <span class="built_in">get</span>(hr,n-(i+mid)+<span class="number">1</span>,n-(i+<span class="number">1</span>)+<span class="number">1</span>)) l = mid;     <span class="comment">//回文串半径可以变大</span></span><br><span class="line">                <span class="keyword">else</span>    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s[i-l]...s[i-1] s[i] s[i+1]...s[i+l]</span></span><br><span class="line">            <span class="comment">//回文串总长度2*l+1=l+1+l</span></span><br><span class="line">            <span class="keyword">if</span>(s[i-l] == <span class="string">&#x27;#&#x27;</span>)   res = <span class="built_in">max</span>(res,l);   <span class="comment">//回文串两边为&#x27;#&#x27;，即字母比&#x27;#&#x27;少一个</span></span><br><span class="line">            <span class="keyword">else</span>    res = <span class="built_in">max</span>(res,l+<span class="number">1</span>);             <span class="comment">//回文串两边为字母，即字母比&#x27;#&#x27;多一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,t++,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>chapter 2 END。	</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://xiaochengye.github.io">xiaochengYe</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://xiaochengye.github.io/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/">https://xiaochengye.github.io/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://xiaochengye.github.io" target="_blank">HaoSengYee</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">Acwing算法基础课</a></div><div class="post_share"><div class="social-share" data-image="/img/acwing.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/"><img class="prev-cover" src="/img/acwing.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Acwing 算法基础课 chapter 3</div></div></a></div><div class="next-post pull-right"><a href="/2021/12/03/Make%20Hexo%20Blog/"><img class="next-cover" src="/img/hg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Bulid my blog by Hexo</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/" title="Acwing 算法基础课 chapter 1"><img class="cover" src="/img/acwing.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-17</div><div class="title">Acwing 算法基础课 chapter 1</div></div></a></div><div><a href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/" title="Acwing 算法基础课 chapter 3"><img class="cover" src="/img/acwing.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-08</div><div class="title">Acwing 算法基础课 chapter 3</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">xiaochengYe</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#lecture-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">lecture 2 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.1.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.1.3.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.1.4.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.1.5.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.1.6.</span> <span class="toc-text">单调队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP"><span class="toc-number">1.1.7.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie%E6%A0%91"><span class="toc-number">1.1.8.</span> <span class="toc-text">Trie树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.9.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.9.1.</span> <span class="toc-text">朴素并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4size%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.9.2.</span> <span class="toc-text">维护size的并查集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%88%B0%E7%A5%96%E5%AE%97%E8%8A%82%E7%82%B9%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.1.9.3.</span> <span class="toc-text">维护到祖宗节点距离的并查集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.1.10.</span> <span class="toc-text">堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.1.11.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%93%88%E5%B8%8C-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.11.1.</span> <span class="toc-text">一般哈希(存储结构)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.1.11.2.</span> <span class="toc-text">字符串哈希</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.12.</span> <span class="toc-text">STL简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">1.1.12.1.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pair-lt-int-int-gt"><span class="toc-number">1.1.12.2.</span> <span class="toc-text">pair&lt;int, int&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string"><span class="toc-number">1.1.12.3.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-number">1.1.12.4.</span> <span class="toc-text">queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#priority-queue"><span class="toc-number">1.1.12.5.</span> <span class="toc-text">priority_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-number">1.1.12.6.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-number">1.1.12.7.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#set-map-multiset-multimap"><span class="toc-number">1.1.12.8.</span> <span class="toc-text">set, map, multiset, multimap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-set-unordered-map-unordered-multiset-unordered-multimap"><span class="toc-number">1.1.12.9.</span> <span class="toc-text">unordered_set, unordered_map, unordered_multiset, unordered_multimap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitset"><span class="toc-number">1.1.12.10.</span> <span class="toc-text">bitset</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.</span> <span class="toc-text">题目</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.2.1.</span> <span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-826-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">AcWing 826. 单链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8-1"><span class="toc-number">1.2.2.</span> <span class="toc-text">双链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-827-%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">AcWing 827. 双链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-828-%E6%A8%A1%E6%8B%9F%E6%A0%88"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">AcWing 828. 模拟栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-3302-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">AcWing 3302. 表达式求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97-1"><span class="toc-number">1.2.4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-829-%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">AcWing 829. 模拟队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88-1"><span class="toc-number">1.2.5.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-830-%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">AcWing 830. 单调栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97-1"><span class="toc-number">1.2.6.</span> <span class="toc-text">单调队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-154-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">AcWing 154. 滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP-1"><span class="toc-number">1.2.7.</span> <span class="toc-text">KMP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-831-KMP%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">AcWing 831. KMP字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trie"><span class="toc-number">1.2.8.</span> <span class="toc-text">Trie</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-835-Trie%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">AcWing 835. Trie字符串统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-143-%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%AF%B9"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">AcWing 143. 最大异或对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86-1"><span class="toc-number">1.2.9.</span> <span class="toc-text">并查集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-836-%E5%90%88%E5%B9%B6%E9%9B%86%E5%90%88"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">AcWing 836. 合并集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-837-%E8%BF%9E%E9%80%9A%E5%9D%97%E4%B8%AD%E7%82%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">AcWing 837. 连通块中点的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-240-%E9%A3%9F%E7%89%A9%E9%93%BE"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">AcWing 240. 食物链</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86-1"><span class="toc-number">1.2.10.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-838-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">AcWing 838. 堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-839-%E6%A8%A1%E6%8B%9F%E5%A0%86"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">AcWing 839. 模拟堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-1"><span class="toc-number">1.2.11.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-840-%E6%A8%A1%E6%8B%9F%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">AcWing 840. 模拟散列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AcWing-841-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.11.2.</span> <span class="toc-text">AcWing 841. 字符串哈希</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/08/15/hello-world/" title="Hello World"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/2022/08/15/hello-world/" title="Hello World">Hello World</a><time datetime="2022-08-15T13:23:25.699Z" title="发表于 2022-08-15 21:23:25">2022-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/" title="Acwing 算法基础课 chapter 3"><img src="/img/acwing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Acwing 算法基础课 chapter 3"/></a><div class="content"><a class="title" href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/" title="Acwing 算法基础课 chapter 3">Acwing 算法基础课 chapter 3</a><time datetime="2022-08-07T17:13:17.000Z" title="发表于 2022-08-08 01:13:17">2022-08-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/" title="Acwing 算法基础课 chapter 2"><img src="/img/acwing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Acwing 算法基础课 chapter 2"/></a><div class="content"><a class="title" href="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/" title="Acwing 算法基础课 chapter 2">Acwing 算法基础课 chapter 2</a><time datetime="2022-03-02T16:01:08.000Z" title="发表于 2022-03-03 00:01:08">2022-03-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/03/Make%20Hexo%20Blog/" title="Bulid my blog by Hexo"><img src="/img/hg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Bulid my blog by Hexo"/></a><div class="content"><a class="title" href="/2021/12/03/Make%20Hexo%20Blog/" title="Bulid my blog by Hexo">Bulid my blog by Hexo</a><time datetime="2021-12-03T10:24:28.000Z" title="发表于 2021-12-03 18:24:28">2021-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/" title="Acwing 算法基础课 chapter 1"><img src="/img/acwing.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Acwing 算法基础课 chapter 1"/></a><div class="content"><a class="title" href="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/" title="Acwing 算法基础课 chapter 1">Acwing 算法基础课 chapter 1</a><time datetime="2021-10-17T10:24:28.000Z" title="发表于 2021-10-17 18:24:28">2021-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By xiaochengYe</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>