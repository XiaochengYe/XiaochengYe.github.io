<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Acwing 算法基础课 chapter 3</title>
      <link href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/"/>
      <url>/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/</url>
      
        <content type="html"><![CDATA[<h1>lecture 3 搜索与图论</h1><h2 id="DFS">DFS</h2><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303233243772.png" alt="BFS&amp;DFS"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="842-排列数字-AcWing题库"><a href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></h3><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>DFS：此题 “暴搜” ，首先应考虑以什么样的 <strong>顺序</strong> 搜索。</p><p><code>if(n == 3)</code></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303234411488-16608868431321.png" alt="DFS"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303234606743-16608873742005.png" alt="DFS"></p><p>注：</p><ol><li>每一次只会存当前路径，回溯的时候系统即已释放。</li><li>回溯之后记得 <strong>恢复现场</strong> 。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,path[N],st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="number">1</span>;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// path[u] = 0;     //可不用恢复,自动覆盖</span></span><br><span class="line">            st[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者结合位运算判别是否已选</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//考虑state的二进制表示，如果第i位是1，表示当前数已经被用过了，否则表示没被用过。所以如果i已经被用过了，则需要跳过。</span></span><br><span class="line">        <span class="comment">//state不是数组，在每层里面没有修改过state，相当于st[i]在回溯之后就自动变成false了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i ;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="843-n-皇后问题-AcWing题库"><a href="https://www.acwing.com/problem/content/845/">843. n-皇后问题 - AcWing题库</a></h3><p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>剪枝：如若当前方案已不可行，不必再往下搜。</p><p>两条对角线(对角线长度为2n-1)：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220304230046330.png" alt="dg&amp;udg"></p><p>对角线：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220305171115034.png" alt="对角线"></p><p>为了防止<code>y-x</code>为复数，再加上 <code>n</code> 。</p><p><strong>第一种搜索顺序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按行枚举，保证每行只有一个，无需row</span></span><br><span class="line"><span class="comment">//u表示第u行，i表示第i列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[u-i+n])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[u-i+n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//恢复</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[u-i+n] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种搜索顺序</strong></p><p>比起上述提炼行优化，此法更原始。结合行逐项来考虑，也可以写成如下。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220322220511867.png" alt="n皇后"></p><p>x y 为坐标，s 为皇后。每次枚举完当前格子，转移到下一个格子，一行最后一格换行。</p><p>x = n 即枚举完最后一行，停止。如果摆了n个皇后，输出。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（DFS按每个元素枚举）时间复杂度O(2^n^2)，比前一种方法略复杂。</span></span><br><span class="line"><span class="comment">//时间复杂度分析：每个位置都有两种情况，总共有 n^2 个位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> s)</span>         <span class="comment">// s表示已经放上去的皇后个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n)  y = <span class="number">0</span>,x++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;                     <span class="comment">// x==n说明已枚举完n^2个位置</span></span><br><span class="line">        <span class="keyword">if</span>(s == n)&#123;                 <span class="comment">// s==n说明成功放上去n个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分支1：放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[y - x + n] &amp;&amp; !udg[y + x])&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[y-x+n] = udg[y+x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[y-x+n] = udg[y+x] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分支2：不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS">BFS</h2><p>“有<strong>最短路</strong>”：搜到的点离当前越来越远(前提是权重一致)。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.初识赋值队头</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.只要队不为空</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//3.扩展队头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="844-走迷宫-AcWing题库"><a href="https://www.acwing.com/problem/content/846/">844. 走迷宫 - AcWing题库</a></h3><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220403215840059.png" alt="走迷宫"></p><p>由于终点在第 8 层扩展到，故其路程即为 8 。</p><blockquote><p>四点扩展：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220403221317576.png" alt="四点扩展"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g存了图</span></span><br><span class="line"><span class="comment">//d表示每个点到起点的距离。</span></span><br><span class="line"><span class="comment">//可以用向量 dx 来表示四点扩展。</span></span><br><span class="line"><span class="comment">//d[x][y] = -1。第一次走过才算最短距离，否则就不算。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">PII q[N*N];<span class="comment">//手写队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">//四点扩展</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i] ,y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何输出路径？另开数组 pre[N] [N] 记录。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">PII q[N*N],pre[N][N];              <span class="comment">//路劲记录数组pre</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i] ,y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                pre[x][y] = t;             <span class="comment">//记录上一点</span></span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒着输出路劲</span></span><br><span class="line">    <span class="type">int</span> x = n<span class="number">-1</span>,y = m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x||y)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">auto</span> t = pre[x][y];</span><br><span class="line">        x = t.first,y = t.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="845-八数码-AcWing题库"><a href="https://www.acwing.com/problem/content/847/">845. 八数码 - AcWing题库</a></h3><p>交换过程如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">x <span class="number">4</span> <span class="number">6</span>   <span class="number">4</span> x <span class="number">6</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">8</span>   <span class="number">7</span> <span class="number">5</span> <span class="number">8</span>   <span class="number">7</span> x <span class="number">8</span>   <span class="number">7</span> <span class="number">8</span> x</span><br></pre></td></tr></table></figure><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>基本思路：最小步数——<strong>BFS</strong> 。从起点到终点，步的权重为1，最少需要走多少步。</p><p>难点：</p><ol><li>状态表示3*3格(队列 ?)</li><li>如何记录每个状态的距离  (dist ?)</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1234X5678&quot;</span></span><br><span class="line">queue&lt;string&gt; q</span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;dist</span><br></pre></td></tr></table></figure><p>处理状态</p><ol><li>将字符串恢复3*3矩阵；</li><li>移动；</li><li>转化为字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//目标状态</span></span><br><span class="line">    string goal = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="comment">//转移数组</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化队列和dist数组</span></span><br><span class="line">    queue&lt;string&gt;q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt;dist;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//记录当前状态的距离，如果是最终状态则返回距离</span></span><br><span class="line">        <span class="type">int</span> distance = dist[t];</span><br><span class="line">        <span class="keyword">if</span>(t == goal)   <span class="keyword">return</span> distance;</span><br><span class="line">        <span class="comment">//查询x在字符串中的下标，然后转换为在矩阵中的坐标</span></span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> x = k/<span class="number">3</span>,y = k%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//求转移后x的坐标</span></span><br><span class="line">            <span class="type">int</span> a = x + dx[i],b = y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span>+b]);</span><br><span class="line">                <span class="comment">//当前状态是第一次遍历，记录距离，入队</span></span><br><span class="line">                <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(t))</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还原状态，准备下一种转换情况</span></span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span>+b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无法转换到目标状态，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        start += c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树与图的深度优先遍历">树与图的深度优先遍历</h2><ol><li><p>树与图的存储</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220406211821304.png" alt="有向图的存储"></p><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向 <strong>图的存储</strong>。</p><ol><li><p>邻接矩阵：g[a][b] 存储边a-&gt;b   ；不适合稀疏</p></li><li><p>邻接表</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。</span></span><br><span class="line"><span class="comment">//h[k]存储这个单链表的头结点；e[N]:当前节点对应图中编号。</span></span><br><span class="line"><span class="comment">//即：e 存了节点值，ne 和 h 存了数组下标</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>树与图的遍历</p><ol><li><p>深度优先遍历</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407213022270.png" alt="深度优先遍历"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>宽度优先遍历</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407213058892.png" alt="宽度优先遍历"></p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过bool数组：哪些点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="846-树的重心-AcWing题库"><a href="https://www.acwing.com/problem/content/848/">846. 树的重心 - AcWing题库</a></h3><p>给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><p>题意</p><ol><li><p>删除1，三个连通块。最多者为4。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214122495.png" alt="-1连通块"></p></li><li><p>删除2，三个连通块。最多者为6。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214250029.png" alt="-2连通块"></p><p>……</p></li></ol></li><li><p>分析</p><p>求每一个子树点数大小，考虑深度优先遍历。</p><p>下面的点数，递归，DFS过程中可以求出每个子树的点数。上面的点数，总数相减。</p><p>如：删去4。每个子节点(集)为一部分，父节点及以上是另一部分。子节点的size可以返回得到，父可以总数相减。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214741679.png" alt="DFS"></p><p>树与图的遍历与边数和点数有关。时间复杂度BFS与DFS都是 <strong>O(m+n)</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span>*N;      <span class="comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span></span><br><span class="line"><span class="type">int</span> h[N];               <span class="comment">//邻接表存储树</span></span><br><span class="line"><span class="type">int</span> e[M],ne[M];         <span class="comment">//存储元素及列表next值</span></span><br><span class="line"><span class="type">int</span> idx;                <span class="comment">//单链表指针</span></span><br><span class="line"><span class="type">int</span> n;                  <span class="comment">//输入节点数</span></span><br><span class="line"><span class="type">int</span> ans = N;            <span class="comment">//返回结果</span></span><br><span class="line"><span class="type">bool</span> st[N];             <span class="comment">//是否已被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以 u 为根的子树中点的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;    <span class="comment">//删掉某个节点之后，最大的连通块节点数</span></span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//每个节点访问一次</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;<span class="comment">//当前那算一个点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问u的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];       <span class="comment">//每个节点的编号不同，用编号为下标标记是否被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);         <span class="comment">// s 表当前子树的大小 </span></span><br><span class="line">            res = <span class="built_in">max</span>(res,s);       <span class="comment">// 记录最大联通子图的节点数</span></span><br><span class="line">            sum += s;             <span class="comment">// 以j为根的树的节点数(以儿子为根节点的子树是以u为根节点的子树的一部分)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res,n-sum);       <span class="comment">//注意是 -sum</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res,ans);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="built_in">add</span>(b,a);     <span class="comment">//无向图</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//任选一节点标号 &lt;= n</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>此处并不是回溯，每个点搜到一次即可。故无需还原为 false</li><li>搜索是搜索图当中的节点编号，不是边。idx存的是边。</li></ul><h2 id="树与图的广度-宽度-优先遍历">树与图的广度(宽度)优先遍历</h2><h3 id="847-图中点的层次-AcWing题库"><a href="https://www.acwing.com/problem/content/849/">847. 图中点的层次 - AcWing题库</a></h3><p><strong>输入格式</strong><br>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 1 的边。</p><p><strong>输出格式</strong><br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ol><li>点的权重都是1</li><li>最短路</li></ol><p>——BFS</p><p>宽搜求最短距离，<strong>第一次</strong>扩展到某个点，即为起点到它的最短距离/路径。(后面再遍历就不是了)</p><p>用宽搜框架搜索图，流程即是将图的结构结合到宽搜上。</p><p>宽搜框架搜索图：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220427215621594.png" alt="宽搜框架搜索图"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">//点和边</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;    <span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> d[N],q[N];      <span class="comment">//距离 队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;              <span class="comment">//d[i] 节点 i 的距离。易错为d[0] = 0。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)          <span class="comment">//没有被访问过</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;       <span class="comment">//数组模拟队列  扩展每个点的临边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><p>有向无环图(拓扑图)一定有拓扑序列，图中任意一对顶点u和v，若边 (u,v)∈E (G)，u在线性序列中出现在v<strong>之前</strong>。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220718212455089.png" alt="所有边都是从前指向后"></p><p>顶点 v 的<strong>入度</strong>是指以 v 为头的弧的数目；顶点v的<strong>出度</strong>(outdegree) 是指以 v 为尾的弧的数目。</p><p>拓扑系列的构建：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220718225229891.png" alt="构建拓扑系列"></p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：拓扑序不唯一。</p><h3 id="848-有向图的拓扑序列-AcWing题库"><a href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing题库</a></h3><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p><p><strong>输出格式</strong></p><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt] = i;<span class="comment">//将入度为零的 点 入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j]--;<span class="comment">//删除点t指向点j的 边</span></span><br><span class="line">            <span class="keyword">if</span>(!d[j])   <span class="comment">//如果 点j 的入度为零了,就将点j入队</span></span><br><span class="line">                q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n<span class="number">-1</span>;<span class="comment">//如果n个点都入队了话,那么该图为拓扑图,返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);        <span class="comment">//注意：记得初始化h</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">toposort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);<span class="comment">//队列中的点的次序就是拓扑序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路">最短路</h2><p><strong>知识结构图</strong></p><p>n 点数，m 边数。</p><ol><li><p>单源最短路</p><p>求从一个点到其他点的最短距离。</p><ol><li><p>所有边权都是正数</p><ul><li><p>朴素的 Dijkstra 算法（与边数无关，适合<strong>稠密图</strong>）</p><p>O(n^2)</p></li><li><p>堆优化版的 Dijkstra 算法  （<strong>稀疏图</strong>)</p><p>O(mlogn)  —— 总共需要遍历 m 条边，插入数据修改小根堆的时间复杂度为 O(logn)</p></li></ul></li><li><p>存在负权边</p><ul><li><p>bellman-ford 算法</p><p>O(nm)</p></li><li><p>spfa 算法</p><p>一般O(m)，最坏 O(nm)</p></li></ul></li></ol></li><li><p>多源汇最短路</p><ul><li><p>Floyd 算法</p><p>O(n^3)</p></li></ul><p>源点：起点</p><p>汇点：终点</p><p>其中一个点到另一个点的最短距离。</p></li></ol><p>侧重于 <strong>建图</strong> ，如何定义点和边。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220726235752051.png" alt="最短路结构图"></p><h3 id="Dijkstra">Dijkstra</h3><p><strong>模板</strong></p><ol><li><p>朴素dijkstra算法    (稠密图)</p><p><strong>基本思路</strong>：</p><ol><li><p>初始化距离 dist[1] = 0,dist[i] = 正无穷</p></li><li><p>s : 当前已经确定最短距离的点</p><p>for(i : 0 ~ n)                                                                        n 次</p><p>​t &lt;----- 不在 s 中的，距离最近的点                              n 次</p><p>​s &lt;----- t</p><p>​用 t 更新其他点的距离dist[x] &gt; dist[t] + w(权重) (如：从1号点走到x的路径长度是否大于1号点走到t加从t走到x，若满足，则更新)                   n 次</p><p>每一次循环迭代都可以确定一个点的最短距离，循环 n 次确定 n 个点到起点的最短距离。总时间复杂度 O(n<sup>2</sup>) 。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆优化版dijkstra    (稀疏图)</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724210044521.png" alt="堆优化迪杰斯特拉"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);<span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="849-Dijkstra求最短路-I-AcWing题库"><a href="https://www.acwing.com/problem/content/851/">849. Dijkstra求最短路 I - AcWing题库</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤n≤<span class="number">500</span></span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">105</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220721232815088.png" alt="n次迭代"></p><p><strong>稠密图</strong>，用邻接矩阵存；<strong>稀疏图</strong>，邻接表。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;      <span class="comment">//500点 100000边 稠密图 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//当前的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">//每个点最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">////1.初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);          <span class="comment">//0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;                            <span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////2.循环 n 次确定 n 个点到起点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)               <span class="comment">//n个点 n次迭代</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;                         <span class="comment">//t存储当前访问的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)           <span class="comment">//找到最短距离的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))<span class="comment">//在所有[未确定]的点中找到dist最小的点</span></span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(t == n)break;//可加上优化</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;                       <span class="comment">//当前已经确定最短距离的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)           <span class="comment">//用 t 更新其他点的最短距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="850-Dijkstra求最短路-II-AcWing题库"><a href="https://www.acwing.com/problem/content/852/">850. Dijkstra求最短路 II - AcWing题库</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤ n,m ≤<span class="number">1.5</span>×<span class="number">105</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>注：迪杰斯特拉不能用于带负权边原因 <a href="https://www.acwing.com/solution/content/6320/">AcWing 853. 有边数限制的最短路 - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;     <span class="comment">//&lt;点的距离，点&gt;</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;        <span class="comment">//稀疏图：邻接表</span></span><br><span class="line"><span class="type">int</span> w[N];                       <span class="comment">//权重</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];                      <span class="comment">//点的最短路是否确定</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 有重边也不要紧，假设 1-&gt;2 有权重为 2 和 3 的边，再遍历到点 1 的时候 2 号点的距离会更新两次放入堆中</span></span><br><span class="line">    <span class="comment">// 堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值 2+x （x为之前确定的最短路径），</span></span><br><span class="line">    <span class="comment">// 并标记 st 为 true，所以下一次弹出 3+x 会 continue 不会向下执行。</span></span><br><span class="line">    e[idx] = y,w[idx] = z,ne[idx] = h[x],h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Diijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;          <span class="comment">//小根堆    根据距离排序</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);                                   </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();                         <span class="comment">// 取不在集合S中距离最短的点</span></span><br><span class="line">        <span class="type">int</span> distance = t.first,ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> j = e[i];                                       <span class="comment">// i只是个下标，e中在存的是i这个下标对应的点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Diijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-ford">bellman-ford</h3><p><strong>模板</strong></p><p>复杂度 O(nm)。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724233657691.png" alt="贝尔曼算法"></p><p>迭代 k 次 的含义：从1号点经过不超过 k 条边走到每个点的最短距离。(如果第 n 次迭代又更新了某些边，说明存在一条最短路径有 n 条边——意味有 n+1 个点，即一定有一个点一样，即路径存在环，而环又是更新过的，即<strong>存在负环</strong>)</p><p>有负权边<strong>不一定</strong>有最短路，可能负无穷，能求出最短路没有负权回路。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724233902063.png" alt="负权回路"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724235058794.png" alt="负权回路不影响的情况"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;<span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span><span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="853-有边数限制的最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。(==不能迪杰斯特拉==)</p><p>请你求出从 1 号点到 n 号点的最<strong>多经过 k 条边</strong>(==负环不能无限转==)的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。</p><p>注意：图中可能 <strong>存在负权回路</strong>(==不一定存在最短路==)</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>点的编号为 1∼n。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。</p><p>如果不存在满足条件的路径，则输出 impossible。</p><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤n,k≤<span class="number">500</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">1</span>≤x,y≤n，</span><br><span class="line">任意边长的绝对值不超过 <span class="number">10000</span>。</span><br></pre></td></tr></table></figure><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>备份更新：防止出现串联影响结果。使用<strong>备份更新</strong>。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725220206244.png" alt="备份跟新"></p><p>负环不存在最短路。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725220834461.png" alt="负环"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;          <span class="comment">//最多经过k条边</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];        <span class="comment">//备份dist数组，避免更新时的串联干扰</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b],last[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edges[i] = &#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)    cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;       <span class="comment">//可能为正负无穷±权，故/2</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa">spfa</h3><p><strong>模板</strong></p><p>针对 bellman-ford算法的更新边操作使用<strong>队列</strong>进行优化。</p><p>队列所存：待更新的点的集合。即队列里所存的是所有变小的节点(a)，只要一个节点变小了就将它放入队列，用以更新后面所有的后继。</p><p>一个点如果没有被更新过，他更新别人是没有效果的。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725233734211.png" alt="队列优化"></p><p>(加入前判断一下，若队列有 b 了就不再重复加入)</p><ol><li><p>spfa 算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])<span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spfa判断图中是否存在负环</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220726234040134.png" alt="判断负环"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];<span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="851-spfa求最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/853/">851. spfa求最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。数据保证不存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n,m≤105，图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">-3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],w[N],ne[N],h[N],idx;<span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//每个点到源点距离</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//是否在队列</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;                          <span class="comment">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])                      <span class="comment">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>)   cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="852-spfa判断负环-AcWing题库"><a href="https://www.acwing.com/problem/content/854/">852. spfa判断负环 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你判断图中是否存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>如果图中存在负权回路，则输出 Yes，否则输出 No。</p><p><strong>数据范围</strong></p><p>1≤n≤2000,1≤m≤10000,图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">-1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">-4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],w[M],h[M],idx;               <span class="comment">//注：是 M 不是 N</span></span><br><span class="line"><span class="type">int</span> dist[N],cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能只放一号点进去。题目“是否存在负环”，不是“是否存在从1开始的负环”。可能存在一负环1号点到不了。应在开始将所有点都放入队列。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]  &gt;= n)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())  cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd">Floyd</h3><p><strong>模板</strong></p><p>邻接矩阵存。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220727205636248.png" alt="Floyd"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="854-Floyd求最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为<strong>负数</strong>。再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible。</p><p>数据保证图中不存在负权回路。(==否则最短距离负无穷==)</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><p><strong>输出格式</strong></p><p>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n≤200,<br>1≤k≤n2<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">impossible</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>,INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//基于DP</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)  dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>    dist[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        dist[a][b] = <span class="built_in">min</span>(dist[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(dist[a][b] &gt; INF/<span class="number">2</span>)  cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; dist[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最小生成树">最小生成树</h2><p>动画讲解 <a href="https://www.bilibili.com/video/BV1Eb41177d1/?vd_source=ee6f185bebb184a943308396273cbf85">最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示_哔哩哔哩_bilibili</a></p><p>建图过程。描述算法思路与步骤。</p><p><strong>最小生成树</strong></p><p>最小生成树问题一般对应无向图</p><ol><li><p><strong>Prim 算法</strong>O(n^2)</p></li><li><ol><li>朴素版(稠密图)</li><li>堆优化版(稀疏图）O(mlogn)较少使用</li></ol></li><li><p><strong>Kruskal 算法</strong>(稀疏图)O(mlogm)</p></li></ol><p><strong>二分图</strong></p><p>判别：染色法。DFS  (线性 O(n+m))</p><p>求：匈牙利算法(最坏 O(mn)，一般远小于O(mn))</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807232301879.png" alt="结构"></p><h3 id="Prim">Prim</h3><ol><li><p>朴素 Prim</p><p>s：当前已经在连通块中的所有点</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/1659024402474-28d9c53c-daf4-4089-8724-ad249a5145c4.png" alt="朴素 Prim"></p></li><li><p>堆优化</p></li></ol><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="858-Prim算法求最小生成树-AcWing题库"><a href="https://www.acwing.com/problem/content/860/">858. Prim算法求最小生成树 - AcWing题库</a></h4><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><p>给定一张边带权的无向图 <code>G=(V,E)</code>，其中 <code>V</code> 表示图中点的集合，<code>E</code> 表示图中边的集合，<code>n=|V|，m=|E|</code>。</p><p>由 <code>V</code> 中的全部 <code>n</code> 个顶点和 <code>E</code> 中 <code>n−1</code> 条边构成的无向连通子图被称为 <code>G</code> 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 <code>G</code> 的最小生成树。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。</p><p>**输出格式</p><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p><strong>数据范围</strong></p><p><code>1≤n≤500,</code><br><code>1≤m≤105,</code><br>图中涉及边的边权的绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化距离</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到集合外距离最近点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i)   res += dist[t];                 <span class="comment">//自环不能加入最小生成树中。若先更新在累加就不对了</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;       </span><br><span class="line"></span><br><span class="line">        <span class="comment">//用 t 更新其他点到 集合 的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)   dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="comment">//赋值 无向图</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)    cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal">Kruskal</h3><p><strong>模板</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220806003302335.png" alt="Kruskal"></p><p>②结合了并查集的方法，类似 <a href="https://www.acwing.com/problem/content/839/">837. 连通块中点的数量 - AcWing题库</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;<span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span><span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)<span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="859-Kruskal算法求最小生成树-AcWing题库"><a href="https://www.acwing.com/problem/content/861/">859. Kruskal算法求最小生成树 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。</p><p>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。</p><p><strong>输出格式</strong></p><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n≤105,<br>1≤m≤2∗105,<br>图中涉及边的边权的绝对值均不超过 1000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edges&amp; e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>                             <span class="comment">//并查集模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);              <span class="comment">//注：是p[x]</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>;                    <span class="comment">//res记录最小生成树的树边权重之和,cnt记录全部加入到树的集合中边的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a,b = edges[i].b,w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a),b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        具体可以参考连通块中点的数量,如果a和b已经在一个集合当中了,说明这两个点已经被一种方式连接起来了,</span></span><br><span class="line"><span class="comment">        如果加入a-b这条边,会导致集合中有环的生成,而树中不允许有环生成,所以一个连通块中的点的数量假设</span></span><br><span class="line"><span class="comment">        为x,那么里面x个节点应该是被串联起来的,有x-1条边,所以只有当a,b所属的集合不同时,才能将a-b这条</span></span><br><span class="line"><span class="comment">        边加入到总集合当中去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;               <span class="comment">//集合连接</span></span><br><span class="line">            res += w;               <span class="comment">//权重相加</span></span><br><span class="line">            cnt ++;                 <span class="comment">//边数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n<span class="number">-1</span>)   <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">Kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="染色法判定二分图">染色法判定二分图</h2><p>无向图G为二分图的<strong>充分必要条件</strong>是，G至少有两个顶点，且其所有回路的长度均为偶数。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/format,f_auto.png" alt="二分图"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/format,f_auto-16598814245022.png" alt="非二分图"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807220126032.png" alt="反证法：图中存在奇数环不是二分图"></p><p>由于<strong>图中不含奇数环，所以染色过程中一定是没有矛盾的</strong>。即：如果一个图用染色法没有矛盾发生，那么他是一个二分图；如果染色过程出现矛盾，则不是二分图。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807221952435.png" alt="染色法"></p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色</span></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，father表示当前节点的父节点（防止向树根遍历），c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, u, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="860-染色法判定二分图-AcWing题库"><a href="https://www.acwing.com/problem/content/862/">860. 染色法判定二分图 - AcWing题库</a></h3><p>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。</p><p>请你判断这个图是否是二分图。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。</p><p><strong>输出格式</strong></p><p>如果给定图是二分图，则输出 Yes，否则输出 No。</p><p><strong>数据范围</strong></p><p>1≤n,m≤105</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;      <span class="comment">// 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍  </span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],h[N],idx;              <span class="comment">//注：e 和 ne 是 M</span></span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;      <span class="comment">//邻接表模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])                     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span> - color))   <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//染色可以使用1和2区分不同颜色，用0表示未染色。3 - color表示染色从1 ~ 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[j] == color)   <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//只有某个点染色失败才能立刻break/return。染色失败相当于存在相邻的2个点染了相同的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);              <span class="comment">//注：初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)      <span class="comment">//遍历所有点，每次将未染色的点进行dfs, (初始)默认染成 1 或者 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展： <a href="https://www.acwing.com/problem/content/259/">257. 关押罪犯 - AcWing题库</a></p><h2 id="匈牙利算法">匈牙利算法</h2><p>在<strong>二分图</strong>中最多能找到多少条<strong>没有公共端点</strong>的边。</p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">// 存储每个点当前匹配的点</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 表示每个点是否已经被遍历过,防止重复搜索一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="861-二分图的最大匹配-AcWing题库"><a href="https://www.acwing.com/problem/content/863/">861. 二分图的最大匹配 - AcWing题库</a></h3><p>给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。</p><p>数据保证任意一条边的两个端点都不可能在同一部分中。</p><p>请你求出二分图的最大匹配数。</p><blockquote><p>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><p><strong>输入格式</strong></p><p>第一行包含三个整数 n1、 n2 和 m。</p><p>接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示二分图的最大匹配数。</p><p><strong>数据范围</strong></p><p>1≤n1,n2≤500,<br>1≤u≤n1,<br>1≤v≤n2,<br>1≤m≤$10^5$</p><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],h[N],idx;                <span class="comment">// 邻接表    </span></span><br><span class="line"><span class="type">int</span> match[N];                           <span class="comment">// 存储(R)每个点当前匹配的(L)点</span></span><br><span class="line"><span class="type">bool</span> st[N];                             <span class="comment">// 表示(R)每个点是否已经被遍历过,防止重复搜索一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))    </span><br><span class="line">            <span class="comment">//此处递归的解析：(当前L统一表示L1，R的对象统一L2表示。match[]表示该R的对象是谁，st[]该R是否被该L匹配过)</span></span><br><span class="line">            <span class="comment">//①L2只指了一个R，L1就只能找下一个R。即此for循环</span></span><br><span class="line">            <span class="comment">//②</span></span><br><span class="line">            <span class="comment">//1. L2有另一个R2（能和R2匹配），L1就给L2说：“换一个”，然后该L1就和该R在一起</span></span><br><span class="line">            <span class="comment">//2. L2就去重新找对象，此时L1的st[]是传给L2当参数用了，</span></span><br><span class="line">            <span class="comment">//但不会对L2重新找对象有影响，因为L1遍历过的R肯定都有对象了，L2也就不用再去尝试；</span></span><br><span class="line">            <span class="comment">//而L1没匹配过的，L2就可以从中选择自己的匹配项挨个匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,m;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向边，但寻找过程只早左边每个点所指向的所有边，不会找右边点的所有边。故存储时只存左边指向右边即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求最大匹配数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//res 存的是匹配数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：<a href="https://www.acwing.com/problem/content/374/">372. 棋盘覆盖 - AcWing题库</a></p><p>chapter 3 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 算法基础课 chapter 2</title>
      <link href="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/"/>
      <url>/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/</url>
      
        <content type="html"><![CDATA[<h1>lecture 2 数据结构</h1><h2 id="模板-v2">模板</h2><h3 id="单链表">单链表</h3><p><strong>数组模拟</strong> 比 <strong>动态分配</strong>链表【struct Node {}; new Node();】 快</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/wpsAFC7.tmp.jpg" alt="单链表"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列">队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大/小的数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列">单调队列</h3><p>常见模型：找出滑动窗口中的最大值/最小值</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637721398.png" alt="单调队列"></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637738675.png" alt="单调队列"></p><p>删除，直到它严格单调。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP">KMP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求Next数组：</span><br><span class="line"><span class="comment">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line"><span class="keyword">if</span> (j == m)</span><br><span class="line">&#123;</span><br><span class="line">j = ne[j];</span><br><span class="line"><span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie树">Trie树</h3><p>高效地存储和查找字符串集合的数据结构。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644760589784.png" alt="Trie树"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx 作用同单链表。 存的是我们当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><ol><li>将两个集合合并；</li><li>询问两个元素是否在一个集合当中。</li></ol><blockquote><p>普通暴力的做法：</p><p>belong[x] = a  集合编号</p><p>if(belong[x] == belong[y])</p><p>查询是否一个集合易 O(1) ，合并则比较复杂 O(n) 。</p><p>并查集可近似 O(1) 完成上述两个操作。</p></blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644832877691.png" alt="基本原理"></p><p><strong>基本原理</strong></p><p>每个集合用一棵树来表示。树根节点的编号就是当前集合的编号。每个节点存储它的父节点，p[x] 表示 x 的父节点。</p><ul><li><p>问题1：如何判断树根</p><p>if(p[x] == x)</p></li><li><p>问题2：如何求 x 的集合编号</p><p>while(p[x] != x) x = p[x];</p></li><li><p>问题3：如何合并两个集合</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644845624459.png" alt="合并集合"></p><p>px 是 x 的集合编号，py 是 y 的集合编号。p[x] = y。</p></li></ul><blockquote><p>问题 2 的时间复杂度较高，可进行 <strong>路径压缩</strong>(如图) 或 按值合并(让高度小的树接到高度大的树) 优化。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644844526239.png" alt="路径压缩"></p></blockquote><h4 id="朴素并查集">朴素并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="维护size的并查集">维护size的并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">size[b] += size[a];</span><br></pre></td></tr></table></figure><h4 id="维护到祖宗节点距离的并查集">维护到祖宗节点距离的并查集</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x] += d[p[x]];</span><br><span class="line">    p[x] = u;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[I] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h3 id="堆">堆</h3><p>手写堆，STL中形式是优先队列。</p><p><strong>形式</strong></p><p>完全二叉树；小根堆(根节点 &lt;= 左右子节点)；大根堆</p><p><strong>存储</strong></p><p>一维数组</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917137772.png" alt="存储"></p><p><strong>操作</strong></p><ul><li><p>down(x) {}  往下调   [O(logn)]</p><p>使用场景：某一个值变大了，需要下移。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917379969.png" alt="1644917379969"></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917390859.png" alt="1644917390859"></p></li><li><p>up(x) {}  往上调</p><p>使用场景：某一个值变小了，需要上移。</p></li></ul><ol><li>插入一个数  <code>heap[++size] = x;&amp;emsp;up(size);</code></li><li>求集合当中的最小值[O(1)] <code>heap[1];</code></li><li>删除最小值 <code>heap[1] = heap[size]; size--; down(1);</code></li><li>*删除任意一个元素 <code>heap[k] = heap[size]; size--; down(k); up(k);</code></li><li>*修改任意一个元素 <code>heap[k] = x; down(k); up(k);</code></li></ol><p><strong>建堆</strong></p><p>有两种建堆的方法:</p><ol><li>一种是从一个空树开始，每次输入一个数，就按照插入操作插入这个树，时间复杂度 <strong>nlogn</strong> (一共n个元素，每个元素logn)。</li><li>还有一种建堆方法是已经把数据都输入到了数组 a[N] ，怎么根据这个数组直接建堆。就是从 n/2 开始down()，因为 n/2 是倒数第二层，如果是倒数第一层其实每个节点自然成堆了，所以从倒数第二层开始，是最简单的一个二层树结构，down 完形成一个堆。从右下角往左边开始建堆，这样从下往上之后，轮到每个节点他下面的子树肯定已经成堆了，满足 down 的条件。</li></ol><p>复杂度分析：(以完全二叉树为例)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644933510031.png" alt="O(n)建堆"></p><p>为什么是 n/4 * 1 + n/8 * 2 +… ？</p><p>根据每一层的节点树乘以需要往下down的迭代次数（其实就是往下的层树）。假设一共有n个元素的完全二叉树，那么最后一层有n/2个元素(满二叉树情况)，不需要往下down()， 倒数第二层(含)之上总共n/2个节点。i = n / 2是最后一个拥有孩子的节点，n/2以下的节点一定是一个子节点，就从非子节点开始向上建立堆。</p><p>倒数第二层有n/4个元素，每个元素最多往下down一次，倒数第三层有n/8个元素，每个元素最多往下down两次……以此类推。最终是一个等差等比混合数列的求和，为**O(n)**的复杂度。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line"><span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line"><span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (u != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, t);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><h4 id="一般哈希-存储结构">一般哈希(存储结构)</h4><p>x ∈ (-10<sup>9</sup>,10<sup>9</sup>)，h(x) ∈ (0,10<sup>5</sup>)</p><ol><li>x mod 10<sup>5</sup>  ∈  [0,10<sup>5</sup>]</li><li>冲突问题。</li></ol><p><strong>方法</strong></p><ol><li><p>拉链法</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646051867837.png" alt="拉链法"></p><p>操作：</p><ol><li><p>添加(插入)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646060882466.png" alt="插入"></p></li><li><p>查找</p></li><li><p>删除(一般不直接删除)。使用标识符</p></li></ol><p>关于哈希表长度选取：</p><blockquote><p>比如大部分是偶数，这时候如果HASH数组容量是偶数，容易使原始数据HASH后不会均匀分布。<br>比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多<br>如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，冲突较小。</p><p>同样地，如果数据都是3的倍数，而HASH数组容量是3的倍数，HASH后也容易有冲突。</p><p>用一个质数则会减少冲突的概率。</p></blockquote><p>选素数操作</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100000</span>;;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j*j &lt;= i;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>)    <span class="comment">//质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板代码：</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开放寻址法</p><p>开辟长度应为题目给出的 2~3 倍，质数。</p><p>基本思路：</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646115363520.png" alt="开放寻址法"></p><p>操作：</p><ol><li>添加</li><li>查找</li><li>删除(打标志，同上)，可将之归为查找一种</li></ol> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中存在，返回x的所在的位置(下标)；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="字符串哈希">字符串哈希</h4><p>字符串前缀哈希法：</p><ol><li><p>先把每一个前缀的哈希值求出来(字符串 --&gt; 数字)。</p><ol><li><p>==将字符串看成 <strong>P进制</strong> 数。==</p></li><li><p>将 P进制 的数转为十进制的数。</p><p>小技巧：</p></li></ol><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646119205933.png" alt="字符串映射"></p><p>通过这样的方式，把任何一个字符串映射到从 0 ~ Q - 1 的一个数。</p><p>注意：</p><ol><li>一般情况下不能映射成 0。否则易冲突。   e.g. A 0; AA 0。</li><li>此类哈希不考虑冲突。<ol><li>P 的经验值是131或13331，取这两个值的冲突概率低；</li><li>取模的数 Q 用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。</li></ol></li></ol></li><li><p>利用前缀哈希算出任意子串哈希</p><ol><li><p>将 h[L - 1] 往左移若干位，与 h[R] 对齐。</p></li><li><p>从 L ~ R 段的哈希值    h[R] - h[L-1] * p<sup>(R-L+1)</sup></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646154233456.png" alt="L~R段哈希值"></p><p>此处用 unsigned long long 存储，便无需对Q(2<sup>64</sup>)取模，溢出即为取模。</p></li><li><p>关于预处理    h[i] = h[i - 1] * p + str[i]</p></li></ol></li></ol><p>当要 <strong>判断两个字符串是否相等</strong> 的时候可以使用这种方法。</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能用KMP者大都可以字符串哈希实现，<a href="https://www.acwing.com/problem/content/description/4063/">4060. 字符串循环节 - AcWing题库</a> 例外。</p><h3 id="STL简介">STL简介</h3><h4 id="vector">vector</h4><p>变长数组，倍增思想。</p><p>系统为某一程序分配空间时，所需时间与空间大小无关，与申请次数有关。故应减少倍增次数。</p><ol><li>size()   返回元素个数(所有容器都有)</li><li>empty()   返回是否为空(所有容器都有)</li><li>clear()  清空</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>begin()/end()   (end() 最后一个数的下一个位置)</li><li>[]</li><li>支持比较运算，按字典序(首字母)</li></ol><h4 id="pair-int-int">pair&lt;int, int&gt;</h4><p>存储二元组</p><ol><li><p>first, 第一个元素</p></li><li><p>second, 第二个元素</p></li><li><p>支持<strong>比较</strong>运算，以 <strong>first</strong> 为第一关键字，以 <strong>second</strong> 为第二关键字（字典序）</p></li><li><p>赋值</p><p>p = make_pair(10,“abc”);</p><p>p = {20,“abc”};</p></li><li><p>可以嵌套</p></li></ol><h4 id="string">string</h4><p>字符串</p><ol><li>szie()/length()  返回字符串长度</li><li>empty()</li><li>clear()</li><li>substr(起始下标(从零开始)，(子串长度))  返回子串</li><li>c_str()  返回字符串所在字符数组的起始地址(头指针)</li></ol><h4 id="queue">queue</h4><p>队列</p><ol><li>size()</li><li>empty()</li><li>push()  向队尾插入一个元素</li><li>front()  返回队头元素</li><li>back()  返回队尾元素</li><li>pop()  弹出队头元素</li><li><strong>没有</strong>clear</li></ol><h4 id="priority-queue">priority_queue</h4><p>优先队列，默认是大根堆</p><ol><li><p>push()  插入一个元素</p></li><li><p>top()  返回堆顶元素</p></li><li><p>pop()  弹出堆顶元素</p></li><li><p>定义成 <strong>小根堆</strong> 的方式：</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></p><p>表示优先队列后面的元素都要大于优先队列前面的元素</p></li><li><p><strong>没有</strong>clear</p></li></ol><h4 id="stack">stack</h4><p>栈</p><ol><li>size()</li><li>empty()</li><li>push()  向栈顶插入一个元素</li><li>top()  返回栈顶元素</li><li>pop()  弹出栈顶元素</li><li><strong>没有</strong>clear</li></ol><h4 id="deque">deque</h4><p>(加强版vector) 双端队列。效率相对低</p><ol><li>size()</li><li>empty()</li><li>clear()</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>push_front()/pop_front()</li><li>begin()/end()</li><li>[]</li></ol><h4 id="set-map-multiset-multimap">set, map, multiset, multimap</h4><p>基于平衡二叉树（红黑树），动态维护有序序列</p><ul><li>size()</li><li>empty()</li><li>clear()</li><li>begin()/end()</li><li>++, – 返回前驱和后继，时间复杂度 O(logn)</li></ul><p>multi- ：支持重复元素</p><ol><li><p>set/multiset</p><p>insert()  插入一个数<br>find()  查找一个数  (不存在返回end迭代器)<br>count()  返回某一个数的个数<br>erase()</p><ol><li>输入是一个数x，删除所有x   O(k + logn)     （k为个数)</li><li>输入一个迭代器，删除这个迭代器</li></ol><p><strong>==lower_bound()/upper_bound()==</strong></p><ol><li><p>lower_bound(x)  返回<strong>大于等于</strong>x的最小的数的迭代器</p></li><li><p>upper_bound(x)  返回<strong>大于</strong>x的最小的数的迭代器</p></li><li><p>lower_bound( begin,end,num,greater<type>() ):</type></p><p>二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>upper_bound( begin,end,num,greater<type>() ):</type></p><p>查找第一个小于num的数字</p></li></ol></li><li><p>map/multimap</p><ol><li>insert()  插入的数是一个pair</li><li>erase()  输入的参数是pair或者迭代器</li><li>find()</li><li>[]   时间复杂度是 O(logn)      （数组是O(1))</li><li>lower_bound()/upper_bound()</li></ol></li></ol><h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap">unordered_set, unordered_map, unordered_multiset, unordered_multimap</h4><p>哈希表</p><p>和上面类似，增删改查的时间复杂度是 O(1)。</p><p>不支持 lower_bound()/upper_bound()，迭代器的++，–</p><h4 id="bitset">bitset</h4><p>圧位</p><p>使用情况：bool 存储一个字节，使用压位。能够节省8倍空间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>()  等价于~(所有位取反)</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h2 id="题目-v2">题目</h2><h3 id="单链表-v2">单链表</h3><h4 id="AcWing-826-单链表">AcWing 826. <a href="https://www.acwing.com/problem/content/828/">单链表</a></h4><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li><p>向链表头插入一个数；</p></li><li><p>删除第 k 个插入的数后面的数；</p></li><li><p>在第 k 个插入的数后插入一个数。</p></li></ol><p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标为k点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k点的后一个点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;            </span><br><span class="line">            <span class="keyword">if</span>(!k)  head = ne[head];        <span class="comment">//k为0的情况,删除头结点</span></span><br><span class="line">            <span class="built_in">remove</span>(k<span class="number">-1</span>);        <span class="comment">//第k个插入数字 下标对应k-1//如果初始化head = 0,idx = 1,则不用k-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(x,k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head;i != <span class="number">-1</span>;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;        <span class="comment">//当前值：e[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表-v2">双链表</h3><h4 id="AcWing-827-双链表">AcWing 827. <a href="https://www.acwing.com/problem/content/829/">双链表</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 M，表示操作次数。</p><p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>L x</code>，表示在链表的最左端插入数 x。</li><li><code>R x</code>，表示在链表的最右端插入数 x。</li><li><code>D k</code>，表示将第 k 个插入的数删除。</li><li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li></ol><p><strong>输出格式</strong></p><p>共一行，将整个链表从左到右输出。</p><p><strong>解析</strong></p><p>实际为<strong>两个</strong>操作。add,remove [ add(k,x),add(left,x),add(right,x) ]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],r[N],l[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>,idx = <span class="number">2</span>;      <span class="comment">//下标的模拟习惯为0与1做首末</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span>   <span class="comment">//节点k右边插入一个数   注意先后顺序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k,r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx,r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span>      <span class="comment">//删除节点k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k+<span class="number">1</span>,x);<span class="comment">//第 k 个插入的数, 对应 k+1 下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>];i != <span class="number">1</span>;i = r[i])   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);     <span class="comment">//其实点为原首节点右一位，末节点为原末节点左一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈-v2">栈</h3><h4 id="AcWing-828-模拟栈">AcWing 828. <a href="https://www.acwing.com/problem/content/830/">模拟栈</a></h4><p>实现一个栈，栈初始为空，支持四种操作：</p><ol><li>push x – 向栈顶插入一个数 x；</li><li>pop – 从栈顶弹出一个数；</li><li>empty – 判断栈是否为空；</li><li>query – 查询栈顶元素。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; stk[tt] &lt;&lt; endl;            <span class="comment">//插入时为 stk[++tt] = x ，直接输出 stk[tt];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-3302-表达式求值">AcWing 3302. <a href="https://www.acwing.com/problem/content/3305/">表达式求值</a></h4><p>给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2+2)*(1+1)</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><strong>中间节点</strong>都是运算符，<strong>叶节点</strong>都是数字。<br><strong>中缀</strong>表达       <strong>后缀</strong>表达<br><img src="https://cdn.acwing.com/media/article/image/2021/11/21/95860_a66013284a-112101.png" alt="表达式.png"></p><img src="https://s2.loli.net/2022/02/07/hERxkJM9DwtKjOX.jpg" style="zoom:30%"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();                 <span class="comment">//注意a,b顺序</span></span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>() ; op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)    x = a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)   x = a-b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)   x = a*b;</span><br><span class="line">    <span class="keyword">else</span> x = a/b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))                                  <span class="comment">//数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>,j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                x = x*<span class="number">10</span> + str[j++] - <span class="string">&#x27;0&#x27;</span>;              <span class="comment">//注意要 - &#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)                                  </span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)  <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">//符号情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c])    <span class="built_in">eval</span>();     <span class="comment">//如果当前符号优先级高于栈顶，则入栈</span></span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>())  <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列-v2">队列</h3><h4 id="AcWing-829-模拟队列">AcWing 829. <a href="https://www.acwing.com/problem/content/831/">模拟队列</a></h4><p>实现一个队列，队列初始为空，支持四种操作：</p><ol><li>push x – 向队尾插入一个数 x；</li><li>pop – 从队头弹出一个数；</li><li>empty – 判断队列是否为空；</li><li>query – 查询队头元素。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> que[N],hh,tt = <span class="number">-1</span>;<span class="comment">//hh = 0，tt = -1 更方便操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh &lt;= tt)    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; que[hh] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈-v2">单调栈</h3><h4 id="AcWing-830-单调栈">AcWing 830. <a href="https://www.acwing.com/problem/content/832/">单调栈</a></h4><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>每一个元素只进栈一次，每一个元素最多只会出栈一次。总操作2n，复杂度为<strong>O(n)</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,skt[N],tt;   <span class="comment">//全局变量会自动初始化为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/king9666/article/details/103949090</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; skt[tt] &gt;= x)  tt--;    <span class="comment">//while     没 = 则错误</span></span><br><span class="line">        <span class="keyword">if</span>(tt)  cout &lt;&lt; skt[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        skt[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：</p><p>内层循环每循环一次，tt-1；外层循环每循环一次，tt+1。</p><p>最多 +n 次，最多 -n 次。</p><p>整个时间复杂度是O(n)。</p><p>单调栈应用 —— <strong>Acwing 131. <a href="https://www.acwing.com/problem/content/133/">直方图中最大的矩形</a></strong></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/19_eac6c46017-2559_1.jpg" alt="直方图"></p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> l[N],r[N],h[N],q[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) , n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line"></span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)       <span class="comment">//第i个矩形的高度可向两侧扩展的左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            l[i] = i - q[tt];</span><br><span class="line">            q[++tt] = i;                <span class="comment">//q[tt]作为栈顶元素下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tt = <span class="number">0</span>,q[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>;--i)       <span class="comment">//第i个矩形的高度可向两侧扩展的右边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            r[i] = q[tt] - i;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  res = <span class="built_in">max</span>(res, (LL)h[i] * (l[i] + r[i] - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644674377127.png" alt="模拟过程"></p><h3 id="单调队列-v2">单调队列</h3><h4 id="AcWing-154-滑动窗口">AcWing 154. <a href="https://www.acwing.com/problem/content/156/">滑动窗口</a></h4><p>给定一个大小为 n≤106 的数组。有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 k 个数字。每次滑动窗口向右移动一个位置。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3//两个整数 n 和 k，分别代表数组长度和滑动窗口的长度</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3//从左至右，每个位置滑动窗口中的最小值。</span><br><span class="line">3 3 5 5 6 7//从左至右，每个位置滑动窗口中的最大值。</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;   <span class="comment">//视情况，或while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<span class="comment">//注意是q[tt]而不是q[hh]</span></span><br><span class="line">        q[++tt] = i;                            <span class="comment">//当前可能为最小值，故应在输出前插入</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);<span class="comment">//注意等于号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];      </span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;     <span class="comment">//hh队列头 tt队列尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//维持滑动窗口的大小  判断队头是否已经划出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;           <span class="comment">//while亦可，但此题只有一次。不确定可使用while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;       <span class="comment">//单调队列</span></span><br><span class="line">        <span class="comment">//当队列不为空(hh &lt;= tt) 且 当队列队尾元素&gt;=当前元素时,那么队尾元素一定不是当前窗口最小值,删去队尾元素,加入当前元素</span></span><br><span class="line">        q[++tt] = i;            <span class="comment">//q[i]保存的是下标</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);     <span class="comment">//个数&gt;=k时才输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;       <span class="comment">//大----&gt;小</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);<span class="comment">//队头就是最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-v2">KMP</h3><h4 id="AcWing-831-KMP字符串">AcWing 831. <a href="https://www.acwing.com/problem/content/833/">KMP字符串</a></h4><p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串 P 在模式串 S 中多次作为子串出现。求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">1000010</span>;</span><br><span class="line"><span class="comment">// int p[N],s[M];</span></span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];                  <span class="comment">//重新开始匹配时，可以把j最多移动多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">-1</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n - <span class="number">1</span>)<span class="comment">//全往前挪了一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n + <span class="number">1</span>);</span><br><span class="line">            j = ne[j];                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>j = ne[j];————重新开始匹配时，可以把j最多移动多少<br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_9b4e5e4a48-111804.png" alt="KMP"><br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_86296c8048-111802.png" alt="KMP"></p><p>时间复杂度是O(n)。以第二个循环的j为例。j最多加m次,最多减m次.O(2m)-----&gt;O(m)。</p><p>上述方法所得下标：</p><table><thead><tr><th style="text-align:left">字符串</th><th style="text-align:left">    a  b  a</th><th style="text-align:left">    a  b  a  b  a</th></tr></thead><tbody><tr><td style="text-align:left">下标</td><td style="text-align:left">0  1  2  3</td><td style="text-align:left">0  1  2  3  4  5</td></tr><tr><td style="text-align:left">next[]</td><td style="text-align:left">0  0  1</td><td style="text-align:left">0  0  1  2  3</td></tr></tbody></table><hr><p><strong>法二</strong></p><p>严版KMP字符串匹配算法 <a href="https://www.bilibili.com/video/BV16X4y137qw?from=search&amp;seid=16643420370716168727&amp;spm_id_from=333.337.0.0">求next数组</a>（单次匹配）<br><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/95860_5b7ce5f648-111801.png" alt="KMP"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(String T,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(String S,String T,<span class="type">int</span> next[],<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.<span class="built_in">size</span>() &amp;&amp; j &lt;= T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;            <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];        <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i-T.<span class="built_in">size</span>();  <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法对应next数组</p><table><thead><tr><th>字符串</th><th>a  b  a  a  b  c  a  c</th></tr></thead><tbody><tr><td>下标</td><td>1  2  3  4  5  6  7  8</td></tr><tr><td>next[]</td><td>0  1  1  2  2  3  1  2</td></tr></tbody></table><p>推荐 <strong>法一</strong> 。</p><h3 id="Trie">Trie</h3><h4 id="AcWing-835-Trie字符串统计">AcWing 835. <a href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></h4><p>维护一个字符串集合，支持两种操作：</p><ol><li>I x 向集合中插入一个字符串 x；</li><li>Q x 询问一个字符串在集合中出现了多少次。</li></ol><p>共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;  <span class="comment">//下标是0的点，既是根节点，也是空节点</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>],str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)    <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-143-最大异或对">AcWing 143. <a href="https://www.acwing.com/problem/content/145/">最大异或对</a></h4><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p>暴力 O(n) * n</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)<span class="comment">//枚举第一个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;++j)<span class="comment">//枚举第二个数</span></span><br><span class="line">    res = <span class="built_in">max</span>(res,a[i] ^ a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Trie树  O(31) * n(十万) ≈ nlogn</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645087093192.png" alt="保存与筛选"></p><p>思路：从前往后枚举，先 <strong>插入</strong> 再 <strong>查询</strong> (也可先查询再插入，但开始空要加判断)。</p><p>​查询：查询 ai 前面和 ai 异或最大的值。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645103981023.png" alt="思路"></p></li></ol><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"><span class="type">int</span> n,a[N],son[M][<span class="number">2</span>],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])             </span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">        <span class="comment">/* 循环之内的内容也可以写为</span></span><br><span class="line"><span class="comment">        int &amp;s = son[p][x &gt;&gt; i &amp; 1];</span></span><br><span class="line"><span class="comment">        if (!s) s = ++ idx;</span></span><br><span class="line"><span class="comment">        p = s;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    </span><br><span class="line">        res = <span class="built_in">max</span>(res,<span class="built_in">search2</span>(a[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集-v2">并查集</h3><h4 id="AcWing-836-合并集合">AcWing 836. <a href="https://www.acwing.com/problem/content/838/">合并集合</a></h4><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li>M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li>Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">//返回 x 的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;a, &amp;b);<span class="comment">//同时输入字符串和数字的最合适方法</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)  <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911891583.png" alt="优化过程"></p><p>find() 函数 <code>p[x] = find(p[x])</code> 在回溯过程中路径压缩优化</p></blockquote><h4 id="AcWing-837-连通块中点的数量">AcWing 837. <a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h4><p>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li>C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li><li>Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li><li>Q2 a，询问点 a 所在连通块中点的数量。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><blockquote><p>同一个连通块之意：从 a 可以走到 b ，从 b 可以走到 a。</p></blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911365103.png" alt="所给样例"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="keyword">continue</span>;</span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="comment">//若不使用下面的 a = find(a), b = find(b); 上面两个语句次序不能兑换。否则 p[find(a)] 改变值会影响到 cnt[find(a)] 的值。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line">            <span class="comment">// a = find(a), b = find(b);</span></span><br><span class="line">            <span class="comment">// if (a != b)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     p[a] = b;</span></span><br><span class="line">            <span class="comment">//     cnt[b] += cnt[a];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-240-食物链">AcWing 240. <a href="https://www.acwing.com/problem/content/242/">食物链</a></h4><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X 吃 X，就是假话。</li></ol><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>样例图示</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645199664162.png" alt="样例图示"></p><p><strong>思路</strong>：</p><p>并查集中，维护每个点到根节点的 <strong>距离</strong> 。将距离分为三大类：</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250329339.png" alt="三类距离"></p><ol><li>何为距离，即是 <code>关于代的关系</code> ，对 <strong>3</strong> 取模以示之。</li></ol><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250388289.png" alt="关于代的关系"></p><ol start="2"><li><p>每个点到父节点距离如何维护？</p><p>存的时候存其对父节点距离。在做 <strong>路径压缩</strong> 时，将每个点到 <strong>父节点</strong> 的距离更新成对 <strong>根节点</strong> 的距离。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250849185.png" alt="距离维护"></p></li><li><p>只需要知道每个点与根的关系，即可判断两个点之间的关系。</p></li><li><p>关于find</p></li><li><p>存下父节点的根节点；</p><p>再加上父节点到其根节点的距离(把d[x]更新成到根节点的距离)；</p><p>把当前节点的根节点指向最终根节点。</p><p><strong>d[i]：第 i 个节点到其父节点距离</strong> <a href="https://www.acwing.com/solution/content/15938/">ref：find()函数调用过程</a></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/41774_bd485030c0-JIE.jpg" alt="find函数"></p></li></ol><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,x,y;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; x &gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)  res++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x),py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y]) % <span class="number">3</span> )  res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span> )    res ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆-v2">堆</h3><h4 id="AcWing-838-堆排序">AcWing 838. <a href="https://www.acwing.com/problem/content/840/">堆排序</a></h4><p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>] &lt; a[t]) t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>+<span class="number">1</span>] &lt; a[t]) t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u],a[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; a[u/<span class="number">2</span>] &gt; a[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u/<span class="number">2</span>],a[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i ;--i)    <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= n ;++i)    up(i);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        a[<span class="number">1</span>] = a[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-839-模拟堆">AcWing 839. <a href="https://www.acwing.com/problem/content/841/">模拟堆</a></h4><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 x；</li><li><code>PM</code>，输出当前集合中的最小值；</li><li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li><code>D k</code>，删除第 k 个插入的数；</li><li><code>C k x</code>，修改第 k 个插入的数，将其变为 x；</li></ol><p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">I -10</span><br><span class="line">PM</span><br><span class="line">I -10</span><br><span class="line">D 1</span><br><span class="line">C 2 8</span><br><span class="line">I 6</span><br><span class="line">PM</span><br><span class="line">DM</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><p>难点</p><p>从第 k 个插入点找到对应元素，又要从堆里的元素找回来。</p><p>ph[k] 与 hp[j] ：<code>第 k 个插入点的对应下标</code> 与 <code>堆中下标为j的点对应的k</code>。(两者如反函数关系)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645004854237.png" alt="交换第k个插入数"></p><p>[如何理解模拟堆中的heap_swap，hp<a href="https://www.acwing.com/solution/content/5661/">N], ph[N]？ - AcWing</a></p><ol><li><p>idx</p><p><code>h[k] = x</code>, h数组存的是节点的值，按理来说应该<code>h[idx]</code>来存，但是节点<strong>位置</strong>总是在变的，因此需维护k和idx的映射关系。</p><p>用<code>ph数组</code>来表示<code>ph[idx] = k</code>(idx到下标), 那么结点值为<code>h[ph[idx]]</code>, 儿子为<code>ph[idx] * 2</code>和<code>ph[idx] * 2 + 1</code>, 这样值和儿子结点通过idx联系在一起。</p></li><li><p>hp与ph数组</p><ol><li><p><strong>ph数组</strong> 主要用于帮助从idx映射到下标k；</p></li><li><p>在<code>swap</code>操作中我们输入是堆数组的下标，需要hp数组方便查找idx。即：</p><p><strong>hp数组</strong> 查找每个<strong>堆数组的k下标</strong> 对应idx（第idx个<strong>插入</strong>）</p></li></ol></li><li><p>操作实例</p><p>交换函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    size ++ ;</span><br><span class="line">    idx ++ ; <span class="comment">//记录第几次插入（设置新的idx）</span></span><br><span class="line">    ph[idx] = size, hp[size] = idx;<span class="comment">//每次插入都是在堆尾插入（设置ph与hp）</span></span><br><span class="line">    h[ph[idx]] = x; <span class="comment">//记录插入的值 </span></span><br><span class="line">    <span class="built_in">up</span>(ph[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><ol><li>找到第idx个插入元素在堆数组中的位置（堆数组下标）</li><li>与堆尾元素交换</li><li>在原来第idx个元素所在的位置进行down和up操作。（up，down，swap操作的都输入都是<strong>下标</strong>）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    k = ph[idx]; <span class="comment">//必须要保存当前被删除结点的下标</span></span><br><span class="line">    <span class="built_in">heap_swap</span>(k, size);<span class="comment">//第idx个插入的元素移到了堆尾，此时ph[idx]指向堆尾 </span></span><br><span class="line">    size --;  <span class="comment">//删除堆尾</span></span><br><span class="line">    <span class="built_in">up</span>(k);<span class="comment">//k是之前记录被删除的结点的下标</span></span><br><span class="line">    <span class="built_in">down</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t])   t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t])   t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt,hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// scanf(&quot;%d&quot;, &amp;k);</span></span><br><span class="line">            <span class="comment">// heap_swap(ph[k],idx);</span></span><br><span class="line">            <span class="comment">// idx --;</span></span><br><span class="line">            <span class="comment">// down(ph[k]),up(ph[k]);//0223这么做错误,k已经改变</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];              <span class="comment">//0216遗漏</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);<span class="comment">//这两个函数有且只有一个执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希表-v2">哈希表</h3><h4 id="AcWing-840-模拟散列表">AcWing 840. <a href="https://www.acwing.com/problem/content/842/">模拟散列表</a></h4><p>维护一个集合，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 x；</li><li>Q x，询问数 x 是否在集合中出现过；</li></ol><p>现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p>拉链法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;<span class="comment">//此处 e 和 ne 同单链表是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N ) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    <span class="comment">//h[k]存的链表第一个节点下标，e[i]为当前点的值；做完操作后，ne[i]为下一个点的下标。空指针的下标为 -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>开放寻址法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="type">int</span> h[N],null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//null 不在 x 范围内的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N)  k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);<span class="comment">//memset函数按字节，h为int，四个字节，每个皆是0x3f(8位)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            h[k] = x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="AcWing-841-字符串哈希">AcWing 841. <a href="https://www.acwing.com/problem/content/843/">字符串哈希</a></h4><p>给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>p 数组的意义，便是用来存储 p 的次方。因为公式内有 p 的次方，故先将 p 预处理出来。</p><p>h 数组：某一个前缀的哈希值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,P = <span class="number">131</span>;</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>] * p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    cin &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] * P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>] * P + str[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2))    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：<a href="https://www.acwing.com/problem/content/141/">139. 回文子串的最大长度 - AcWing题库</a></p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646209987825.png" alt="回文子串的最大长度"></p><p>前期步骤同上，而后</p><ul><li>长度是奇数</li></ul><ol><li><p>枚举中点；</p></li><li><p>二分半径。</p><p>每次二分一个长度，判断左右两边的哈希值是否一样。若同，扩长度；否，缩。</p></li></ol><ul><li><p>长度是偶数</p><pre><code>  在每一个字母之间插入符号 ，将其化为奇数。</code></pre></li></ul><p>下标的计算</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646213451004.png" alt="逆序下标转换"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hl 正序字符串所有前缀的哈希值；hr 逆序字符串所有前缀的哈希值。</span></span><br><span class="line"><span class="comment">//逗号表达式返回值为最后一式的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>,P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL hl[N],hr[N],p[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(ULL h[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s+<span class="number">1</span> , <span class="built_in">strcmp</span>(s+<span class="number">1</span>,<span class="string">&quot;END&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);                    </span><br><span class="line">        <span class="comment">//size_t strlen(const char *str)</span></span><br><span class="line">        <span class="comment">//从str开始到第一个&#x27;\0&#x27;为止的字符串的长度，长度不包括&#x27;\0&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n*<span class="number">2</span>;i &gt; <span class="number">0</span>;i -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i/<span class="number">2</span>];</span><br><span class="line">            s[i<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">        <span class="comment">//a b c b a</span></span><br><span class="line">        <span class="comment">//# a # b # c # b # a</span></span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = n;i &lt;= n,j &gt; <span class="number">0</span>;++i,--j)</span><br><span class="line">        &#123;</span><br><span class="line">            hl[i] = hl[i<span class="number">-1</span>]*P + s[i];</span><br><span class="line">            hr[i] = hr[i<span class="number">-1</span>]*P + s[j];</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求以s[i]为对称中心的回文串的最大半径。 二分回文串的半径</span></span><br><span class="line">        <span class="comment">//mid为回文串半径[...]S[i][...]  --&gt;  [长度mid][长度1][长度mid]  --&gt;  s[i-mid]...s[i-1] s[i] s[i+1]...s[i+mid]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)           <span class="comment">//扩容后的字符串起始下标应为 2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(i<span class="number">-2</span>,n-i);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;                               <span class="comment">//注意 + 1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(hl,i-mid,i<span class="number">-1</span>) == <span class="built_in">get</span>(hr,n-(i+mid)+<span class="number">1</span>,n-(i+<span class="number">1</span>)+<span class="number">1</span>)) l = mid;     <span class="comment">//回文串半径可以变大</span></span><br><span class="line">                <span class="keyword">else</span>    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s[i-l]...s[i-1] s[i] s[i+1]...s[i+l]</span></span><br><span class="line">            <span class="comment">//回文串总长度2*l+1=l+1+l</span></span><br><span class="line">            <span class="keyword">if</span>(s[i-l] == <span class="string">&#x27;#&#x27;</span>)   res = <span class="built_in">max</span>(res,l);   <span class="comment">//回文串两边为&#x27;#&#x27;，即字母比&#x27;#&#x27;少一个</span></span><br><span class="line">            <span class="keyword">else</span>    res = <span class="built_in">max</span>(res,l+<span class="number">1</span>);             <span class="comment">//回文串两边为字母，即字母比&#x27;#&#x27;多一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,t++,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chapter 2 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Black And White</title>
      <link href="/2022/02/21/%E9%BB%84%E6%B0%8F%E7%89%A9%E8%AF%AD/"/>
      <url>/2022/02/21/%E9%BB%84%E6%B0%8F%E7%89%A9%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="2a0b7b6dbf7c098994aaaee2e24635558a88c32ad2e9a868c8a9b8455ad536a7">2779a6e840bf540475d4100b8728576d6a48e2436bea7db61c88df4f5cfba421812fa8711bbee9baf40fac3b7db90008240494a413c8687f974bed31569118c93883428fbb39cc9b13e78a9b4444fa5f3567fc108f5de3b4f73fe53782e4d8d8a46a696b25905ba411753fc3cc5306d6310188d23e3ee08ac78e2c907a06903606d2175c6445010855033369551cc10460767ebd1f07b11dc62dc290553a66c62596bd0d5adbea68ce7cab4392992753229869a8a5db5f144b9ba222c2d323e8c31b955f42763abcf6fe838007826c3a49858f1b8c012ac96d437ff2029e22062fcb10cbcfe5ada16336c63a73b82dfe61936356a76718f287a1774da9de28e04a90f60881207234488667197ecb9b2bfd83c821cee9ed8da2d38e23065d651f8d3d9f2e38d787fc49b17e2cd248bf34f7293457615b5fae78a6484f9999dc2b0872e61f412c742830b39b4b3bb0d03d875ae55fbfbbc7dddb6858a7c4be7069751f20bed028c7f721c4ba33afbeddee2aa8408aa2490a201c0bb8dfb2a99e205cb9e5b8ca33e4b79ed6e487e3401c26b52126893b4fc0ab9ca15a74ae6089f6c04b3fdd6226634c82aa7661f4a441fb476ed52ed43de8e5f35b319c158d295ae97c9fde7d3c95a1c02fe5d496eae72349df46e7442adec1720a871bb0f80e7ac4ec4e064051574beb87af7e95013bbb97cb908ed98070a3bb5a7a103704388cd17e044246cad732ab2b0acc4bece90fd60dcf535b250fb7cc3796d886e3dd0012183df7af7532b370209dbbef64b5002fd2ce869a7a8f544c687e996e32e141289217b7dcfe71e0a0d79c5fd0c3ca257b1f3d5c00185dd044abb8a4cb7f3e617b1745e63a4d294d2acf25f5adf419c157a3965d7f1aee58950ffc1398844b0b70966709884c42f1038767a9ea88c5d63d9138d3807f0dd64f3f4978b45f07d27e1114f849de7da7c44d62596444e7ce8f2c333a5fc1c3160a5a4e43b27854beb2f7babdaf1006dba38f15e838e9ee797227cbc479c1d05e2cf44ba50e856ba026262c6b2f64996410787d980a1f59c2be6b976858b24bf772359b48855c3710aaeb6745148ba40994ac49e9ae387d6613bb25239d51f2206643c04fe590088d038bd394344f3be2262a20848cf7ac864aa2285671f7b88387add0698644b44248ec9d4590bb5bea2a3d08eadc192c4e91b81c270c8bf96e574d3df1d126cb44f16f3516c7aec9a0fafd1963c8271a0459a2c2f0d708f48ff15202bafa2f81888f61f612534d0a4ea69174ef0716ee926fcc61565f013cca02dbb1f9735b95986936dde6fd648e456abc0da6e55d8b0d75c850199201f5b4cd1f834d943ded008620239c9c65a28d8eb21775fe0785f1c02a2d62dc72e593c2d067f414775c7ee5b7872b85a336299d9152c623c48ab572d33780230b448d0bc0fc7e82f3ec09d7e7fc8a88e1ef07f8a31de67a7e50eb93fb6ed171d18d6cbc4c4174c98846558b34fcd9cb95c2f240aa8f86d3ad821a78dea6d3a0e5f04462867dafdbd4e290a8c97e9b9f0a856ac0fa5a61707c92f04d7aae76dce2094af478362ddc9c60813bb4c5dc0fe8be3b0cc410ef0b9d8d2f335d6adfaa923f9760baafa7c4ccf26c79588ca1f9bdd563a525a61c83ccebcaee16d9d979c9af62ed7e23bb6fd0534a4cc2fe77f17140f593912744a9d6e5f44491558c81254cd34a3ebb6c12851f8ac177bce0352bb83eb8980f49d992da236ab15b6e8870ea2486153e0f23a2f3e1c20acbc94e7ea223064ef7244879ec0dafd9d62a6acc101803e78f3c29b52e087fd1fac120789619e5739e8e89b50a220ef390730f0b2eb6d1b6b0f1afbccb4ee4c1324f92436add234e1d17a726e205ed9a4946f49a94b39d5526b4a976e6667f050b9e069d6ee2bf785ae7e30cd3c88603a379fb57ed2c8f0d3d1308accb4ac06983857784b31420856457f2826413b6613703ee0f379b64bb6baddb5f0cc9e64fb35c21d2d6a624087c0b7dc08f5271e5716bdaf51fd263a9794200a47976dc5a8efeab6f5431952074d63fb5678689aba6afc9cff2bbedb4263fc47bb099bc9bccb87872a86c66b50063f8f42b74f72a5828c59fb487ff49df01a6ee82b562fa91014c7e521c80c369c13c8b6b558b59ceabb41caa262e5bc75d4c73311dfa3ad2efb4f3a0610db4d6b5986129014d695a05fc464a5ca4456f942c6a8c0feae3547f8fd99427116864d648d5eeab03ebe55b046c148b191b0d523113440dd697c75865ce74044508b0648b3dc4eae9f2425a9aa2b37af7be5955d9a65eba8b013cf0b797cd54fdb83fa5322b42cf270c4f837e0f2315dc433deba65001ee3463072be1562f667007f021f54b645e05f5f78ff146816fea000045ca6206d64fdb763aef9ecdf3ba79d632507b04d1ed9ae8ca0dc8ba4f3f1a91c69ab7d7ed9e41c840e376cbb6b6f93e6d2c8e0dc9f5e4506c8cdb8ecb3cf8d1e532665edfdcad7798bcd9b234bfa13a52f0d3eddfa3de2e35625bd1a8ce133b854612929cf5e8b6c575408523eb488ed445421f8475e245ed5f52474717f49a6bc144118c8decca32e285151c02388556e098cf8d1a7acd5dc3a50c6dd2b978e7e2d77c8c1c48c4f82713d1855f062264db56a09cae1edc7cd8954c8b26ebb25b818f7152f8246e442bc4e6489d0aa9b43fb6e0da1a0aefd98df9de5ebdaa7c95f4ef8b438b2278d6a62e6dea14361798e0a4da4e580ef86fbd45f0d118701b716d0e98ab8f4e83efd60c16e12f0c12824c4dc4e029eabf1ee1b896b2d162a559259331e7b71f9237e80943799df8da80a96daa23120285ee40739b828694f91853ba4b54eadf0148357c4f9c8730b3972483d3a5311f1b6199d174b321e4bf7abd0dea156d684ec69ab5a0581496558602e36cce55235fe30e54c41b9bb27d0564acc172aef593c83f7de2b5611c8ca5a2b1e0eab71dc339ba535913df70936242641f0878fead4bd2b3bfe463c658d722c00e706fb1175eda4be61f0f1fb37a243f84c1798f427653c8681432470f83c86706a01f4fb1b5df81d719d7e502e8416daa3fc48fdac2c437e678603458925ef4dc812d3486013bff1ad222e51bec6bbe163f134db6e63dcddefcc7219696cc30ca4ff68e55ab3411609b8eb2c2b78810fccc06ac081bdee27a36623547dcdc3f392e78462bf759949227024e34e21c8fa34cdeada55950bab9e45bc6e16e04466fa89dedf564d83ce493f516e61495a02faa80f067fb32fde80f803473d1dd5b714256fc5bd5e23bd2862c97e968be6867f20f5ff2030373bad37e6bf28cabd4c9371b886729b3fd01f395aa77e11344e04d6c787a5b3f0b7bde8093449170a5ebe20b3c5148ac1c023facd052f63c96f8e3df6c780e9c83812e36b95a272076e7e4825dff1ec2c3c05b3a004531de0d44ce0739bcba3fd57dfce50c1c186f302db12ed7fbe2166669bf4d5f8c4b30be389fa54a3bf9064bceb8cb6fdba2fc8cd759395f867ae7aaaafdaa1d7a933fd01130e19a20441e399a4fe755918737b04f8f083bd39b68c286b2c9b932d1f698096cce312449583fe807eb24b56756423c343a3dd85a15a2ccd2c673e123254dbc306414ccc1d1cf45dca480fcb74d02e9d9de0d5b95c4075683dab118523757ee6e9a80d47984521606891533ffd2963cbedb8b1ebf5117f9183614facc7876e4349c7130bbb4c2f94dd0735da40a9eacf7efc5247a594e61ff1b2fcea5722dd3f619b352789f88319eb81ada46c585c6b3ed938745e6863d9c5588ff41dc919447c86a41dee773efdff6d4c051a88146e560ee5fd417f1a69703299150472a065ed726c728e4ab56662696b6a78f8e1edb8a4962390820fd072274b96e3c4df873d203c318d1da8776b5c6fca8263b75951cc5ae81550b53e30cec9e7844c0ed9592ffdfabaffde5d5e7c2b2070e9e94f6c6bfbccf8f573082c9a64ed3c23fa1183086a1b6095d298b8a115eea80a6e6900cf15f761a333e5cf5269428b329083217d658aaadd669a9592acc47801327208b47d1c1a3c869ca211f5aa783c3bd0c8573052879eea2998f1edc85885f3719f3fa74f315ad3b274418ec48c8f14b4586fa3c937ec4ec971e1f0ae41f4398eba7a2082dae66301f4a4739eee0554998e483cea049db51f49c41a74d42d59bfa964c3d67c169dbf408d517d4d6ae2474b0ee21f213d60103aa6615170abb31fb8a7ed45d8cdf3f94dd72adafb72b66f66c8eb8c9f28c18a0907d8983e6d3ff12523387618f81417d2a955b24eb6c892ea228aaf67b2c4e4c7de22cad0c47a1dc952c429ab3cc5f5e42c1c6135ca5283be680155a51265c5778aa0d40bd6bf435f563bdd3bbcad6c18ef50e49f254f3332f0e5b30f0ea60477eb695ed3a532dc364c067eaf66fa77616cc11f7e1c9216315ffaa9853c893d26c5e0910111335ab510777d4b256d1f2c181f10b504ddfc013586c0d391e890bfcbed23a7aa8d9be1e43f2f746dbb20a51e46b6030280e560a853a6884003d5046fa1f0c031ec323bcf2f58f8920cf0e90da12dccaf63c23245c11e251b3fd750fab62b237a6df5b83aa299b01372224f147512fd5cf186ef921c33a1447f0b7e1d0dfc850dbc9f33d6f36d53f302d24c5c336370884dc216fb80785704fc148546658c8db905935b6eaff2199f57e92f773e85852259c66270a5d311bd7f21785ac3ed8a5d6acf7e93ba2a9f493ffeeeec5c52559a0751231e17bc60cfe466802bc17bee19f7c1e110395113e809e029ee5970fe9025e22a7056082c92cc7050d3da2a73b96a02c8ccd0c9814475d9366effd23d207f1230c2118891fe626e5beccc31f11bfbb75893948d27f3d01b785e633bb4b09bca96627b25968a1f4afb3b887c8f2adb2c00f8c59328fca5bd87e94c975c4fd36bf11403bd03c0727aed7d5d6a10ffdec24843596a3db34be4e13fb37434eea9f405e63fec77d9d71b0fdc7b011d964f808f465e248600bd21661a4e32520112ea12d0cb41793984323dc1bab1cc165b749ef6fa324e53be5cf3b15ddb5d27e6e43c54b7adb3708ed5e153d6ba775861ecd6d672fa0e9060f6c29870377317290aaf9044b712488d7d814d46b57b835aba8e421ab40eeb7b33f44e808130fff89653622cf27a94ed8d0ca159bbec0f56902d21cd2b1bd9e0ade6f6127abafd359262ed8d41f98813e39252cce30f1cff53b0ca11f005e271538679e1f2ae91e50226cc165c50f994802bdc1cacf23d857cd8fce01ded2afe4cad7e9976fa62a32580ba3dc549b9fd1e487c5548fd9f6a6c1fbb027be235e1ccd555643829e9d74a7e3d787e8180ee4cf9dcf342ccaa0ffe3c15d7adcb405a0b440c2db70afe248a2563ce0db72ad0c7d65b454216b4106ff2866a4cd27f0e3f3c5239cd3d8e245cdd9e852016c295ec2a6e5aa39baf4e51a2d27454c7256689b991c2af9075c0efca28a3a2ca0f1c2572c3ad7ff95761b1e81d18fb1615eac2277dfda3f6fa9c9ec57bb6b31cd91c2c1aa840460bb356a1eedc4800577dd12bf1f7158558688deb5bc8e12c8a79a5b2f3c6f0722c03a922dc3144587c79af091a3ab4f69837d2952d8814dc1bd4891e78bf7b8a2862e078339b1d11adf98d156a03c332710ac5baad4174ead74c7c98e98bdc0e3577b3d96241392ddce6e203f36f0623af8aeea4a8ed39fd8b6b19ace34e08c9b202bdebb7f3e25e16ff681153fb7d5bc42bf521e51e3e4cdc98eb8f7031f922033fa3e9d98332f893aeee52a450495b9bc5200234d75ba6181241a97c4876aa2827b9530fb99726a2e241a0f57661ca23ef2215d4b32bc8de9a27474faca5151ecdbff24bd2332c48e1117511b080075d2cdf935774e84d395170e1d5c01c1f48e9030aa5264b47276c1cc61b7f2c239b93e000622a5b9977b307d6d94f67b4734f74739b69d2ec3817146d8175aa8fa406d9495bf4d713a97d7e926163f68200788867cbe1cfafbc0c4ac58d6a0165dc8380a4335de2107d588ab5013941c6f704c528b5ff7f3b48d93c2b98a547b0354e363578c4f0828de7d54ff5dea89cadba6439ac076b7417a216a7631fd650cad1aafea3b0b0d080116dd58b0b9a7fff9a386b2a8ee539175c8c73a07a9c22d3afe79a9e2652977ad9fd1261736d50722c93952726fc35a6c57dc96ce6b37ba2ae79d7e1398e7574507c2064cda30b40827422b9abf0d81be092098723eccc13a0afef4046b8b7a5b0915dae4eb8a24f65457052b292db91c6a3e17c634b1eb372533593557360530bf3a0c921227b794ab6b270fad429d6a37a0998b28a05ada1a8180922e1581dd7f4ffad951385bc6b85f635468fefe229f539ff7a9f3251233e724f13365e74c9b9608c8dd1b2040a8eddc3c3831c0eef4312279a7068546f91e9f86beaa50c918a4cbef98337b8a851f99e578885767380c8c684bcbc5a6833700a2ea0dd4b253ec3635b1d68d96969cee79ae0b675251e4349022ec335b8743ad53edf8e62d579cd3cf8f13dad5a5c7f2fc087a0b45f855c04f2172dff7cb30cbc84be6ae7f2856efc7bf7ce47371ff9cdc4b6a09e85565708c0146e4fd393a4dda7e535f7d0182dc78b5aab60c6d6fb8d4404924fa15c5bb9759454a47b52ee322d8387d205e61723d6e37c372b55375c34b5b4248b42a4063b16fffa558e71080f78ab1d900fb2210837a3acfb6dded1a21a4f030ac0a34e6157b63993a4070163a67af2bb87fb43c32a6644e8d26558f0f746987f14613437fd05fda4bfaacc861df46a1e5aa1dc224215df5b8f0cb8cf2ac8c3a72943b052e7865dcbded287a4960de39580037eb39a7af12d23df08e01c1fc402559730670e4da8dd2ad6bb981054cb73271f96bbc2ddd280dce943ee163faeb96351e946a33c12396c21d9653fff1d9a20c516c56a509195c42609feab32c0e2ac38910cba0698dcf386eed268bf1ca8759a66653ace78ce288cc6c9288be4f864fdd0ac34b3430b456712828cebb560565deb74542e0ff24328891e5a5b7d8b3908eea4f042bb1909938d9683be46b9b5b63952ef15b2cbfb1f3397de326a5a1d4a526797441b82335c7c20ae535cd878f06c774eff7f2522e0b59963805cbd17a0d8159254c2f5851b67f55754430e987852178a4ebbeebd15ed67d01d7467de64091b270959a3747854b0ae8e02d884a18394ef28044b2a19a32ce7823fe7969770351e0f86255f177b535b409b66ef8a5bddf4470cba54d763af372de292d3142c3266cc37f15d366c3e7137b926eae80c851345610b3677ccb610452373e02dfd1d71783f0c882929dbea4ceb6471579f55555f047ce4a342b9ef9cf849f0b037b026e8330061b2cdaf40fd808a0c9f54b4bbd708b2f235df69086d4fb6e19c4964c5eb4c01ef6169ed41fd4ff0ebca6a186cf7dbef98cf28cf21ffd461063420fcd12bed48766f60dc86297df8c39726fd5d2a08db6675c2bf879f80804a13eeeaad3034cab8a587bcf7f4edb0a19e18af63c56ac1cf409e5f83fd3d8288a40eb060bda57bdc376f11b127ddeca823f9be4e2752b97c5b9a21bef81e1b1b555a88ded43d0a1bfd9228599a64098bebde0ec1aa52423f0597650253bdbea928dc3466978adac361c8f6d94e9b71411e748182e01a78d2a36bd9e3d7ab5f304a669ef1356b200cbc50cb538ef38b3170eb8d7dae4bb9b00c0f893427e66a2b5d579d8deeb81c459d2c505baab88ff45fdac2f3b7a1af3b323ac34f06838bc8c3760299252f1ed0cf1db7ece75f19f5ec4373002cf507ec5a187154e44ba9ba73ac77345795ed9b8cf21eed543c240dc4bce3fbaa2ebc232a1211e0a91d32e7ba4fec2896c1e3ed32cd4cfd1a89f6dd979ce22138db1fb34eb3ccc13be45dedcb59f2d616281214cde687de8abab2fcea248845515b6a080d68ff51c8126f3c5445dc3c3611ee0f46fca81dbeaa69805c460256135ef827958a1112eac3a3830d7a8e960bb8e55344e4570f71d7cb6dc19a3eab874b8917f39f2474a11981911de6544f2000d10d83f1c3db8cbf87e0c9fa7a661626acf418c25ece00596d4930268e1a97934241b2e00ba60432fd816c73603a0c0e85bc9e7e79cf8c844148517d3814724f748d1a7a98127bcf652172e3188dd12df461515daab95d2e8213618ebd14a56c28cdb34e7fd4d098cb7a3ce75ac5ca8cfcc90657451d799135b2e2a123dec2f0ad0d2208bebeffe79451959a8cf6e7c674a94b8b73920ccc92a66459bb2ec458615d900764fdc38892d3217d4d0f4f42efbbeb07047d904d29d57ae8a4f62a4bd80dcb1714edaed23417e9fa7d6f3a325eae9a785aa669a078c469702f403fbe302f074359ac063938d332ff3a7b89e8d774bcd4f5bbe70fac7998628c4445364d344a337af9a2fe2bc3ffea014942419463620c239a88d8e1ab974d755a421672e39c2abd866f0d2a9ff34150041e133eb0f7115e6385bdf5b8b8d8546d07cf64b5726ab43ef2331db2d40f519f2eb965499309e9e2f50862d1b434f8e95c617530e27d4a31cbbaffb8be6dfa77ac1e827b631a1040f053b0514a3a852cc92f465834f748814b8afb3aa00b35358dd942834bc8b96311708e869195b668ea31c6c0ffe8e0306a278ae3433043de93c7a791d310bbba2c07cb4ee8c9696de5edb87e0bc7d1736fcfa939604fb4ed5356f64c7719ef76257213c1df67fec832754478ae26553e306d4d453a8d0c8c957d7e3d1b2a23c7229ffcbdb1e4b39c6411a594d9c07d18572714d4a3f789cfa05995cf83ba78a5f3eea5d9392760c7341ccb14f495a677b89ec7a4a4f14a750f27bcb86f7ba90970d1e564d82c14c7288a3b4650cc6b72d46a762a58a518f61f798afe73672e5bf82e8009e1d6f2874d82deb8d2645470e1854253d155a22c88da6359487c95ed12973461321bd010fa76b2236df355a4e8f79cc1bf30c49fcd624e3b9badf7d701c4af1b3af9af5132badb5ebe3a137f13c71e3b654748665b08f705e58f180dc5a232f6ea9903154c5aee6c683cc7346ac81f135f9998f62cdbd5076c047c18274fca878a7ba0023dacd828f87bc5956814f810d2d9af8ffdf043e2fb10b5d7a4b52f8d116ed2a77c05cd1400ab5d4c3b176aea24ea7212aafb2395b0dc0d081761a21b0a7fad64d59c607e5c2e818b4cac6a5360c22dec0888fdcd199713f23c77301818c1671bc1c0fae05ce1c1282df3c5347612bb160781e43a1b4e1f16b5efa452504fbde24d29a73753c56ead0732a79f11b486127daadc21a964e378f692abdd9b8fbdb60527d1f7d7c1979d56ae351b2ba522c559cbb501fda51a21ef82fb82f772219eb37c3d149f287c015257f466b6f2bc09a1013b9c58591fc9dcc7244512ced0eb04d6dcd898ccbce338c9bb0b78d1f2b698953572a582f2549bef74d798196b4447ccd094b61e66ac917584b6f980c0931a785fa3b6888b3b3967c90b3b3b95bbb8e7d65f625df8202e8a4c9057b6bc474b7e6dd3456d8203cda2f8d8a27869a2d70dca73111814d5386889cf3d270bb132b3cbfd9ce0eb451327f34d6620f32cb47d0c67abf2e643db3738386836069ac9512a11a91b9dc255bebf0c3a5c7f01178f80639bcf0d87191cc868594c9a6f7a5b87c01b3f1962d20feb0a0db1fb5e53eeeb8e650181a4bd19900652a0799ce8f02fa69b034b630feda12cfdb3f61e907d3292a7af17a129f1de823803f646887821d3d9048cceec10f620b4ceeeab46ab08f6825c3bb625a5cc023c7bfac9f45e2793e28952b663712915802602c15c9413a233a442606accd7ea61650e2cf81d98c264eab0d4ad38573504625d46a7da78e69ebc21386f4ed3653719885538f395a2375a2544c8762c5aa1310fe2bb125a675f90e9561d0e199562e3a413fb68f13ea1b03fcb2697175493d3a541c0dc9e6780d513f0c7c9dc0eb673399ddc68e6b73a6c4a4d60e5825b5383c4c6cfecde59e8791f1ba7bd447e61f52d597876e4cae787e1bfd8b1a60cd0aca3b5c7238c94d6c2421313d464fc0d574231ff96b0c341505a24e3ba5b1899fae15ec4c4764ea145afbd1be992198c3379a1bb782f35de12e7ae2641baf23c274db49a06ce43fbe359f4539b41dc4288277aaf5f5803647799bb07455d123015d806591e12079d09b15d794a4e7b30ac093aeab14b44db7f2f672f7db0013aef7338d18377f29f62af4e4a35481d4d3748c386a04e83a2db2ba92e8f6193190481f0b584f9a7c9d54910594de83669aa8ca1c1596f345046ba7ce622e391351391e39f934916492366496c144d14662d5ba204068c242a03c99d7a7b69c9e32bb41e2839456c5ebb77dbff497aa87a30832ce8c775fb85146ce1fc46a794f6f687b0442328ba2fd02cab4b22bb158d28d43e8b6bf49a006444fd3522a8bdb40e16ebe72e3740bb1faa1e10662a15ce9a1ac11b04e389b5511a1402e629594d94978002c4b8414dc27ce333587e8fa878e088b770b43518025f99df037bb90358fa38a3edcb48fc38a3a62eee3eb041009b876692fe9dc3d91b78971a406a14e8f6102aa61c9baed01b13258814eeafef8d4e89c1b9ac97391a388926e806c643208d4a9adacacea5e3fac7feba244ffdea38bb60d17fc8a9d94ec74b150f9e95755c50fc64ae5153608e36d9856557f1a5ad610c7f7e6d11a8ffa6fed0e63b742e29944660bd89ac340c5d4be862e2d73d7bee21878f1e7d4ac19723aac34b3ee8545d7a024099f38845aa81812d2c8ba6f6a4cd08e3696633f194c7cae70dd7cc1bfde3b2ab6971458954172b40927a835508f9afb1e0aabccd8895a0351e84b023fc39933bad5d3bb40413a473f370d6a05e345b5df535b8a1249affaa50eb477be89c0cd177bccafe8a64c3effd9b2e04b2b096d23681c80f955bd23d320a23d24d2ed95a01cd52d4d8f27e26b1ecbf7c8d4548a8facb6a6930f32271d5ff948490b2e1d7837cf79b530feb4c604a91968f6bfd667ba1baeb061ea603209bcf2efa31cef54d2461f49e8226a1f8fb23567039e3bc6647fb003c3d2d0c562cb3fd123357941856fa3911641d86132300947b51027b716bc53588b4211212724bc98f0b5cb3caca6f73cbc57c0fab52fc38a9b5f262870f8f090c50f443df69268359299c862b0005fcbef3f31719fd2c58fda8437be8af06d0dc3bf1196f569581fa44314b1f4d0526dcd30dce072597cf29f46472f4857131872931023a3632f240386979a490f60e1501c14a9eff195ddafa9fead8303123f4b3723af69b67e1b74855d8aeed4a7781199cb16f0f5370119f5dbda20bbb6123bbd40c16b13645367354e36091b9203cfee6865715cdb5fb7ddb57eaf52830061e818cef4aafff1652ca64d0028edd48b23be88b02c17cddfc1fb707adb3dedcb2d00030ad10e1f2a6eb8c48c166b7ea33830b53aa1dd01e8be305389930090baa4b617d9a6f9c9abd6f6b7c7ea040cdc38e978003d5ee3327f916da36d9f6508ab7fdce17285178a4bd49716c0a4d18e40486b806fcd422fbe263aeef27f69c0ee83681b91b8bba5e919a9580dce23d2225e94c56a605420a6ba1230fcdf2bfad29038821f20d8d366c4a4279a6009ee4eee8c355bbf3fe24c57a7f2862199ed8d2fdc28b09ed1d3703b00a4b63851ded513ea51b7f1637ec41f0045</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码输入框</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ空间备份 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剧录 2021</title>
      <link href="/2021/12/31/%E5%89%A7%E5%BD%95%202021/"/>
      <url>/2021/12/31/%E5%89%A7%E5%BD%95%202021/</url>
      
        <content type="html"><![CDATA[<h1>剧录 2021</h1><p style="text-align:right"><font face="仿宋"><b>冰冷的日常，唯有暗夜，才是觅燙的主宰。——序</b></font></p><p><font color="#008000"><b><strong>虫师</strong></b></font></p><p>千万里路迢迢，缘是相顾鹊桥。</p><p>瞬息间意绵绵，却已遍寻人间。</p><p>翻山越岭草萋萋，便折红豆寄情。</p><p>北冥南山风萧萧，轻燕成双归巢。</p><p>回首只见足迹隐隐，不觉刻骨铭心。</p><p>朝朝暮暮，四顾茫茫，所谓伊人，在水何方。</p><p>红尘沙滚滚，晨曦雾漫漫，方知伊人已相伴。——首季歌词</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107010739782-1365390130.png" alt="img"><br>别被愤怒和恐惧蒙蔽了眼睛，只是各自的存在形式。</p><p>——眇之鱼</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107113659136-836553829.jpg" alt="img"></p><p style="text-align:left">    <font color="#20b2aa">        <font face="仿宋">        <b>            (未知)<p>            日出日落，朝颜花只一日，</p><p>            日落日出，附近花开一片，</p><p>            但已非昨日之花。</p><p>            然，艳丽不改。</p><p>        </p></b>        </font>    </font>    <font color="#bdbebd">        (华盟 / B站)<p>太阳升起 然后落下</p><p>花朵盛开 然后凋零</p><p>太阳落下 然后升起</p><p>花朵重新盛开</p><p>        虽和昨日相比又不同</p><p>        但花朵今日依然美丽</p><p></p><p>        (漏勺)</p><p>        太阳升起 然后落下</p><p>        花朵盛开 然后凋零</p><p>        太阳落下 然后升起</p><p>        花朵重新盛开</p><p>        虽和昨日相比又不同</p><p>        但花朵依然美丽</p><p></p><p>        (诸神)</p><p>        今日日出日落</p><p>        今朝花开夕落</p><p>        今日日落日出</p><p>        周围花开一片</p><p>        然而今日花已非昨日花</p><p>        尽管如此今日花开依然美丽</p><p> </p><p>        (枫雪&漫游)</p><p>        今天太阳也会东升 然后再次落于西山</p><p>        早晨盛开的花儿也将会凋谢</p><p>        今天太阳也会落于西山 然后再次东升</p><p>        阳光照射之处遍地花开 但却已非昨日之花了</p><p>        而今日之花美丽依然</p><p></p><p>        (KUKU)</p><p>        今天太阳也东升 然后西沉</p><p>        早上开出的花 从花茎上落下</p><p>        今天太阳也西沉 然后东升</p><p>        河岸一侧 鲜花盛开</p><p>        却是与昨日不同的花</p><p>        但也是很美的花</p><p></p><p>        (极影 / 台版漫画)</p><p>        <b>            物转星移<p>            花开花落</p><p>            周而复始</p><p>            生生不息</p><p>            但今日已非昨日</p><p>            然而今天的花朵依然美丽</p><p>        </p></b>    </p></font></p><p>——吸露之群</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107010840406-1320174656.jpg" alt="img"></p><p>——虚幻之春</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220109124816516-1926566011.jpg" alt="img"></p><p>——眼福眼祸</p><p>单是有血有肉，便足矣称得上强大。</p><p>——镜之深渊</p><p>无声无息，忍耐风雪；无声无息，绽放枝头；无声无息，侵蚀殆尽。</p><p style="text-align:left">    <font color="#bdbebd">        【译二：虽无言,却风雪而立。虽无言,却花满枝头。虽无言,却兀自凋零。】<br>【译三：有花不语，凌风傲雪。有花不言，自开自凋零。有花幽幽，芳华尽蚀人间。】<br>    </font></p>岁月流逝，古木终生魂。故此令人为之倾心。若冠以其天香，更无法自拔。<p>——花惑</p><p>大地之下，是冰冷还是苦闷，是恐惧抑或寂寞。地底深处，清澈的流水，繁星生息。</p><p>——壶天之星</p><p>悠久的时光长廊中，参天大树曾立于此地，日复一日，根深蒂固，枝繁叶茂，随万物繁衍逝去。静静守护，一如既往。</p><p>——永恒之木</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011128094-485075470.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011331588-2104765566.jpg" alt="img"></p><p><font color="#008000"><b><strong>刀剑神域</strong></b></font></p><p>与其因为怀疑而后悔，不如因为相信而后悔。<br>——壹-12</p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011604998-39861807.jpg" alt="img"></p><p><font color="#008000"><b><strong>鬼灭</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011701041-1130327884.png" alt="img"></p><p><font color="#008000"><b><strong>狼与香辛料</strong></b></font></p><p>如果汝要逞强，先设法控制双手不要发抖吧。</p><p>总有一天，咱们的渴求会得不到满足，经历过的种种快乐会被风化，只剩褪色的记忆。</p><p><font color="#008000"><b><strong>eva</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011740464-176235567.png" alt="img"></p><p><font color="#008000"><b><strong>魔法少女小圆</strong></b></font></p><p><strong><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220108215947004-1417180014.jpg" alt="img"></strong></p><p><font color="#008000"><b><strong>青春猪头少年</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220108220252829-2003685384.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220108220301386-1488220621.jpg" alt="img"></p><p><font color="#008000"><b><strong>奇蛋物语</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011903146-357300200.png" alt="img"></p><p><font color="#008000"><b><strong>罗小黑</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107011928270-1406667871.png" alt="img"></p><p><font color="#008000"><b><strong>冰菓</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107012025535-261512429.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107012101082-759429954.jpg" alt="img"></p><p><font color="#008000"><b><strong>樱与抱月</strong></b></font></p><p>要问我为何要一直奔跑，那当然是因为恐惧。在我踟蹰不前时，说不定眼中的未来，在世间已成为过去，这令人终日惶惶。与其在不知情中被巨大的变化甩在身后，我宁愿选择跑在最前端，主动创造变化。</p><p><font color="#008000"><b><strong>龙女仆</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107012550150-1506654682.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107121035828-1819274721.jpg" alt="img"></p><p>代码原理： <a href="https://github.com/joxeankoret/multiav/blob/master/multiav/web/session.py#L129">multiav/session.py at master · joxeankoret/multiav · GitHub</a></p><p>影片中为实时获取标准输出部分(リアルタイムで標準出力を取得する)，出处：<a href="https://qiita.com/Esfahan/items/e33aa8daf39a2c883eb4">Pythonのサンプル集 - Qiita</a></p><p>(需要在 py2 环境运行)作用与在 Linux Terminal 运行 top 指令的输出一致。</p><p><font color="#008000"><b><strong>猫咪日常</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107012724130-1565157548.jpg" alt="img"></p><p><font color="#008000"><b><strong>KillaKill</strong></b></font></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107012814773-314926020.jpg" alt="img"></p><p><font color="#008000"><b><strong>风灵玉秀</strong></b></font><br><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107112824390-88095444.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107112845894-1272616855.jpg" alt="img"></p><p><font color="#008000"><b><strong>时光代理人</strong></b></font> <img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107112930744-207441736.jpg" alt="img"></p><p><font color="#008000"><b><strong>致不灭的你</strong></b></font><br><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107113002759-1761475273.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107113039590-1611588870.jpg" alt="img"></p><p><img src="/2021/12/31/%E5%89%A7%E5%BD%95%202021/2335982-20220107113057709-1410963729.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ空间备份 </tag>
            
            <tag> 影剧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hellow World</title>
      <link href="/2021/12/03/hello-world/"/>
      <url>/2021/12/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bulid my blog by Hexo</title>
      <link href="/2021/12/03/Make%20Hexo%20Blog/"/>
      <url>/2021/12/03/Make%20Hexo%20Blog/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Github">Hexo &amp; Github</h3><h4 id="Download">Download</h4><ol><li><a href="https://git-scm.com/">git</a></li><li><a href="https://nodejs.org/">nodejs</a></li></ol><h4 id="Step">Step</h4><ol><li><p><code>node -v</code>查看node版本</p><p><code>npm -v</code>查看npm版本</p><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code><strong>安装</strong>cnpm 管理器<strong>镜像</strong>源</p><p><code>cnpm -v</code>查看cnpm版本</p></li><li><p><code>cnpm install -g hexo-cli</code>    <strong>安装hexo</strong>框架</p><p><code>hexo -v</code>查看hexo版本</p><p><code>mkdir blog</code><strong>创建</strong>blog目录</p><p><code>cd blog</code> <strong>进入</strong>blog目录</p><p>(<code>npm install</code>进一步安装<strong>hexo</strong>所需文件  )</p></li><li><p><code>sudo hexo init (+文件夹名)</code>   生成博客 初始化<strong>创建</strong>博客文件夹</p><p>hexo就安装完成，可以启动。</p><p>1.<code>hexo clean</code>清除所有记录</p><p>2.<code>hexo generate</code>生成静态网页</p><p>3.<code>hexo server -p 80</code>启动服务   或<code>hexo s</code>启动本地博客服务</p><p>4.<code>http://localhost:4000/</code>本地访问地址</p></li></ol><h4 id="绑定远程">绑定远程</h4><p>Github创建一个新的仓库，命名 <code>YourGithubName.github.io</code></p><p>在blog目录下安装git部署插件</p><p><code>cnpm install --save hexo-deployer-git</code></p><p><strong>或者</strong> <code>npm install hexo-deployer-git  --save</code></p><p>复制URL，到hexo的配置文件<code>_config.yml</code>。注：Http已经无法直接通过github账户密码访问，<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">github设置令牌</a> ,直接使用SSH链接更简便。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: git@github.com:YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>部署到Github仓库 <code>hexo d</code></p><p>访问地址查看博客 <code>https://YourGithubName.github.io/</code></p><h4 id="问题">问题</h4><ol><li><p><strong>不能识别git的SSL证书</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_connect: Connection was reset in connection to github.com:443</span><br></pre></td></tr></table></figure><p><code>git config --global http.sslVerify &quot;false&quot;</code></p></li><li><p>fatal: unable to access ‘xxxxx’: OpenSSL SSL_connect: Connection was reset in connection to <a href="http://github.com:443">github.com:443</a></p><p>法一：git bash命令</p><p><code>git config --global http.sslBackend &quot;openssl&quot;</code><br><code>git config --global http.sslCAInfo &quot;C:\Program Files\Git\mingw64\ssl\cert.pem&quot;</code>(git安装路径)</p><p>法二：VPN导致</p><p>1.查看自己的VPN端口号，例:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line">git config --global https.proxy 127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>2.取消再进行配置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>查看命令</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy#查看git的http代理配置</span><br><span class="line">git config --global https.proxy#查看git的https代理配置</span><br><span class="line">git config --global -l         #查看git的所有配置</span><br></pre></td></tr></table></figure></li><li><p><code> Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency bash: syntax error near unexpected token Warning:'  .</code></p><p>Node版本太高，可修改 \node_modules\stylus\lib\nodes\index.js ，代码最前面加：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">exports.lineno = null;</span><br><span class="line">exports.column = null;</span><br><span class="line">exports.filename = null;</span><br></pre></td></tr></table></figure><p>无用，则：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vim node_modules/nib/package.json</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;stylus&quot;</span>: <span class="string">&quot;0.54.8&quot;</span>    # 将 stylus 版本由原来<span class="number">0.54</span><span class="number">.4</span>改成 <span class="number">0.54</span><span class="number">.8</span></span><br><span class="line">  &#125;</span><br><span class="line">保存退出，执行 npm install </span><br></pre></td></tr></table></figure></li><li><p><code>hexo init blog</code> 错误，失败,ssh改了问题1以及<a href="https://blog.csdn.net/qq_37555071/article/details/114260533">443 error</a>还是错。</p><p><strong>拆解</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/hexojs/hexo-starter.git blog  （此步失败换ssh链接)</span></span><br><span class="line"><span class="function">cd blog</span></span><br><span class="line"><span class="function">git submodule init</span></span><br><span class="line"><span class="function">git submodule update</span></span><br><span class="line"><span class="function">npm <span class="title">i</span>   <span class="params">(==install)</span> </span></span><br></pre></td></tr></table></figure><p>或换源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//gitee.com/weilining/hexo-starter.git blog</span></span><br><span class="line">cd blog</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">npm config set registry http:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></li><li><p>字体乱码</p><p><img src="/2021/12/03/Make%20Hexo%20Blog/1643357305658-166057744661233.png" alt="1643357305658"></p><p>用VSCode打开对应.yml文件，切换编码为<strong>UTF-8</strong>，重新输入中文字符。</p></li></ol><h4 id="修改主题">修改主题</h4><ol><li><p>如不喜欢blog ，可删除文件再创建。</p></li><li><p>克隆目标主题</p><p><code>git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia</code></p></li><li><p>配置文件</p><p><code>_config.yml</code> 改 theme ----&gt; theme: yilia</p></li><li><p>清理 生成  推送远端</p><p><code>hexo c</code> <code>hexo g</code> <code>hexo s</code> <code>hexo d</code></p></li><li><p><a href="https://tholman.com/github-corners/">GitHub 角 </a>  设置<code>z-index: 1031</code>属性值避免被上层覆盖</p></li></ol><h5 id="butterfly">butterfly</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br><span class="line"><span class="comment">//stylus 主题的依赖，必须安装</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h4 id="使用">使用</h4><p><strong>新建文章</strong></p><p><code>hexo new test</code>生成主页,在test/source/_posts下会生成test.md文件</p><p><strong>文内图片</strong></p><ol><li><p>把主页配置文件 <code>_config.yml</code>  里的 <code>post_asset_folder </code>设置为true；</p></li><li><p>在hexo目录下执行 <code>npm install hexo-asset-image --save</code> ；</p></li><li><p>运<code>hexo n &quot;xxxx&quot;</code> 生成md博文，<code>/source/_posts</code> 文件夹内除了 <code>xxxx.md</code> 文件还有一个同名文件夹；</p></li><li><p>在<code>xxxx.md</code>中插入图片时，把图片复制到xxxx文件夹中，然后在<code>xxxx.md</code>中按照markdown的格式引入图片。</p></li></ol><h4 id="参考">参考</h4><p><a href="https://www.cnblogs.com/somata/p/11255547.html">gitee+hexo搭建个人博客 - 乾坤盘 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从0开始搭建自己的个人博客 bilibili</a></p><p><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">Butterfly美化 - MoYu-zc - 博客园 (cnblogs.com)</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/">butterfly官方文档</a></p><p><a href="https://blog.csdn.net/qq_33384402/article/details/107200465">Gittalk评论系统配置</a>   &amp;   <a href="https://github.com/lsqstudy/hexo-theme-amazing">gitalk</a></p><p><a href="https://www.jianshu.com/p/1054736bd3ab">检索</a></p><p><a href="https://sm.ms/">url链接生成</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 算法基础课 chapter 1</title>
      <link href="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/"/>
      <url>/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/</url>
      
        <content type="html"><![CDATA[<h1>lecture 1 基础算法</h1><h2 id="模板">模板</h2><h3 id="快速排序算法模板">快速排序算法模板</h3><p>——分治</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225414615-99406498.png" alt></p><p>②的实现</p><p>1）暴力——开辟额外空间：</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225454794-747346755.png" alt></p><p>2）双指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序算法模板">归并排序算法模板</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225506781-1597839794.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数二分算法模板">整数二分算法模板</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225528019-1930741038.png" alt></p><p>有<strong>单调性</strong>可以二分，题目不一定有单调性。两者无决定关系。</p><p>如果找到一个性质可以将整个区间一分为二，二分可寻找划分边界。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225542686-657322707.png" alt></p><p>每次<strong>选择答案所在</strong>的区间进行下一步处理。直至区间长度为1。（二分一定有解，题目不一定有解。因为定义边界，二分能够算出中点。）</p><p>区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数二分算法模板">浮点数二分算法模板</h3><p>精度经验值  <strong>多2</strong>：</p><p>保留6位小数   r-l &gt; 1e-8</p><p>保留4位小数   r-l &gt; 1e-6</p><p>保留5位小数   r-l &gt; 1e-7</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度加法">高精度加法</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225604388-410296783.png" alt></p><p><strong>大整数存储</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225616459-441909897.png" alt></p><p>逆存，进位、高位补数更方便操作。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225625411-1680669889.png" alt></p><p><img src="https://img2020.cnblogs.com/blog/2335982/202112/2335982-20211231225745947-1294263317.png" alt></p><p>// C = A + B, A &gt;= 0, B &gt;= 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>(需转为 A&gt;=B)</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225839450-1060680784.png" alt></p><p>若有<strong>负数</strong>，则两数相减A-B，一定可以转换成|A|-|B|或|A|+|B|，分情况讨论。</p><p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘低精度">高精度乘低精度</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225853377-1314137168.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225904106-821632396.png" alt></p><p>// C = A * b, A &gt;= 0, b &gt; 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度乘高精度——<a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode43</a></p><h3 id="高精度除以低精度">高精度除以低精度</h3><p>区别前者，从最高位开始算。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225928738-478677729.png" alt></p><p>// A / b = C … r, A &gt;= 0, b &gt; 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维前缀和">一维前缀和</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225951690-602744695.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="二维前缀和">二维前缀和</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230005489-1633726927.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为 S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="一维差分">一维差分</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230021806-155619005.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230027349-2128206738.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230033769-1350180452.png" alt></p><p>完成+c ——&gt; 只要O(1)时间去给原数组中间某一个连续区间全加一个固定值。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230051278-1158349634.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B[i] = a[i] - a[i - <span class="number">1</span>]</span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230116312-1640207519.png" alt></p><p>(a数组是b数组的前缀和)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><h3 id="双指针">双指针</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230152163-1561872434.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">(<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">(<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="位运算">位运算</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230211383-1673648993.png" alt></p><blockquote><p>10</p><p>for(int k = 3;k &gt;= 0;k–) cout &lt;&lt; (n&gt;&gt;k&amp;1)&lt;&lt;endl;</p><p>1010</p></blockquote><p><strong>lowbit(x)</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230222309-1420076420.png" alt></p><p>0000 0011=3，它的相反数为-3=1000 0011，但0000 0011 + 1000 0011 != 0000 0000。计算机就引入了<strong>补码</strong>，相当于上面的相反数的表示。将人容易理解的二进制称为<strong>原码</strong>，计算机实际使用时用的是补码。<strong>正数的补码就是自己，负数的补码为按位取反加1</strong>。</p><p>对于1000 0011来说，若其为原码，则表示-3；若其为补码，则表示(-1)<em>2^7 + 1</em>2^1 + 1*2^0 = -125。</p><p>应用：求x里面1的个数。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230237375-1030858540.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><h3 id="离散化">离散化</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230258277-1318058867.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());<span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并">区间合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目">题目</h2><h3 id="快速排序">快速排序</h3><h4 id="AcWing-785-快排实例">AcWing 785. 快排实例</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>注意<strong>边界问题</strong>。下面用<strong>j</strong>，上面不能取到 <strong>q[r]</strong>。下面用<strong>i</strong>,上面不能取到 <strong>q[l]</strong>，可能出现 ∅和[0,1]的死循环。可以用q[r]或q[(l+r)/2]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;             <span class="comment">////补等于号</span></span><br><span class="line">    <span class="type">int</span> x = q[(l+r)/<span class="number">2</span>],i = l<span class="number">-1</span>,j = r+<span class="number">1</span>;     <span class="comment">//x应当固定q</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进</strong>的快排</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partiton</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//荷兰国旗问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> less = l - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> more = r;</span><br><span class="line"><span class="keyword">while</span> (l&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &lt; arr[r])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, ++less, l++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, --more, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr, more, r);<span class="comment">//默认以arr[r]做划分，不可遗漏最后一位数！</span></span><br><span class="line"><span class="keyword">return</span> &#123; less + <span class="number">1</span>,more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//改进的快排，随机取数字做划分值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>), r);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;p = <span class="built_in">partiton</span>(arr, l, r);<span class="comment">//返回划分区域（如[5 5 5]）的左边界和右边界</span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);<span class="comment">//&lt;区</span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);<span class="comment">//&gt;区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quickSort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-786-第k个数">AcWing 786. 第k个数</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>3</code></p><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &gt;= r)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = q[l+(r-l&gt;&gt;<span class="number">1</span>)],i = l<span class="number">-1</span>,j =r+<span class="number">1</span>;       <span class="comment">//注意(r-l&gt;&gt;1)括号位置。</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> --j;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_50deed4916-3.png" alt="3.png"><br>降低复杂度。若左边数量已大于k，则只对左边进行排序；否则对右边。<strong>分治</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)      <span class="comment">// if(l == r)</span></span><br><span class="line">        <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> x = q[(l+r)&gt;&gt;<span class="number">1</span>],i = l<span class="number">-1</span>,j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i;<span class="keyword">while</span>(q[i] &lt; x);     <span class="comment">//while(q[++i] &lt; x)</span></span><br><span class="line">        <span class="keyword">do</span> --j;<span class="keyword">while</span>(q[j] &gt; x);     <span class="comment">//while(q[--j] &gt; x)</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sl)  <span class="built_in">quick_sort</span>(q,l,j,k);</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>,k)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><h4 id="AcWing-787-归并排序">AcWing 787. 归并排序</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>1 2 3 4 5</code></p><p><strong>解析</strong></p><p>归并排序：<br>1.确定分界点<br>2.递归排序<br>3.归并————合二为一</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;    </span><br><span class="line"><span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(N);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(N);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q,<span class="type">int</span> l,<span class="type">int</span> r)</span>  <span class="comment">//闭区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);   <span class="comment">//或 l+r&gt;&gt;1</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt; q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l,j = <span class="number">0</span>; i &lt;= r; i ++,j++ )    q[i] = tmp[j];  <span class="comment">//注意q[i]条件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-788-逆序对的数量">AcWing 788. 逆序对的数量</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>5</code></p><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_b8e943dd17-4.png" alt="4.png"><br>4 5 6 | 1 2 3<br>当你发现 4 比 3 大的时候，也就是说右边最大的元素都小于左边最小的元素，那么左边剩下的5和6都必然比右边的所有元素大。因此就可以不用数5和6的情形了，直接分别加上右半边的元素个数就可以了，这一步就降低到了<strong>O(n)</strong><br>即 位置6(mid) - 位置4(i) + 1。为3的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> res = <span class="number">0</span>;      <span class="comment">//int则溢出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">            res +=( mid - i + <span class="number">1</span>);       <span class="comment">//逆序对对比归并排序只加了这一句。 //是i,非l</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l,j = <span class="number">0</span>; i &lt;= r; i ++,j++ )     q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分">二分</h3><h4 id="AcWing-789-数的范围">AcWing 789. 数的范围</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid;        <span class="comment">//注意是q[mid]而非mid</span></span><br><span class="line">            <span class="keyword">else</span>    l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l]!=x) cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span>    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另：<br>二分应用<br><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==mid)  l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r = mid<span class="number">-1</span>;          <span class="comment">//这里减一，while内加 = 不再死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亦可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int l = 0,r = nums.size();      //-1是不会执行循环的</span><br><span class="line">while(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = l+r&gt;&gt;1;</span><br><span class="line">    if(nums[mid]==mid)  l = mid+1;</span><br><span class="line">    else    r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-790-数的三次方根">AcWing 790. 数的三次方根</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-100.0</span>,r = <span class="number">100.0</span>;        <span class="comment">//r不为n，负数情况下结果大于n</span></span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((mid*mid*mid) &gt;= n)    r = mid;</span><br><span class="line">        <span class="keyword">else</span>    l = mid;            <span class="comment">//结合while条件，此情况无需加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度">高精度</h3><h4 id="AcWing-791-高精度加法">AcWing 791. 高精度加法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>()||i &lt; B.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())    t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>())    t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)   C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);    <span class="comment">//不要忘了-&#x27;0&#x27;，字符--&gt; 数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-792-高精度减法">AcWing 792. 高精度减法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>两者都是<strong>正整数</strong>的情况，需转为 <strong>A&gt;=B</strong>。若有负数，则两数相减A-B，一定可以转换成**|A|-|B|<strong>或</strong>|A|+|B|**，分情况讨论。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否 A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())    <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C = A - B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>())    t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>)   t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);    <span class="comment">//不要忘记-&#x27;0&#x27;,字符--&gt;数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);            <span class="comment">//记得加符号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-793-高精度乘法">AcWing 793. 高精度乘法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><strong>高</strong>精度乘<strong>低</strong>精度<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_e84b7dee0f-%E5%9B%BE%E7%89%871.png" alt="图片1.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() || t;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())    t += A[i]*b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();   <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] -<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>高</strong>精度乘以<strong>高</strong>精度    参考<a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode-43</a><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_1a93ea880f-1627700273-JdpAic-image.png" alt="1627700273-JdpAic-image.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = A.<span class="built_in">size</span>(),len2 = B.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">C</span>(len1+len2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i+j] += A[i]*B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; C.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i]- <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-794-高精度除法">AcWing 794. 高精度除法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>区别前者，从<strong>最高位</strong>开始算。也可以不用从后往前存，此处为统一操作都从后向前存。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/b,商为C,余数是r</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> &amp;b,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;  <span class="comment">//商</span></span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r*<span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;=<span class="number">0</span>;--i)   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和与差分">前缀和与差分</h3><h4 id="AcWing-795-前缀和">AcWing 795. 前缀和</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>做题的时候一般使用 <strong>scanf printf</strong>。<br>cin 和 cout 比 scanf printf 慢的多。因为cin cout与stdin stdout总是保持同步，这个兼容性的特性，导致 cin 有许多额外开销。<br>ios::sync_with_stdio(false);这条语句作用是关掉scanf 和cin 的同步，加快效率；劣势是scanf和cin 无法混用。</p><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++ )    s[i] = s[i<span class="number">-1</span>] + q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_03004b0d17-5.png" alt="5.png"><br>1.预处理前缀和数组<br>2.用公式求区间和</p><p>有f(i-1)等 -1 的操作一般循环从 <strong>1</strong> 开始。</p><h4 id="AcWing-796-子矩阵的和">AcWing 796. 子矩阵的和</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>下标从 <strong>1</strong> 开始<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_84a126e716-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210915214026.png" alt="微信图片_20210915214026.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];  <span class="comment">//求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]); <span class="comment">//算子矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_d652c3ff17-6.png" alt="2"><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_2936066c17-7.png" alt="1"></p><h4 id="AcWing-797-差分">AcWing 797. 差分</h4><p>输入一个长度为 n 的整数序列。</p><p>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>差分无需专门考虑<strong>构造</strong>问题，考虑如何 <strong>更新</strong> 即可。构造与修改操作可统一</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">insert</span>(i,i,a[i]);   <span class="comment">//构造b[i]矩阵(差分)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   b[i] += b[i<span class="number">-1</span>];     <span class="comment">//前缀和计算(原数组) 或 a[i] = a[i-1] + b[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]); <span class="comment">//接上 或 a[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_a5cadb3217-8.png" alt="8.png"><br>构造同 [1,1] a1     [2,2] a2 …</p><h4 id="AcWing-798-差分矩阵">AcWing 798. 差分矩阵</h4><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_225d688716-2.png" alt="2.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_83ed2cff17-10.png" alt="10.png"></p><h3 id="双指针算法">双指针算法</h3><h4 id="AcWing-799-最长连续不重复子序列">AcWing 799. 最长连续不重复子序列</h4><p>给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>1 2 2 3 5<br>——i<br>j<br><strong>s[a[j]]–</strong>;  //除去1<br>**j++;  **      //j右移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; i &amp;&amp; s[a[i]] &gt; <span class="number">1</span>) <span class="comment">//注意是 s[a[i]] &gt; 1      i</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] -- ;            <span class="comment">//注意是 s[a[j]]--        j</span></span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-800-数组元素的目标和">AcWing 800. 数组元素的目标和</h4><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。数组下标从 0 开始。求出满足 A[i]+B[j]=x 的数对 (i,j)。数据保证有唯一解。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = m<span class="number">-1</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i]+b[j] &gt; x)  j--;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x)  cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>双指针时间复杂度 <strong>O(n+m)</strong>。<br>如果题有多个答案，不能用双指针，复杂度为O(nm)。</p><h4 id="AcWing-2816-判断子序列">AcWing 2816. 判断子序列</h4><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。判断 a 序列是否为 b 序列的子序列。子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j])    i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == n)  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算-v2">位运算</h3><h4 id="AcWing-801-二进制中1的个数">AcWing 801. 二进制中1的个数</h4><p>给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>1.求 n 第 k 位数字：<strong>n&gt;&gt;k&amp;1</strong><br>2.返回 n 最后一位1：<strong>lowbit(n) = n &amp; -n</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)    x -= <span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_9e468e514c-112301.png" alt="112301.png"></p><blockquote><p>10<br>for(int k = 3;k &gt;= 0;k–) cout &lt;&lt; (n&gt;&gt;k&amp;1)&lt;&lt;endl;<br>1010</p></blockquote><p><strong>lowbit(x)</strong><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_c803d1274c-112302.png" alt="112302.png"></p><blockquote><p>0000 0011=3，它的相反数为-3=1000 0011，但0000 0011 + 1000 0011 != 0000 0000。计算机就引入了<strong>补码</strong>，相当于上面的相反数的表示。将人容易理解的二进制称为<strong>原码</strong>，计算机实际使用时用的是补码。<strong>正数的补码就是自己，负数的补码为按位取反加1</strong>。<br>对于1000 0011来说，若其为原码，则表示-3；若其为补码，则表示(-1)<em>2^7 + 1</em>2^1 + 1*2^0 = -125。<br>应用：求x里面1的个数。</p></blockquote><h3 id="离散化-v2">离散化</h3><h4 id="AcWing-802-区间和">AcWing 802. 区间和</h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>总共 2×10^9 个数，但最多只使用 <strong>3×10^5</strong>。故开三十万：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_33788bee2e-QQ%E5%9B%BE%E7%89%8720211012124535.png" alt="QQ图片20211012124535.png"><br>基本做法：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_d11cb8bb2e-QQ%E5%9B%BE%E7%89%8720211016120845.png" alt="QQ图片20211016120845.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];  <span class="comment">//a[N]为存的数。s[N]为前缀和</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存的所有要离散化的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; add,query;  <span class="comment">//插入操作。求操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//用于求 x 离散化的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;    <span class="comment">//&gt;=x最小的数</span></span><br><span class="line">        <span class="keyword">else</span>    l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//映射的数值为从1开始的自然数。方便前缀和运算 </span></span><br><span class="line">    <span class="comment">//若不想写二分，可以写lower_board</span></span><br><span class="line">    <span class="comment">//return lower_board(alls.begin(),alls.end(),x) - alls.begin() + 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//先把所有要操作的数先读进来，将其中用到的下标离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入所有的左右区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r; </span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        <span class="comment">//区间两个端点都应该离散化</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此，所有需要用到下标皆已存。下一步 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;    <span class="comment">//在离散化后的坐标位置上加上要加的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first),r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique的实现：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_c6c8d4b22e-4.png" alt="4.png"><br>双指针<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_28fd9b262e-5.png" alt="5.png"></p><h3 id="区间合并-v2">区间合并</h3><h4 id="AcWing-803-区间合并">AcWing 803. 区间合并</h4><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_90945ece2e-1.png" alt="1.png"><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_fa7453d62f-2.png" alt="2.png"><br>pair在sort时优先左端点排序，再右端点排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">vector&lt;PII&gt;segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>,ed = <span class="number">-2e9</span>;            <span class="comment">//起始维护值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg:segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>)    res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>)    res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);     <span class="comment">//加上最后一次</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chapter 1 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
