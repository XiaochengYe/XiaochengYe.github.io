<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Acwing 算法基础课 chapter 3</title>
      <link href="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/"/>
      <url>/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/</url>
      
        <content type="html"><![CDATA[<h1>lecture 3 搜索与图论</h1><h2 id="DFS">DFS</h2><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303233243772.png" alt="BFS&amp;DFS"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="842-排列数字-AcWing题库"><a href="https://www.acwing.com/problem/content/844/">842. 排列数字 - AcWing题库</a></h3><p>给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>DFS：此题 “暴搜” ，首先应考虑以什么样的 <strong>顺序</strong> 搜索。</p><p><code>if(n == 3)</code></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303234411488-16608868431321.png" alt="DFS"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220303234606743-16608873742005.png" alt="DFS"></p><p>注：</p><ol><li>每一次只会存当前路径，回溯的时候系统即已释放。</li><li>回溯之后记得 <strong>恢复现场</strong> 。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,path[N],st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="number">1</span>;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">// path[u] = 0;     //可不用恢复,自动覆盖</span></span><br><span class="line">            st[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者结合位运算判别是否已选</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,path[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u &gt; n)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!(state &gt;&gt; i &amp; <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//考虑state的二进制表示，如果第i位是1，表示当前数已经被用过了，否则表示没被用过。所以如果i已经被用过了，则需要跳过。</span></span><br><span class="line">        <span class="comment">//state不是数组，在每层里面没有修改过state，相当于st[i]在回溯之后就自动变成false了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            path[u] = i ;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>, state + (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="843-n-皇后问题-AcWing题库"><a href="https://www.acwing.com/problem/content/845/">843. n-皇后问题 - AcWing题库</a></h3><p>n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。现在给定整数 n，请你输出所有的满足条件的棋子摆法。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">.Q..</span><br><span class="line">...Q</span><br><span class="line">Q...</span><br><span class="line">..Q.</span><br><span class="line"></span><br><span class="line">..Q.</span><br><span class="line">Q...</span><br><span class="line">...Q</span><br><span class="line">.Q..</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>剪枝：如若当前方案已不可行，不必再往下搜。</p><p>两条对角线(对角线长度为2n-1)：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220304230046330.png" alt="dg&amp;udg"></p><p>对角线：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220305171115034.png" alt="对角线"></p><p>为了防止<code>y-x</code>为复数，再加上 <code>n</code> 。</p><p><strong>第一种搜索顺序</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按行枚举，保证每行只有一个，无需row</span></span><br><span class="line"><span class="comment">//u表示第u行，i表示第i列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    </span><br><span class="line">        &#123;            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[u+i] &amp;&amp; !udg[u-i+n])</span><br><span class="line">        &#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[u-i+n] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//恢复</span></span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            col[i] = dg[u+i] = udg[u-i+n] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种搜索顺序</strong></p><p>比起上述提炼行优化，此法更原始。结合行逐项来考虑，也可以写成如下。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220322220511867.png" alt="n皇后"></p><p>x y 为坐标，s 为皇后。每次枚举完当前格子，转移到下一个格子，一行最后一格换行。</p><p>x = n 即枚举完最后一行，停止。如果摆了n个皇后，输出。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//（DFS按每个元素枚举）时间复杂度O(2^n^2)，比前一种方法略复杂。</span></span><br><span class="line"><span class="comment">//时间复杂度分析：每个位置都有两种情况，总共有 n^2 个位置</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">int</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> s)</span>         <span class="comment">// s表示已经放上去的皇后个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n)  y = <span class="number">0</span>,x++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;                     <span class="comment">// x==n说明已枚举完n^2个位置</span></span><br><span class="line">        <span class="keyword">if</span>(s == n)&#123;                 <span class="comment">// s==n说明成功放上去n个皇后</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,g[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分支1：放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[y - x + n] &amp;&amp; !udg[y + x])&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[y-x+n] = udg[y+x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y+<span class="number">1</span>,s+<span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[y-x+n] = udg[y+x] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分支2：不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS">BFS</h2><p>“有<strong>最短路</strong>”：搜到的点离当前越来越远(前提是权重一致)。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.初识赋值队头</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.只要队不为空</span></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="comment">//3.扩展队头</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!s[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="844-走迷宫-AcWing题库"><a href="https://www.acwing.com/problem/content/846/">844. 走迷宫 - AcWing题库</a></h3><p>给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220403215840059.png" alt="走迷宫"></p><p>由于终点在第 8 层扩展到，故其路程即为 8 。</p><blockquote><p>四点扩展：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220403221317576.png" alt="四点扩展"></p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//g存了图</span></span><br><span class="line"><span class="comment">//d表示每个点到起点的距离。</span></span><br><span class="line"><span class="comment">//可以用向量 dx 来表示四点扩展。</span></span><br><span class="line"><span class="comment">//d[x][y] = -1。第一次走过才算最短距离，否则就不算。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">PII q[N*N];<span class="comment">//手写队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;<span class="comment">//四点扩展</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i] ,y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何输出路径？另开数组 pre[N] [N] 记录。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n,m,g[N][N],d[N][N];</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">PII q[N*N],pre[N][N];              <span class="comment">//路劲记录数组pre</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i] ,y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                pre[x][y] = t;             <span class="comment">//记录上一点</span></span><br><span class="line">                q[++tt] = &#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒着输出路劲</span></span><br><span class="line">    <span class="type">int</span> x = n<span class="number">-1</span>,y = m<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x||y)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">auto</span> t = pre[x][y];</span><br><span class="line">        x = t.first,y = t.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="845-八数码-AcWing题库"><a href="https://www.acwing.com/problem/content/847/">845. 八数码 - AcWing题库</a></h3><p>交换过程如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>   <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">x <span class="number">4</span> <span class="number">6</span>   <span class="number">4</span> x <span class="number">6</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>   <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">5</span> <span class="number">8</span>   <span class="number">7</span> <span class="number">5</span> <span class="number">8</span>   <span class="number">7</span> x <span class="number">8</span>   <span class="number">7</span> <span class="number">8</span> x</span><br></pre></td></tr></table></figure><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2  3  4  1  5  x  7  6  8</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">19</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>基本思路：最小步数——<strong>BFS</strong> 。从起点到终点，步的权重为1，最少需要走多少步。</p><p>难点：</p><ol><li>状态表示3*3格(队列 ?)</li><li>如何记录每个状态的距离  (dist ?)</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;1234X5678&quot;</span></span><br><span class="line">queue&lt;string&gt; q</span><br><span class="line">unordered_map&lt;string,<span class="type">int</span>&gt;dist</span><br></pre></td></tr></table></figure><p>处理状态</p><ol><li>将字符串恢复3*3矩阵；</li><li>移动；</li><li>转化为字符串。</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//目标状态</span></span><br><span class="line">    string goal = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="comment">//转移数组</span></span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="comment">//初始化队列和dist数组</span></span><br><span class="line">    queue&lt;string&gt;q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt;dist;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    dist[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//记录当前状态的距离，如果是最终状态则返回距离</span></span><br><span class="line">        <span class="type">int</span> distance = dist[t];</span><br><span class="line">        <span class="keyword">if</span>(t == goal)   <span class="keyword">return</span> distance;</span><br><span class="line">        <span class="comment">//查询x在字符串中的下标，然后转换为在矩阵中的坐标</span></span><br><span class="line">        <span class="type">int</span> k = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> x = k/<span class="number">3</span>,y = k%<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//求转移后x的坐标</span></span><br><span class="line">            <span class="type">int</span> a = x + dx[i],b = y + dy[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a &gt;= <span class="number">0</span> &amp;&amp; a &lt; <span class="number">3</span> &amp;&amp; b &gt;= <span class="number">0</span> &amp;&amp; b &lt; <span class="number">3</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span>+b]);</span><br><span class="line">                <span class="comment">//当前状态是第一次遍历，记录距离，入队</span></span><br><span class="line">                <span class="keyword">if</span>(!dist.<span class="built_in">count</span>(t))</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//还原状态，准备下一种转换情况</span></span><br><span class="line">                <span class="built_in">swap</span>(t[k],t[a*<span class="number">3</span>+b]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无法转换到目标状态，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        start += c;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(start) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树与图的深度优先遍历">树与图的深度优先遍历</h2><ol><li><p>树与图的存储</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220406211821304.png" alt="有向图的存储"></p><p>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向 <strong>图的存储</strong>。</p><ol><li><p>邻接矩阵：g[a][b] 存储边a-&gt;b   ；不适合稀疏</p></li><li><p>邻接表</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。</span></span><br><span class="line"><span class="comment">//h[k]存储这个单链表的头结点；e[N]:当前节点对应图中编号。</span></span><br><span class="line"><span class="comment">//即：e 存了节点值，ne 和 h 存了数组下标</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>树与图的遍历</p><ol><li><p>深度优先遍历</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407213022270.png" alt="深度优先遍历"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>宽度优先遍历</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407213058892.png" alt="宽度优先遍历"></p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过bool数组：哪些点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="846-树的重心-AcWing题库"><a href="https://www.acwing.com/problem/content/848/">846. 树的重心 - AcWing题库</a></h3><p>给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><p>题意</p><ol><li><p>删除1，三个连通块。最多者为4。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214122495.png" alt="-1连通块"></p></li><li><p>删除2，三个连通块。最多者为6。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214250029.png" alt="-2连通块"></p><p>……</p></li></ol></li><li><p>分析</p><p>求每一个子树点数大小，考虑深度优先遍历。</p><p>下面的点数，递归，DFS过程中可以求出每个子树的点数。上面的点数，总数相减。</p><p>如：删去4。每个子节点(集)为一部分，父节点及以上是另一部分。子节点的size可以返回得到，父可以总数相减。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220407214741679.png" alt="DFS"></p><p>树与图的遍历与边数和点数有关。时间复杂度BFS与DFS都是 <strong>O(m+n)</strong>。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">2</span>*N;      <span class="comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span></span><br><span class="line"><span class="type">int</span> h[N];               <span class="comment">//邻接表存储树</span></span><br><span class="line"><span class="type">int</span> e[M],ne[M];         <span class="comment">//存储元素及列表next值</span></span><br><span class="line"><span class="type">int</span> idx;                <span class="comment">//单链表指针</span></span><br><span class="line"><span class="type">int</span> n;                  <span class="comment">//输入节点数</span></span><br><span class="line"><span class="type">int</span> ans = N;            <span class="comment">//返回结果</span></span><br><span class="line"><span class="type">bool</span> st[N];             <span class="comment">//是否已被访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以 u 为根的子树中点的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;    <span class="comment">//删掉某个节点之后，最大的连通块节点数</span></span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">//每个节点访问一次</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>;<span class="comment">//当前那算一个点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问u的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];       <span class="comment">//每个节点的编号不同，用编号为下标标记是否被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);         <span class="comment">// s 表当前子树的大小 </span></span><br><span class="line">            res = <span class="built_in">max</span>(res,s);       <span class="comment">// 记录最大联通子图的节点数</span></span><br><span class="line">            sum += s;             <span class="comment">// 以j为根的树的节点数(以儿子为根节点的子树是以u为根节点的子树的一部分)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res,n-sum);       <span class="comment">//注意是 -sum</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res,ans);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="built_in">add</span>(b,a);     <span class="comment">//无向图</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//任选一节点标号 &lt;= n</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>此处并不是回溯，每个点搜到一次即可。故无需还原为 false</li><li>搜索是搜索图当中的节点编号，不是边。idx存的是边。</li></ul><h2 id="树与图的广度-宽度-优先遍历">树与图的广度(宽度)优先遍历</h2><h3 id="847-图中点的层次-AcWing题库"><a href="https://www.acwing.com/problem/content/849/">847. 图中点的层次 - AcWing题库</a></h3><p><strong>输入格式</strong><br>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 1 的边。</p><p><strong>输出格式</strong><br>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ol><li>点的权重都是1</li><li>最短路</li></ol><p>——BFS</p><p>宽搜求最短距离，<strong>第一次</strong>扩展到某个点，即为起点到它的最短距离/路径。(后面再遍历就不是了)</p><p>用宽搜框架搜索图，流程即是将图的结构结合到宽搜上。</p><p>宽搜框架搜索图：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220427215621594.png" alt="宽搜框架搜索图"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;    <span class="comment">//点和边</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;    <span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> d[N],q[N];      <span class="comment">//距离 队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;              <span class="comment">//d[i] 节点 i 的距离。易错为d[0] = 0。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)          <span class="comment">//没有被访问过</span></span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q[++ tt] = j;       <span class="comment">//数组模拟队列  扩展每个点的临边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓扑排序">拓扑排序</h2><p>有向无环图(拓扑图)一定有拓扑序列，图中任意一对顶点u和v，若边 (u,v)∈E (G)，u在线性序列中出现在v<strong>之前</strong>。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220718212455089.png" alt="所有边都是从前指向后"></p><p>顶点 v 的<strong>入度</strong>是指以 v 为头的弧的数目；顶点v的<strong>出度</strong>(outdegree) 是指以 v 为尾的弧的数目。</p><p>拓扑系列的构建：</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220718225229891.png" alt="构建拓扑系列"></p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：拓扑序不唯一。</p><h3 id="848-有向图的拓扑序列-AcWing题库"><a href="https://www.acwing.com/problem/content/850/">848. 有向图的拓扑序列 - AcWing题库</a></h3><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。</p><p><strong>输出格式</strong></p><p>共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。</p><p>否则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q[++tt] = i;<span class="comment">//将入度为零的 点 入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh++];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j]--;<span class="comment">//删除点t指向点j的 边</span></span><br><span class="line">            <span class="keyword">if</span>(!d[j])   <span class="comment">//如果 点j 的入度为零了,就将点j入队</span></span><br><span class="line">                q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n<span class="number">-1</span>;<span class="comment">//如果n个点都入队了话,那么该图为拓扑图,返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);        <span class="comment">//注意：记得初始化h</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);</span><br><span class="line">        d[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">toposort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);<span class="comment">//队列中的点的次序就是拓扑序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路">最短路</h2><p><strong>知识结构图</strong></p><p>n 点数，m 边数。</p><ol><li><p>单源最短路</p><p>求从一个点到其他点的最短距离。</p><ol><li><p>所有边权都是正数</p><ul><li><p>朴素的 Dijkstra 算法（与边数无关，适合<strong>稠密图</strong>）</p><p>O(n^2)</p></li><li><p>堆优化版的 Dijkstra 算法  （<strong>稀疏图</strong>)</p><p>O(mlogn)  —— 总共需要遍历 m 条边，插入数据修改小根堆的时间复杂度为 O(logn)</p></li></ul></li><li><p>存在负权边</p><ul><li><p>bellman-ford 算法</p><p>O(nm)</p></li><li><p>spfa 算法</p><p>一般O(m)，最坏 O(nm)</p></li></ul></li></ol></li><li><p>多源汇最短路</p><ul><li><p>Floyd 算法</p><p>O(n^3)</p></li></ul><p>源点：起点</p><p>汇点：终点</p><p>其中一个点到另一个点的最短距离。</p></li></ol><p>侧重于 <strong>建图</strong> ，如何定义点和边。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220726235752051.png" alt="最短路结构图"></p><h3 id="Dijkstra">Dijkstra</h3><p><strong>模板</strong></p><ol><li><p>朴素dijkstra算法    (稠密图)</p><p><strong>基本思路</strong>：</p><ol><li><p>初始化距离 dist[1] = 0,dist[i] = 正无穷</p></li><li><p>s : 当前已经确定最短距离的点</p><p>for(i : 0 ~ n)                                                                        n 次</p><p>​t &lt;----- 不在 s 中的，距离最近的点                              n 次</p><p>​s &lt;----- t</p><p>​用 t 更新其他点的距离dist[x] &gt; dist[t] + w(权重) (如：从1号点走到x的路径长度是否大于1号点走到t加从t走到x，若满足，则更新)                   n 次</p><p>每一次循环迭代都可以确定一个点的最短距离，循环 n 次确定 n 个点到起点的最短距离。总时间复杂度 O(n<sup>2</sup>) 。</p></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>堆优化版dijkstra    (稀疏图)</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724210044521.png" alt="堆优化迪杰斯特拉"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;<span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);<span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="849-Dijkstra求最短路-I-AcWing题库"><a href="https://www.acwing.com/problem/content/851/">849. Dijkstra求最短路 I - AcWing题库</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤n≤<span class="number">500</span></span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">105</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220721232815088.png" alt="n次迭代"></p><p><strong>稠密图</strong>，用邻接矩阵存；<strong>稀疏图</strong>，邻接表。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;      <span class="comment">//500点 100000边 稠密图 邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];    <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="type">int</span> dist[N];    <span class="comment">//当前的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">//每个点最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">////1.初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);          <span class="comment">//0x3f代表无限大</span></span><br><span class="line"></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;                            <span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">////2.循环 n 次确定 n 个点到起点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)               <span class="comment">//n个点 n次迭代</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;                         <span class="comment">//t存储当前访问的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)           <span class="comment">//找到最短距离的点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))<span class="comment">//在所有[未确定]的点中找到dist最小的点</span></span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//if(t == n)break;//可加上优化</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;                       <span class="comment">//当前已经确定最短距离的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)           <span class="comment">//用 t 更新其他点的最短距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],dist[t] + g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        g[x][y] = <span class="built_in">min</span>(g[x][y],z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="850-Dijkstra求最短路-II-AcWing题库"><a href="https://www.acwing.com/problem/content/852/">850. Dijkstra求最短路 II - AcWing题库</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤ n,m ≤<span class="number">1.5</span>×<span class="number">105</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>注：迪杰斯特拉不能用于带负权边原因 <a href="https://www.acwing.com/solution/content/6320/">AcWing 853. 有边数限制的最短路 - AcWing</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;     <span class="comment">//&lt;点的距离，点&gt;</span></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;        <span class="comment">//稀疏图：邻接表</span></span><br><span class="line"><span class="type">int</span> w[N];                       <span class="comment">//权重</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];                      <span class="comment">//点的最短路是否确定</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 有重边也不要紧，假设 1-&gt;2 有权重为 2 和 3 的边，再遍历到点 1 的时候 2 号点的距离会更新两次放入堆中</span></span><br><span class="line">    <span class="comment">// 堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值 2+x （x为之前确定的最短路径），</span></span><br><span class="line">    <span class="comment">// 并标记 st 为 true，所以下一次弹出 3+x 会 continue 不会向下执行。</span></span><br><span class="line">    e[idx] = y,w[idx] = z,ne[idx] = h[x],h[x] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Diijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;          <span class="comment">//小根堆    根据距离排序</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);                                   </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();                         <span class="comment">// 取不在集合S中距离最短的点</span></span><br><span class="line">        <span class="type">int</span> distance = t.first,ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="type">int</span> j = e[i];                                       <span class="comment">// i只是个下标，e中在存的是i这个下标对应的点</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>)   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y,z;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="built_in">add</span>(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Diijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bellman-ford">bellman-ford</h3><p><strong>模板</strong></p><p>复杂度 O(nm)。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724233657691.png" alt="贝尔曼算法"></p><p>迭代 k 次 的含义：从1号点经过不超过 k 条边走到每个点的最短距离。(如果第 n 次迭代又更新了某些边，说明存在一条最短路径有 n 条边——意味有 n+1 个点，即一定有一个点一样，即路径存在环，而环又是更新过的，即<strong>存在负环</strong>)</p><p>有负权边<strong>不一定</strong>有最短路，可能负无穷，能求出最短路没有负权回路。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724233902063.png" alt="负权回路"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220724235058794.png" alt="负权回路不影响的情况"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;<span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span><span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="853-有边数限制的最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/855/">853. 有边数限制的最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， <strong>边权可能为负数</strong>。(==不能迪杰斯特拉==)</p><p>请你求出从 1 号点到 n 号点的最<strong>多经过 k 条边</strong>(==负环不能无限转==)的最短距离，如果无法从 1 号点走到 n 号点，输出 impossible。</p><p>注意：图中可能 <strong>存在负权回路</strong>(==不一定存在最短路==)</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>点的编号为 1∼n。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。</p><p>如果不存在满足条件的路径，则输出 impossible。</p><p><strong>数据范围</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>≤n,k≤<span class="number">500</span>,</span><br><span class="line"><span class="number">1</span>≤m≤<span class="number">10000</span>,</span><br><span class="line"><span class="number">1</span>≤x,y≤n，</span><br><span class="line">任意边长的绝对值不超过 <span class="number">10000</span>。</span><br></pre></td></tr></table></figure><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>备份更新：防止出现串联影响结果。使用<strong>备份更新</strong>。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725220206244.png" alt="备份跟新"></p><p>负环不存在最短路。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725220834461.png" alt="负环"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;          <span class="comment">//最多经过k条边</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];        <span class="comment">//备份dist数组，避免更新时的串联干扰</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last,dist,<span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> e = edges[j];</span><br><span class="line">            dist[e.b] = <span class="built_in">min</span>(dist[e.b],last[e.a] + e.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        edges[i] = &#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>)    cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;       <span class="comment">//可能为正负无穷±权，故/2</span></span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,dist[n]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa">spfa</h3><p><strong>模板</strong></p><p>针对 bellman-ford算法的更新边操作使用<strong>队列</strong>进行优化。</p><p>队列所存：待更新的点的集合。即队列里所存的是所有变小的节点(a)，只要一个节点变小了就将它放入队列，用以更新后面所有的后继。</p><p>一个点如果没有被更新过，他更新别人是没有效果的。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220725233734211.png" alt="队列优化"></p><p>(加入前判断一下，若队列有 b 了就不再重复加入)</p><ol><li><p>spfa 算法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])<span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>spfa判断图中是否存在负环</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220726234040134.png" alt="判断负环"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];<span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="851-spfa求最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/853/">851. spfa求最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 impossible。数据保证不存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示 1 号点到 n 号点的最短距离。</p><p>如果路径不存在，则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n,m≤105，图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">-3</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],w[N],ne[N],h[N],idx;<span class="comment">//邻接表</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//每个点到源点距离</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//是否在队列</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;                          <span class="comment">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])                      <span class="comment">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                &#123;   </span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(res == <span class="number">0x3f3f3f3f</span>)   cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="852-spfa判断负环-AcWing题库"><a href="https://www.acwing.com/problem/content/854/">852. spfa判断负环 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， 边权可能为负数。请你判断图中是否存在负权回路。</p><p><strong>输入格式</strong></p><p>第一行包含整数 n 和 m。</p><p>接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p><strong>输出格式</strong></p><p>如果图中存在负权回路，则输出 Yes，否则输出 No。</p><p><strong>数据范围</strong></p><p>1≤n≤2000,1≤m≤10000,图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">-1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">-4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],w[M],h[M],idx;               <span class="comment">//注：是 M 不是 N</span></span><br><span class="line"><span class="type">int</span> dist[N],cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能只放一号点进去。题目“是否存在负环”，不是“是否存在从1开始的负环”。可能存在一负环1号点到不了。应在开始将所有点都放入队列。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]  &gt;= n)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>())  cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd">Floyd</h3><p><strong>模板</strong></p><p>邻接矩阵存。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220727205636248.png" alt="Floyd"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="854-Floyd求最短路-AcWing题库"><a href="https://www.acwing.com/problem/content/856/">854. Floyd求最短路 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为<strong>负数</strong>。再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 impossible。</p><p>数据保证图中不存在负权回路。(==否则最短距离负无穷==)</p><p><strong>输入格式</strong></p><p>第一行包含三个整数 n,m,k。</p><p>接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。</p><p>接下来 k 行，每行包含两个整数 x,y，表示询问点 x 到点 y 的最短距离。</p><p><strong>输出格式</strong></p><p>共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n≤200,<br>1≤k≤n2<br>1≤m≤20000,<br>图中涉及边长绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">impossible</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>,INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">int</span> dist[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//基于DP</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[i][j] = <span class="built_in">min</span>(dist[i][j],dist[i][k]+dist[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; Q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)  dist[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>    dist[i][j] = INF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        dist[a][b] = <span class="built_in">min</span>(dist[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Floyd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(Q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(dist[a][b] &gt; INF/<span class="number">2</span>)  cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; dist[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最小生成树">最小生成树</h2><p>动画讲解 <a href="https://www.bilibili.com/video/BV1Eb41177d1/?vd_source=ee6f185bebb184a943308396273cbf85">最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示_哔哩哔哩_bilibili</a></p><p>建图过程。描述算法思路与步骤。</p><p><strong>最小生成树</strong></p><p>最小生成树问题一般对应无向图</p><ol><li><p><strong>Prim 算法</strong>O(n^2)</p></li><li><ol><li>朴素版(稠密图)</li><li>堆优化版(稀疏图）O(mlogn)较少使用</li></ol></li><li><p><strong>Kruskal 算法</strong>(稀疏图)O(mlogm)</p></li></ol><p><strong>二分图</strong></p><p>判别：染色法。DFS  (线性 O(n+m))</p><p>求：匈牙利算法(最坏 O(mn)，一般远小于O(mn))</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807232301879.png" alt="结构"></p><h3 id="Prim">Prim</h3><ol><li><p>朴素 Prim</p><p>s：当前已经在连通块中的所有点</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/1659024402474-28d9c53c-daf4-4089-8724-ad249a5145c4.png" alt="朴素 Prim"></p></li><li><p>堆优化</p></li></ol><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="858-Prim算法求最小生成树-AcWing题库"><a href="https://www.acwing.com/problem/content/860/">858. Prim算法求最小生成树 - AcWing题库</a></h4><p>给定一个 <code>n</code> 个点 <code>m</code> 条边的无向图，图中可能存在重边和自环，边权可能为负数。</p><p>求最小生成树的树边权重之和，如果最小生成树不存在则输出 <code>impossible</code>。</p><p>给定一张边带权的无向图 <code>G=(V,E)</code>，其中 <code>V</code> 表示图中点的集合，<code>E</code> 表示图中边的集合，<code>n=|V|，m=|E|</code>。</p><p>由 <code>V</code> 中的全部 <code>n</code> 个顶点和 <code>E</code> 中 <code>n−1</code> 条边构成的无向连通子图被称为 <code>G</code> 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 <code>G</code> 的最小生成树。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。</p><p>**输出格式</p><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p><strong>数据范围</strong></p><p><code>1≤n≤500,</code><br><code>1≤m≤105,</code><br>图中涉及边的边权的绝对值均不超过 10000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化距离</span></span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//找到集合外距离最近点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i)   res += dist[t];                 <span class="comment">//自环不能加入最小生成树中。若先更新在累加就不对了</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;       </span><br><span class="line"></span><br><span class="line">        <span class="comment">//用 t 更新其他点到 集合 的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;++j)   dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);</span><br><span class="line"><span class="comment">//赋值 无向图</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t == INF)    cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal">Kruskal</h3><p><strong>模板</strong></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220806003302335.png" alt="Kruskal"></p><p>②结合了并查集的方法，类似 <a href="https://www.acwing.com/problem/content/839/">837. 连通块中点的数量 - AcWing题库</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n, m;<span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span><span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)<span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="859-Kruskal算法求最小生成树-AcWing题库"><a href="https://www.acwing.com/problem/content/861/">859. Kruskal算法求最小生成树 - AcWing题库</a></h4><p>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。求最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p>给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。</p><p>由 V 中的全部 n 个顶点和 E 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。</p><p><strong>输出格式</strong></p><p>共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 impossible。</p><p><strong>数据范围</strong></p><p>1≤n≤105,<br>1≤m≤2∗105,<br>图中涉及边的边权的绝对值均不超过 1000。</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edges&amp; e) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>                             <span class="comment">//并查集模板</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);              <span class="comment">//注：是p[x]</span></span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>;                    <span class="comment">//res记录最小生成树的树边权重之和,cnt记录全部加入到树的集合中边的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a,b = edges[i].b,w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a),b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        具体可以参考连通块中点的数量,如果a和b已经在一个集合当中了,说明这两个点已经被一种方式连接起来了,</span></span><br><span class="line"><span class="comment">        如果加入a-b这条边,会导致集合中有环的生成,而树中不允许有环生成,所以一个连通块中的点的数量假设</span></span><br><span class="line"><span class="comment">        为x,那么里面x个节点应该是被串联起来的,有x-1条边,所以只有当a,b所属的集合不同时,才能将a-b这条</span></span><br><span class="line"><span class="comment">        边加入到总集合当中去</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;               <span class="comment">//集合连接</span></span><br><span class="line">            res += w;               <span class="comment">//权重相加</span></span><br><span class="line">            cnt ++;                 <span class="comment">//边数加1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n<span class="number">-1</span>)   <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b,&amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">Kruskal</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t == <span class="number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="染色法判定二分图">染色法判定二分图</h2><p>无向图G为二分图的<strong>充分必要条件</strong>是，G至少有两个顶点，且其所有回路的长度均为偶数。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/format,f_auto.png" alt="二分图"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/format,f_auto-16598814245022.png" alt="非二分图"></p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807220126032.png" alt="反证法：图中存在奇数环不是二分图"></p><p>由于<strong>图中不含奇数环，所以染色过程中一定是没有矛盾的</strong>。即：如果一个图用染色法没有矛盾发生，那么他是一个二分图；如果染色过程出现矛盾，则不是二分图。</p><p><img src="/2022/08/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter3/image-20220807221952435.png" alt="染色法"></p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">// 表示每个点的颜色，-1表示为染色，0表示白色，1表示黑色</span></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，father表示当前节点的父节点（防止向树根遍历），c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> father, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, u, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="860-染色法判定二分图-AcWing题库"><a href="https://www.acwing.com/problem/content/862/">860. 染色法判定二分图 - AcWing题库</a></h3><p>给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。</p><p>请你判断这个图是否是二分图。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 n 和 m。</p><p>接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。</p><p><strong>输出格式</strong></p><p>如果给定图是二分图，则输出 Yes，否则输出 No。</p><p><strong>数据范围</strong></p><p>1≤n,m≤105</p><p><strong>输入样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;      <span class="comment">// 由于是无向图, 顶点数最大是N，那么边数M最大是顶点数的2倍  </span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],h[N],idx;              <span class="comment">//注：e 和 ne 是 M</span></span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;      <span class="comment">//邻接表模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])                     </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span> - color))   <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//染色可以使用1和2区分不同颜色，用0表示未染色。3 - color表示染色从1 ~ 2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[j] == color)   <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//只有某个点染色失败才能立刻break/return。染色失败相当于存在相邻的2个点染了相同的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);              <span class="comment">//注：初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)      <span class="comment">//遍历所有点，每次将未染色的点进行dfs, (初始)默认染成 1 或者 2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag)    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展： <a href="https://www.acwing.com/problem/content/259/">257. 关押罪犯 - AcWing题库</a></p><h2 id="匈牙利算法">匈牙利算法</h2><p>在<strong>二分图</strong>中最多能找到多少条<strong>没有公共端点</strong>的边。</p><p><strong>模板</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n;<span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;<span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">// 存储每个点当前匹配的点</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">// 表示每个点是否已经被遍历过,防止重复搜索一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="861-二分图的最大匹配-AcWing题库"><a href="https://www.acwing.com/problem/content/863/">861. 二分图的最大匹配 - AcWing题库</a></h3><p>给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。</p><p>数据保证任意一条边的两个端点都不可能在同一部分中。</p><p>请你求出二分图的最大匹配数。</p><blockquote><p>二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。</p><p>二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。</p></blockquote><p><strong>输入格式</strong></p><p>第一行包含三个整数 n1、 n2 和 m。</p><p>接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示二分图的最大匹配数。</p><p><strong>数据范围</strong></p><p>1≤n1,n2≤500,<br>1≤u≤n1,<br>1≤v≤n2,<br>1≤m≤$10^5$</p><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> e[M],ne[M],h[N],idx;                <span class="comment">// 邻接表    </span></span><br><span class="line"><span class="type">int</span> match[N];                           <span class="comment">// 存储(R)每个点当前匹配的(L)点</span></span><br><span class="line"><span class="type">bool</span> st[N];                             <span class="comment">// 表示(R)每个点是否已经被遍历过,防止重复搜索一个点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))    </span><br><span class="line">            <span class="comment">//此处递归的解析：(当前L统一表示L1，R的对象统一L2表示。match[]表示该R的对象是谁，st[]该R是否被该L匹配过)</span></span><br><span class="line">            <span class="comment">//①L2只指了一个R，L1就只能找下一个R。即此for循环</span></span><br><span class="line">            <span class="comment">//②</span></span><br><span class="line">            <span class="comment">//1. L2有另一个R2（能和R2匹配），L1就给L2说：“换一个”，然后该L1就和该R在一起</span></span><br><span class="line">            <span class="comment">//2. L2就去重新找对象，此时L1的st[]是传给L2当参数用了，</span></span><br><span class="line">            <span class="comment">//但不会对L2重新找对象有影响，因为L1遍历过的R肯定都有对象了，L2也就不用再去尝试；</span></span><br><span class="line">            <span class="comment">//而L1没匹配过的，L2就可以从中选择自己的匹配项挨个匹配</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,m;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b);<span class="comment">//虽然是无向边，但寻找过程只早左边每个点所指向的所有边，不会找右边点的所有边。故存储时只存左边指向右边即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求最大匹配数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//res 存的是匹配数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展：<a href="https://www.acwing.com/problem/content/374/">372. 棋盘覆盖 - AcWing题库</a></p><p>chapter 3 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黄氏物语</title>
      <link href="/2022/04/24/%E9%BB%84%E6%B0%8F%E7%89%A9%E8%AF%AD/"/>
      <url>/2022/04/24/%E9%BB%84%E6%B0%8F%E7%89%A9%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="25aa1596c506b47d8f5faadfaf33eaa10b111fd786cea136b62b1d1704234b27">2779a6e840bf540475d4100b8728576d96487a1851407c3f24cfe95cc1685d5515d0e381f1783e7aabe43fbdb4285e0ef16fabb5feb4671d11225a3ce89c23dcaafc188b211398caa64802734dc5c2c20d112a6810ea2fb847baf7a4b6e9b9d4addd0caad199a750c304c36862fb56b947c1ff2cc12523fd185607964ed52e43dcfa712396c8b5aedde3763dc70e65b17e8cb508fd5fcb2cac15fa7869a597cec0bd0fa4a5aa4ffb3ad83a6969269c1990be4a3eabedc6112b3ca3ee38bade193d5dc0209e7221a4ae4a3b809cf365bd2891751e552cdf2e02688061060330644d95ebbefe7903aaf1699d97694e9ea35250ee09723192f524be6e05a08aad416ecfddbd7de5913ed57bad79920a6f818e3085e868407b768dbae460f2daca114eeea6576feca3761248e6f11a80d7bdac7e0efed1a091b39fc51f62e0a073312f5fb9c29c6bb1bc6e0d8197df24bdfc4f63fdc264e78050f66b3613702861e13e834fc7dc1f75c34b9743cae20171b62724a6ae5502269bba245fbbb6d5a68ff3d37c8f1043c54136bbe7fe5e7f69637b39a5cff7d4615b9c7e8a6bc8155bb2f33e5aab3dea5ac1b8a799b5e32ffc4fb012d88911e4903ce947d9ac42315434a0e3bcf373792a36fe4c666e6dfd7d450f86496f0ce0db9e9222b5548c4afb4687bc16181218133ab5f0c1bd13132ce300bbc0752b673fb99352cc966be4c00fa91673a81ff34eaffbaaf234fd0d28811350951bad1580034c6b199bc7844e61971009b6caa9a67d682f3e2286cf24de690550f6b0277e03b4b5b1996f6151ec28db794ee211bf5a22da0a940152f80a42682f43013cce02221dffb88234f03089ccaaf2777a8d4bea3760c2b10652d2b815aad8f0248cfeb8c4b3183aac49c09ed7ce2a862b9c4ad879a9b8868c48ddda13ccea4c91881ff9aac7fbefce2cd69e30cb33388ac8cbad67b7073bce750f11ed3f8ae7ef69c365ddefda4a6fb8081679d784cd7934af62503ba809f1e9ee2c595dc24ce8c632cd73d02063cc81041b9efae8ef046e80bfa4abe65ae65ff4925470f98c231b11738c33e3f46e55260741ef7172c1f215bff23058fd3269f283949e162a7c17dd63b3da9633a571ec0ff5223297dec67a91d5d16ede70d0ffbbf997f2f51628396f1a692ff8492e691362d620ce986f344f17680e95aecc27e0be627fb53fb362d9df87b099a08d115813459588a141c1d2323154739acd57ed9e54cbe89dd17cdc6dfcfaf70f881e06723a0e2296aefd43f5d7788f7b1bd040419512e649ed89e40b5b3a4170189114107005470c979e829948b4b10136cfc6d02ade8107bb8f3d5e53ec05ab05f30e2f45d48a05b61e4617b0303ea1e8e65d7036936ed1766df82f7eb882990b4572ca0af4ce63c94c7a276c05207d1c304ff82b46ec08a0e170f8657ee12c55b8455705e84b37f5a52609c73c5fa7fba3c9f5df73bf5dcf81d865f4214cfe4962b44d8cb8a2ce9fd9f5d33f3a9d35c89e97f925d70b3fd8ae7449622176e45475c3ac78b04b3ccc2563790dc0bfae95e38b32cdf6ac967bb3db39f089fb3448aa1cb0ca63fab0546c0cba5b1980f5884809f1dd081df72a09ee80bb69249af47983bc6ab4345de53f8e4c5d4ee7de52cf959fc59989144cab7f8f7353e906ca010a098771b1fc4d3b4a1e79964fad77bda70e55212718a543a874ebd61d023fd5ae210406f2f679719092f61e252d4935bdfc2862e4411aeb9aa004a4ff24b65de6f33df3d3df5abac990be7388725d7bb570894bc6fa4935a421cfb3f1bdc9b85bae0e613566b9037b6cbc890b59d2f446bddb8d4e96ae63b341c76bbb94fc99a800ad7c3a387a72f7a2b75d21eda6b2089a4523a06756bd131bf73c70f379688bff0a0363c17e67782b8f838476aca1cd28b8152a2712d2a0ac3e11bfa97f56e8f005253845812acc2b461156959a9a0618567ac22774ff41104960a02c085a7c6a9088fa63727d0a7aba8743c6141cd2850b7db222f8a3e2fa486b376d28982c96eb35ecfb7001994c72942a7a552fdc385abdd47af80d789548d1ca1a01d77cfde7cda8c02a9ac5da5e60fb381d36df99dfc5b733608288d119ea6eae8d012ef384dae5e5d982539310442060a91ef541ae8163e06220d06beed9b6d86c8a7ab7f8e720d5b62c11a4557b2c8a6af521530f904ad3d06573751967dd33e87d35806c7cfc1bb65c83adabb66081634e183eb46a33f29848c847266e1f5cdb309410a856adc31b4fc4ca59f7816736e50d2d0da0023870a557d034ab81d9deb63a74bc940ad3f855d65b0ab9e60d3e0913af4049b8bd809409e30abb614c6ebbaa357caaf4847dda147c5a189340e76a5eb20f163dd77a28776a12cf9a47d9fa23f150d4f4f6802b73e4ed909a8c85538464f5236efed6b6ed84d50e87581a656771f952be94359f73faaa8e069ec60a59689e07a9d2f67bd6a84e5b5c7889600dabade8d6ddeaaad7211214de029b4011ee3471d4d27c7bce9e34f1649513f171a984b5d387b600d2e96e9b54511f7be154ad5b8d7ec175912628dd2942ca692b67993a30ee70ce498233c3f95bd3c1df2b823bd512ca94b2461b3e2f1bf1fe735c5a60f7d9723e79196d3b970067ab095b1071250703afb93ec7b9322dec23bba601f3939eba903f87f7f2d8acb4ab68c2dfc9af04b1a4db983fd7a7e0adf7d9c3348aa5e3b91ec9c4b285c8dd0b794b28948f94e4ffd179ba06e6b20dc3a8806031ef5065890312213eb8869584a1cb1dfae37483848b387a54b796aa57a78113bc44f232211b73f2cbb7a59c0c2ea89bc163920a611908f96309ed9818e11733a67ea71432cbf5f376019d9881a0814b0c4efb5309d4b53512d359eb29590c7fbc6a09ed5c79ba18335e87710512dc9d5d519845a4cccd515481ccfb9dcddba0bc4f9b9140c4711b18612802144e9fe556216a97ccef91c349f040d25b12f2fc8ad30ac94bc506fe5bd6db7ea967a6bd04da5b6d7fc2d663dfceb29de9cf652a3dc962d6eeb5d60ce7eee075e2e035b2f7d9be1ffd239f5e0bbd8b7747bb2fc597ecd243b1e176d5ed81ea04208027be83d15804b60ee3f96ee4c5ba2a70fb903865fd8b021ff05d7df6358d68125da119cf54d60e526123eb599555842edbc886f67b10af4a229556359a24d5e0a316e151ff453a387d2e9dc500919466c55b800915bf8a6ee5a399df5e29ebffdc9acdbd2bce90326616b274495362dd353fbc1c347256aeb8a1f33cb0eb7e4f5de98dce63d3e2f0ee1d0648faeb188e25ffdd82a3699e7c98159e9a802f6b9a8aa75e520ce2aa8f0c39830d570413331bf695230addf912ed2c8c79f0064e7e633235e3cb0683a01c9cb997a7be824f741de4c4fa802f21845bb44a20cfbf999583bf873e9923f1ba7ac05376cdf899ead1213096e4bc69f999e3d7001c6f72061f1fd637fe9f649d476d6f656d473df7b09db02280b08047587d1cfb3e8af4922541def4c56346e13a4ff6d51bec73827ea73fadd488d7b9de2d126ef5db511e987f4d4a221d3058338421975e2705a9ee7e87bc3b918690b5fdf11735c10693d9122449d3e4731ee8d2e1d97d3924b8d1a87a5528f0f0e0a88f70a5b9413151051de396fa1f29b7b8486018c191c317a0ce84128762844964bdb39c118dc0b46b18fd10e10ba2195fcef115eb78a236f0146596e307663c8b145a5bf73b9ebe3af7ac5e850bc43e09ff6704d65bec75e2afe3ba166a36f9d6399eed801cebe810c858c4c071159b6baa0a8bb32a6e9b900d9d3adb1809cad8f479eaf53c3fba3d519455d30c9b9545493b874e23221105b74bea1a3ffb916302d4ab17b5f9405ca1bc2ad2ca97e9699ce17284cd4e8c262538f1636a0426c1334fb2737260c70fcd40c21cfe293aaec05ff0f454f04eca61a8930c3567b8435833ec96dc1787607d12d90797b1d6e72732bd5b4599452f26b35f1f86403cd92fcc232eb21b140f4858d78f7f511e2e5d4b548f54e95e879e2bb6c504b04992fcf80217a573355fb09d79a932d90fc3cc9caa40f63fd829d25b396b506b9757b35f89179ce0b470049305103a1011d3949208c5cea5558d26c6fe3455149c76f17fa547e3f28c8eefae69ec033d527556c971b9094891c7edb59c9aa55e941891b48ef34cacc5dc1641f1afa8e7815b0f5e7b0acbafc1dd4051b82afb8a36b0122a68fef012a92b09daf49774096e40b092e51b8980a5e7744957513a8780ae6524eae18fd817f4230e4193841cf108e5b2a915caffc6cb97976a3ad5d30828c620d0be48c33d5f85604afabcce47c161650f85089416d4dd8589a9e366a4a6ab8ee2ef7ba6d57c128d1b2b6214855e9f4abe62f06d3ec2dcc0eb116589753fd25c79707b8d8c622b34ca0e134a58d659ca96778c57ec38a62bd8feea00f9630cca55054fe1d4e29984d4b0c5949920b5d9c15a5083c9cb7628e669f9e410b08107c23a6fa16ddbeee7fe73b316dce22e87b18d2b2891fe727c056e99713c98705b26810e677f205ee10d378cc15f408766cb10739e4f8a636486745825c60ecd26d7733f82dafef989a98eb46e712fc93a20e376277d423b8867e751508638c88fd113117baa8212ad9db625644ef00c1339d252129fc5f8ec4b4360621b4e1f117c3dff3d407cd1a3b7d6558f6d7c381baddbd173062e614f749320d0618c671a9ce331aaaf4eae6c0d135603849ff43edea9aaa72ed8b217728a2e1c235bc36d08adcef359302b27bbd69c0d18a50131a85c486211bc013dc7846b00fc7415d4bb7a60ac963b7fcda41f4503dbb4ade5d0b2334d4fcee5eb58d8afd049685b7fa12a3f322bd85b603dcea9a4a7bcdc5e73ca198b64891cd042087309478e6eff5e424c6784f32428750530f7927ff773dd57133928d8d3b0e0c81804b904f56024d5247768502087efd1f8700245e2bfab6146bc3cd9530fb14a9ca3fe1306f605669fe730775c154cf9d7f8ee3472b2dc54aed4b241255d6eaf562d299472e58c394b7f4b91640bd65e4c59d2ce2e4d6276288b7afad4dc37496ff403cd5efceb49f4b5b1d21b2dbf5da1d9a12879ee028734dd0ae14d1a029003f96c2bbbade6cdcd5b7619f5fe0a007c5f2c5bcbe45e38368b837981dcc18cf68913e4f4c009579c33c48a0958af638dd784e6df083edf94218895da45948d6060c229b840c7c8639db2e844b3773e85132caaa6ed67b6ae4fc5834d30a556fab3e5c4e932eb24e7e58cae31bf1c0f4c0f22dc55a5eece2beada857a965085b9c31ed7ef402e60ea25c14e821eff3279bd45e71efd0f907002bba7a2c91fa794a1bc7d4f1044f08f9b530696d20a4134c337077168c48792de211928a499389a55230b201e8fe5c7efed0e89af116d4dac1950be053b8bb70051f8c913bebf243bcef70ed9cb12d84ddcca954e62e105848221332a0cd4ff1ba5bae57b82202581c4567ffabe96c68bb20f4d45cd25a2ce107cc1b0f2738bb9b0602426468e48324d2654a9b1096599985569d0b84c0423b4c96569147216ac674ceefc721fd7361bae4cd3e87ab088d67f0d9437683c0af50082bef7fd597dedef905f3c0997358dcffb3d0a445b344d0ef8620f86375062af3a67cf71b43da215b95f45c83659da5562d804163a1e1b5664b10ebf2274ee4a67f10993ccf1ea00f6de153bd055ad0b7017f8e79f0922d654c8c7c399b56770421795d1f09773ffbda941371e0e1b59ad2fd4f09db7181f3dac0a0057dd7831453818c88d135e9b12bc471d138a50752afcb14437a9872f834d2bf84cc0184411d32e251e8ac3107f57ebf7e812b81dbbd64999149258463aabcbbbb1e61a94cf14c8210ad10b713a0106306faa14f071e0601db525d902a022ec52cac0008201572149a1e3c71f8d81889ce6a2f8ddb440160cd4416d0154cf71209f515f343ad18a08485c48801fc0c62a78d94dda2c9d1e1f831b77602c9b4ab5a862e374303b9e221922a06ee3eeacfef19031d52dbbea38bb1c1ad04a7f734e8823da55fa5e0ccd6beb2c88200ac199c80c074a70e80ca56c1b50dc684a03f5da880dd8ee03fc648dfbbe3915b70c438e59616258029a89b3ed93ebf7cd39299ce2f1174c040523dacef2bf3dbcc3db8f405510e7e8ea77a7954fa471b8f45881028b09ec91d4a5045cf764f45e5fd021f40aff5a58a48fbc35e126c77e40569a467e6c0adc134d3ba4d8002a7dac83c215bb2904bc91b9dc804325c67c0a2cb594eb7fbd8a989ca123addde0d388b05d4a43ef5ae419e67526458205cf991d23060fc639f25385bea339e389f92a8e014dba2c5abf95b67a06ab266277c51a5c7036ae15480376df7e778b3928e4af8b89b45eda17e7f204abcb37b4126c76e4c9ca7cb08ee157a0bb685878aa6331b52407bd5fb9c3bc73b700d575b4804a65ffe55012aba835ee2802c18ea545a1c092a2451688b89829e9c8ef193f30679278c3b6ad782364fd7014bebb01de8f886db9d298b2b45750f27204269c5719b17618957e0c210a4490069f221d5ca00d7ff19e89b4289cef6cf0dc5167c34418c1760bf5224f0a7a24783f3ec24a4e6ba6e5cd9734a64c766a6bb0f3829dfa0d918ac57661cc5ba5647451052a88e2a816ee7c92d5e2b8443ab6208995eec9244230fde5dabdeb27ae2f1ba7501fd4177efed61a3a1dddcc69775068629f258ee266397197dcf3c3ed060e8f78c114b3641b43a8fdcdd5b952bf27619e85bb3049f4efa38c76a643be24814ebfcb0361d7fcfa99042927f0bb615220ad394109f18805f0c04abd21b8c9dcd366e72481cfa328c3b3e98126d1830e4cdff81f6e37164ac80330b58d3e8f3515edc3bacbcfe436f98a9c3b332bb9a0f02a7e3fe47f623f21f50202e2924e5d99c562f07e67cb6047e6b5d74eacf8453e0c6c5d75ae43221cecac6e3387a01663777db88b554d1186b8f4bdc330863f0765cd67a54df24cb29d3c0d23e2f544fa22fc24b05222f7ddee661c560aed6eed55397ad6defd187bf9ecb4d36892575d8b8bb4ef54f6aa9440f5f8af8513e0056f4f6e1222198f56b3dfad5c1416afa92a05a4566fe055223749619137fec0a0b4c35251ab32f87426281ba4b25be75018276f4cc74e1763727380db0e5d45cd5f159bc815cbdfe9ab8a51917ee3638a37e053e2ff7806c2fcc1047af09af86c23f0b315a2cdfebb7bfdf10a530064fbdf659f327b0baf487f802b50d43f88649983d266208e3da282d158c4fdb06b227e302777b17047112a5eb6ea354ea2cca914540cf58fb6c97522bf36ab4573090d88824779893105261cc8df26aecd7ca9e387dd55bf2df75808647f847d01fb079337eab450b6a346979d69338f7a4aa1a8f0643551e45e800f221afe3f743b0292ceae09039b7e948c282fe750e18d2e934000354f4d2b5945b97bc9a728aea13c009422dd9cd1f42cf61afba62e3f0cdaf5d4a2e70c361d9b671e6c212526dfb89abd44047875d91c0b79e78e43ee7a87800dc6fd75cd6ecf60e8d2a5386ef340efa789686f90ed66e1f02a4c165fd29d48cae3d32c94d092167f221f1dd48459338a190192839f91a6ddec0fcd4c7d6a48213f56dbdcf6a79367e2c905fa859e137da6b885062ee2af0dd5c9fa1360ad1d91bfb983481dd5862e4dfbaa8379d233bcd0e50fbda879ae50ab6417c2a73fb027ed895d063577f98e46440d6493eef327d04db72f2a463ac54260f305656606322debe1f7f6d8cb285650ad4f2f6ef212b787c786ac9bd8093fd4794fc8f5660313f0ef7b91a765e5a1cf4321c18fc9a414a49f71ddfde93de5f402d989c4dbb64e66324cafe5b08b9c2dddf0fc49cd0087aaaeb90ad2af775df131c355a7f431ae2838a6f51bcf0d07142e54947140d4b587cef4a03f11a8291a2f69654f634a98f252375704afdb3968f0d68521ecf3960c8628fc09fb27d7ece8711765d1c1282289d180d8af5fc6cd14788ed11096a10a02187a61a3bb333024482f00f40a274aa0cb196957baadcf174df881e6603ca3d1f99153c90f734b200025e15e6a49fc4f23999fb9f5d6996ae6364cd1f98d9c09d6291707e67e50e6db1fc487ea1d3bdede692a9f7c39ede6a1a24d0db02b873d68bbaf0682b26435f22c09b1bf04bf6b2eacaa4bf842c65f30408ff796e87fe00a404d232287b449a824e7afda5426d44a9dcd5ce47f796d559ec11d32228f25d23d925511a7431f1b8f06ad9dbfe1bb745ab02d303b7a1e9606536b833897fdda479be35e2f136f18afc12ef4fc186db46b39865436c2f35325b5211f1e8d48fa078d0b1ee75fdf05f0539c8418112db0ea8eb0f545fa591e2034933a2d4097f13270c4acbbc7a99d651982ae5b3709b4136441fd397c0e30998b3820c1833d77732935630c0062a1dc2a7b96d8a15f49c1bcbb12d6c6bdc252fd2c627ab51dc88c74b7e44c914c6f09ba6d9cf0af6c525360dc39106de06a23be18b44e81479384f6a5fa50d0a867425df472546ea36e278a550bbdb672e0d9fffc15b8bc8bfce28f8b7dfa6f87598a8f4cb75a3c3612c956f08064e5b4929ace268c5be6c90ba46f41ce5cdce89b0fc65d6d58d2cde62d72f2613b071a5f3f1774e79fb5526149f8bef55604393f8d2010adbee29ee383d5c96fbae2cb2eaeb3c9b3ccbf1a40d023d1fddbb5a7e68b1aa882a1582243221bc78ae9d92eb9934d61a153f64822f2aa598b0df8ad9d7300488403660af171c980bb050eb3dc3ae3c0ceb04bfc17848e7b2655d77f47127ea6dfa5d2ed921d0610974bbda7b9e263faaa4b2b98686b31d57efd679b66b1f02ba7a0fa6c1a39ac213f7fdc5b62038d094733fe2788779eaf077e80e0212102d7bd3df4dc8b3da75dbd01609a1a7d9fc3c95c5fb8be87d59ed78e33e96eed42aa50128c63e6c56fabd21fe0c0d19a16a9f98587870280220315455402a3cf3a8b003e4295f7b37c2cbf61b09c017c2a2d4cc0e92c2721a16cb3b667a2e7561c64bd78a12a30152683c9434d9379c24e52e35075670c02b4d524777850ccaa54163d1a405afe1a466bdee44f49fe3100e1f1a9201fb06bfec93912984d6100a38d56f339bc0c33458b0b1cde98bf047fe86b94f0626a5f9285794e18019c57a4f4da969d33cf3d53317ee4bb4b7a49e6bc2251f85725553c9a3e9ff47da6dd5659ab16c3e3b774d5eb6ab6d70ebd04b5e66b8f255e6373529f1f0653f70e65502446079ae0fcc1aeb6fbfaf122c569eac2215ca499038b3ffbae86c884a1ee0b8ab0b2bcd53219440341a38e1666888a3522163772a5d8981759bb490f9adc0d4191ceb1d2402e0831eea741bc731eb037c997d1afcb1552f95583af2ed92cc6ed4a972e0a84c3a339c7f2d2145ce735e1dba3c418e341e912c4256167744ad9f694f65f7c4ac6996b2709e3e7ad16d2e2f9640c2fb3a44d84e4177299bd121a3049c67b6981a98ecee1103299f8275ceccf2f418fe2f4795c708f69e07a6d57fef9ce07ec06a51451796ace15263ddf9d5a1dce08ea12def5f555f4d4852b0dc8bff77d42e3170a99134e5448229d8b8d5d1499a4390e0ed8adffacd18fbf95a3052eb3b9d890d6f646ebfe96053f2e2356e7a9c892852987e586f58abba782e79211dafbff7cd55aed264fdf174e6dc18911f16652856a942da329eeee3fa99fea17a24a62809a5ed625a224a2997c7cd3d27247b1b7f39629d1b485d2c5378ddffa2768a448fa4f5f7a92549179b0a77546776ce0bc3d651c6b08218791e82a8dd94fd1d9289731f8120c04dda9396b33d57481b5c34d9c8d6c8fb0ea479796befa15685c57a7f8074ed4e83396427f52bae8e9e54e3e69d212e4c998cb82782efd5dc09f9822ed3e7a081baf6f1eb380b4e2f75a544b534088dab393a4101ca188cf0551d868bb0af1bf4b1e70069a9e98258d905664027a77d4255ff0414e411866f3352d51b2f4dbc1024805278b29cff42375f02d5f4a8ee8c79b1f9436b184f4df9b725dff3bb0c639057ae2ab931a369bec1eaccb878f4cb8aef8df2c81434d9e0ffc6224cc9bf6ffd5f31218cc7266b0e1750f16c8469007ee837e95e9f50abcf45d6fc5ca3379b955d256c039d8e8f2a4bf96eba38c9b050c761dfea9495816081a1aa2dfa0df781e44700735ea57e4bfe95c07f79704b8bbc0b8a8b54d01b56502bc81230cae64db5ba66684acb78ce2cba09b4eb0420e8d94e5b1cedee498f1332fa88f754c65147216731f40b9502f6691d43527099fcdfe99f08573e4387b6a158bc85e33e64542f9ba5efa18d09ed25de31635dd3502639bbfe06f5e1f09174296c010526f38ae8f52f7ef491ebd2b57cb2731ffca49614c4560dabf1774491f6d0e16d5c08cd3a78b355305b57260d24663b85204fa97d37d8151891d59005ba69e1e4b37a749ce95fbf01d348a2daad809e85a05ec98570173e8c895c01dc5964fffc8a5ab08630f9eba2cd3f0bc54f1a04cc5ed9b1180c7e080cf20b9c217ffd1e4d7a02b0d4a5f4f158224240352aca309ad587a3a99c3ce1d2f509e74875c04e10c62ad0baf5170a7d6f5a7a32a3ffd4b0b13c0b2fa548b423dc024a43e733ff7fda2a605b181613430ce91e3e906c4669fd57ce00138120a6cded32c6fd6451782bca3fba8e3fb6e6b8a73fb7d88cb7e4432d412031089c775ec2ca2eb6e3ce1fbba6753b46bdfbb79f7bbd5a11115890d80c2f58c25300cefee9cb2850bf95a7f4cc0efb8a689ef509607c4ada420400e839f98d31b82e42a53d1e51894d1f6c9878fd18d21a96857eae31c28239b29b3f757c6dceed27eaa610c1881357b30bf64e6f3b5c7335fce168a1753b51369e13b68d564442850fc13dcb6989c5d7aa4493c6b0ccd01122b9de756e71ccf045c7ffc4e55ea3da9802c07809d81ebc90bf64e762309592f5bcdad274d55765610a60bb255ed2f071a60299bd7cd2441de6f263d444520bccc3bbf2d207890e22a1e0aa88ffe51b8a244700b003986bbb1f0a1c1b5748fc473b2b82eb4e67f38c3e7fc1390c7abdd6bbea1ff090c0956c20c06b4611ac3ad81f0f26432475adfb9e9a8f8a626e26fe4803043b2c14aa9552a1cea5db413a022629f6793f2f1f3d21bb05a66bcbb61eb3791cccf89877e1cbd0bed0f35e88d31cdb816c3212d903fb838d9f97bf973d53fbf9698944c20a9c6b2fa1cd2f202f1d0fbe7a4d6e354db1b4d60479853d1a877903630ee318dd1ef6a8a99c76cb8f49bf38538c788d58315c043f5f7b57a4ab51796dc09d65e0765abeb8b2f94c338ea4610e4ea94458eb991d88a5bedf0760ce2c0a60d30fa2adf8dd454ca747065b0533873715d726a71aaaa588d8821460156217345ada507716329db78bdbc152513bae9fb791a502fe4b7a723ebb4c5c6172b518a83a7195a1d6a20b54efd6ae3ef6090b34f5f5177fb727a08187655710ec559db51cf1acd8342a9c498e5d535ca63bf46ce80f0e5d8b3a8f03e4185dc8e6dd35eec77f9e6d14d83b5bb4423d7a1970354b6471a8061b4516b11736cb0a9e29d380cd6153be785ea526ca5944621b0a4eca77118c076ac381086f5d77a9e54134aa9bbf599c0cd5752527f7400965bbff2d8d25af4a2fa4f4d75a5fc63aefcaa9055b6400004ef252e70d8471f639f0e159f267f4383caeb691eb4fca60231253cb773d57671b1ff55b3f870a06442701a1535394a87935b0cb2d9719a20dba013cbea38a57baaa3ed8727c731302b5b77f771b28862999bea8fb0a988fb167d7be028b7eba7d73cbe2495236c01aa8f34a1ec913d34964eafd5e90e795caaaafa0329bee19e31a38363a33195403182c94415fa29d45258615f85251b058bd07b3de56001b8216414451bffbb6fdb00f00a54009a45d33a1fcad7909c268a4a39216fcd3886015cd2911004e8f21015ca4ff3432ad6c6ed38b643921f24d1c84351b413796c1040977a09ec8381d2df81caa86844f94603a6d868515f4a273e9f53ccfa105e67efd5ba505ece53a324c96c98294d79375dffd37d8be70a6a202b86c8d8cb45e88cd30c87e8983a4376ad90c73a4ca7a8a765909ae2cd658f81ae13fc3e231672b974653f3a2c3a694f903edc1cc73ac083ca3c2e90fec194d38d425cda6ba8e310fad55c75f698631f9b3a0eae23951acbfe15dedc3488928d14468e0fb0c790038e4b6ded121f3257729c246a6b6bc1dda61eb903c0da490ebcbf5f3b796b9e62de15d660417c3b258a0eff9249178d7204f018a80d4891ba565780830ed2566131da98669196e91534ca1a811a768d2008e9d0a1f8a65a415bdd361c2b3030b673f4b3c87325394cf328505defd70f68bc55666bb35b376df151d645728bf2e1fb28cab5c1d05d4c7e0915273bcba9e228b0e20f2fd2c8ecc53269eb8b894b9dd933ec7b700b26196bd83654ef0d531f133677dc64e2f5fa64dc924b883596e3edaece59b9ff3b2dc29f40cbf4f52b03d5bd6951a3c88abf7794f7a91fbe977b982e61f3d237d7f301247b26c848d199c26eb20577db2fd129f01b694b022395f094d25824ff3a1f74d91282dda111cffdbede4aed92358f7c1594d918a5e222317215013bef711004ab0c4efd16c9c27d70cf2312af61b4285f89fc536696104a9823840d253c101512ca66035b802bb5bb058772cc1e27e199c47084dce36887b5194559efea84a8808706d98498f85da4d187387ee05ca69e2482808a8835bb61bec84d6821e9d6189f51b55af54503417501b99b55af09d6264a4e6bb05f376903c889a0d023e1ebedffa5314e9a598dbe404b3f77af2c3b6f9ef42fa8a7e1e9a95e60c68a42cdc7ebfb36330c472568026fd1d64533aeb5275a20e375e5956bbb9d450fec6c674674aa21155fd843f6d6e1e86faf0c64b762f8b98245f59f8df447210c41b51bb5d18d24100516e4ce30f32bd4e935e32d55ef0588b517f939596ba90a89ab2aee46fb06cf1e84d5be8f29924f6aa800d8ba79603de0de8cea8758bf5643d367a7588c0cbe44ba5f75b1661dac9be9664aa781b0fce1c63afc23ec9d12a4730cc11930f1724b6350ee6395610bfc6090e6cab32274192301c5dc361480eff5f93d0a45503e7702631ab366784f805bd36736b19e68ff228ca5f590144458e188ff6ccb634d9cb2f28371b9037b000c466c9421bb73c47b675a28d5593bb880ef158b1d39a028c447b83d8ebed8b11aadc46cd932dd353c823e484eece85ae9ff4aa90740f3bdd97bf243f72262a70405d96b57fc93084294fa48ada672c286ab12af56e6caa2d265f78043f04d65619a41693fe128839a96be2b3b4bf3bc235dac8c5ceb515d0d20edcf499ea9bc8a216fd6c356dda1c4cbe52f6a4b75984546401ff130bdacfe535c4baf89a6f265c077739789950668e906fdd900a44f19f019284973d389e5e83acfe839a0b4d7e50c642a4f97af3cd4ced6ced04b1a11620818a0769de2b2c8a34c4f1d80d0facb602d345b5ae4627142c9450b89fa45633ce652e45602db2d760c59b6195564c0141c58f33142589ea01086e0b4f7169c2fadbf7b6c11818b98b05ce488c84f25b9ce82a6680cef3f7bcfbf04701716307074b95a95e86aa4cb7e79847f73caa7598f426b5b7aae0b8f86a8398e91d12bd0915413963f964c33321e8017dcd7f7f32b66d7a3e8df43d1957fbf1d06077e391418a5272e437e69deb24801579e5f5890ad599b19b55de102737818fb1a9673be596fd7e0836e2c18ab602312da2e2eb84b8871d83872e1064f26fe6d810b34ddeb64a07aa7b7cc0bbace089647f7ad2774b581069d4b22fc245ba046f6c8c04ed7618a64661ddb10079ba817531c7949c79f999fd3f318544e811e0bf50b4b6382c1bac02d27f5cce7df9f9f7d2fa04c398e7bef23e31764772d7681305fb0c2ddfb063d54f4d574a2764a80871669584fe69450ad6634798890978c947587090e32a585b0a3fae2936f8b90dccfb1057ba7f3aaae886d900a986930cd0086eb73a66308ca0a22172171299f9c0e171745f493bbaa4624af25a3dae186e962b4b5f7dbccdfc259652a2fd3cbe8d87a4a2c2f428d8b8642e0eb9270de4025170ef54b1126e620e3aeeccf787ada5ad8bff15423407155e08011f29f3a1fa0c48e320d75376c2560a5e64bc9379a147f8ac745aab812540cd3a24f42bff23c8764ab57185c72fe3f75fba7ee30c929add5c762f2a206e5e4289ee7d57a9b7e2d3b911ecba41bdc95633648d360a95a736a812bf737d03708a963432c5dfdb3a244a7fb19cef2d56dac6ea0b9205835068ea00f38e329e8a62bf691fb86c930ca87e870872b6a855b9f8eea0707d40a1c68880e3988cf2b03a6ddc03f4e19a52956defac721e4368100d792dd7667486d1e2039a007cbe29b2463598a7013d8b35383a5ae8b761b56da5d1b9a11faec716b57098f2e2c10d200877213bb497f3dedb1d3e0891971511daec0f8dc0960ec9536f1dd755445f038d1487997cee8605af12d4c00847a58f6d5fc68a521ef4c134a4f64cf5bead74affc46a21ffc26ce41997a96e6324b0f2338c6a2bc774b9ec3e7b3cd53f6ca6299c625754279760247372ef5c801cd1fd28bc69997f248d34782a9a161d3f77423088dc73e8ea86e706b0bd193d73e289fae7421f62d8c044c8250ec40248503db49f2edae2646e4b2405d8a14b2db01bb5e8f5842c7a2a52dbd0f80e2dced8a8c2e179d3f68d14b78acb3e52e42e1ce5d93ff773a1b66ab08b5be7fee937135d97f69599f201d82cd5b407383369adf401b1b0cfa378d4b1a12411507d57757d6947b3efeb23e5928fdf1ec08a4ff8432146e9665ea3e27cad5a292e475cc2d4cafede1d9c53c390503b70ee47f6e993f5d02eb5301057978d7c969391da747953b2be4271397695d7a5816c0bbd8b46666acfc2339a24f4014e1872aa3a13641351d30ffda4bcd4d68e22664aeed26f63dd2d14bfe81f29ccd2ac1c7b57682d73dc39c7dcc9b289a576d21f0b475d04b62f0e32b0cf78f8817936407f057276e8ca2b8677a7b901882a4538f9867134becf4704593b725fc2f1a6967584ef7b0ab666b4ddcfb84d0c7da28969eb7d16e528fc022264e3c18e7acda511a0e1dbba0cc7fde24b92301b520dfa6f8bd14713ef2ae4619aa5ca27f94dbe6aa115db9a93e851dd90a45413f7a5424292d92675a69d36ee3a658423dc7318150957906bc7e05221925779c40ad063d2bf50e33c14658bdd9caea0723057edd2e8eee855bf4b3d3af996f9caf280b650ff1d8b9cedb78680274e88229962b785817233d4c14fce70587d17de3351c904aacdc02908d8427d42f6d3d5946b292f7cb7a7c1ce2d54d6feff6f35a089d0fcd057c10407885198e60b34c23e6972ae0575817661d3f2376abb2730b0b0a122ee3ac5f4af7b18c4b6bdfd6ca00cbcca4cc06f4e0fef1e184d7936175199567efc1df58408f71d78b85926cc49fd62b65c4fe6ea2f82bf9a24dc32420a92331cde275c6c4aac9cba0924dd170c7226dc068f36f37024423b6004f1a5cd999108964391b7bd913ffa96429fe2c2376583ba23c934282d81d82a60b77fa7f34f895fd8e99919f65ec27a1ad80965f3f63fbf83338352fcd794cfda11535a64d2a8954f172aca1b4a5fe4583a2c16ac97742acabf497bd380ceb07456a41895d392b4cc06b7e3f96acba01cce9b88476c15cfd9ef586dbf73f0d341e58259e7843146bc41e7bcdfd66c92c5194fb96d147d41aeef47e96dbbddfee302c1a57fd27892acc0ec1c70be784c6321f56d5c7d5a2c29c5e5d15a787d20e765cf80e9570c00d1383ec1997de32c8a60fdd76c4ad2c99f9f1f5bb7f1fed7eeb0eb146f5b54bc59f65e9050844aeb8480dbff10aad3f447e5918ef983d65abf2fd443f3768916bc0e3cf60aadf9676a8cfc5d1dfb463006ebf874c7916678ef97b9414529f67664518404ad62f561d5ec141c37c02d2903ababdf6fd5712e9e15fab1ad87b0485e8ef12bfff453f32bdcf3836cdbf556de2aae953cefb621945dfa9e7268157924afb046d4edfbda9ddc54a4795b306cb46b2cfc8e14bbf6a5d761b0a1de19b3d935069bd7b6ef6e2f281dd5ae16655a8b9a248e8ce1558f9c7b2d415616aea7f808d15c77fad93bc0ad0b0f0380da1d8cbe3a66ef36ed2e013c1efaf6ef43caf28d22abc1eddde189541afb56fd89f18b22f937fc312eaae6255c9d14c97e46d998d9412e972ae0247ccd7889d677f5474112326ade0738a4be9e22cd2e5f33fbf822fb7b9bcdaa78c122d6819f7760eb3e20ed42f59981a23ce6aa9e459ac54958fa5ac9992ae43b8d47f9b2d4e296e924e794a1ec1af5ddbe2ef908cd52e4e5ffb7afa425a2590db87e004ffece8b39efe639b1b2973d1095e407197ab0ea06e4c542b75fd0751254481ef6111c84d0747dd16127a223d873e4c97c12dc5dccf275bf6beb612be2027731a976f5fa6f6a04b72ea1eeb0106894fc29a0501da639f9e662626e9296f84bd855d1cd3951efdc7154f88f8182b26a430767f1f9dcbce3f703cfb70a98a76914a555c3077573a784184daaa73abf5972d7800cddc6804df7745946896196f8d2f58243e6998301d86f85ab1bbc8479564e65adeef5a5fdf6fa4ffc3df6d9cbd12e41c2e95c74ac089726f9d4757cc56832509f0768da7d83c78c02c73b04a2eecb16f92df4fe539f3fb2bc6f94329b14dcc98e6f47a6a85852cb83a931c94b73c1ef52857b5434250d226d27693c5306674e75ddc8f201ae14f205e432e1e301553bd8623ba5f154384f988b0600c37d0eb4073e8950501cbf264699377eacdf332b82b90d3d82753f5d1d97f04ddd35547d983344b34f9ec1b4ce12895ba100543c6ff7ce7a12227905a7b2b265fac79436dca7246caff66335fc4ee9b4f640251a1f27633e1ac47426997e768d8845f4ba72ec0a47a89ea59bf1db419869693e1103dc8a481c8ddb5449abceeaba080375e43e0c1dcafdf3c98f0589c090f1d92b0a527c924033e10c4eda8f86568987a69727eafcec13c1610d49f0f800c375b93da74ca05214f3372a934fdc78bd4a6ac9c05c849d328bd6cd6f7b37e72a88b8f8ae3b8c94f023f1ebe9ef1cb3219ba5fb13ab1a27827edfdfe7e74d86d28e267fda5c9e1091f98797e991c735616541b9fa3fada61d909e1c96ad70ee2a7b9a093d4e20306c80751965b90851edfd55e79bacc326801b14d3471c030c02f97506bf9cdf34dd20ecdc3fdceb732c6a091940702574a86d23d0c68bd7947a98b71d3126620283a4264ed9c4a1de8a9e2ebf7a598576873aabc865a0f41e03cb1ec46d306c5fe7ab1984755441930b9fbc277575af580cfb1ebbe16cb5bbb86b1e722ec3caef4ec13fa2edbd9e2e829d0961b290caa809b66f6578597051a95e5ffc55646fbf99df4844f8f5fd5fa9f1113110e3fc339b2e9487f48183f76c1e33f38a4938d4b279fd3359da4116cf0f5ef4cae0d264d78950d4ce83df70c90c1e1ba8cccd9f43847b2f441506d2808a5cab17cd7efc5b16b34dda5913ecd40adb482022bf7459aee3da164a60d4dc05de3b4d805cfee820b772da9850d7e766ee12d1ad505bcb43df9e0c9261b69fe56ab8ccd9a7a6a5e78eb3b53820dc81ed93b0c1dafbd32a3047a15f75b43cef1bc98663bc9c76211115faff8c8418c31df5c6116d23dfbc0bfcb4526954fe76059a789655393deda2392542e01ce3c4e3e25f8c410ee013b261f4095307a8a360d986bf8d341ecccb08940e6b5b316a372a709b3c9eebd9229020386f881dfd3fd30ae03883daa73b4e7bab684aa730c034b89f9479a974aa4fb58115be33bbc7f0fd4dea3e009fddc54e0c0547d041289a48f4afbb378d47132e83562517c5c6a75f6fa10438ef2460877b965ce7c519a33572b5f173eb3866dba0ff8890cd4d6f3cc1a150f7de3e0cb91cfac4ad8f8c058542a6c55ed0da18124d7c071fbdd77f036af41e8cb99086eec4729b53818a1fb758a4e7a0336c94ffdb1c4e3f0a834dda013cf3f23bc1902c0f473fcea852ba025b5cac0bd3f2ab795e77dc98a0933ab7bf9a19d7c5dc253d8698e43bb07357d6a00720e215a2430776be581fe2d22f53c0ea5db8fcd95b752bc461b4db8b7024ef81512045e1cb4a901f1d8d103abe886915995b1a4d67b54d757e3a6c0c24b9fedc6e8ccc17ad89c2c51c2692a4017e10e9f87ae41e2e28eb8a34a19509cd8ee3ae70e744e1baece65bc3326ebf16abed00268b07a5949e8744d97e235ce4f7fe79ffc23d81ce00767fc6a6c7dd7b845b94f801998b8020c83bb45c24a6d3faf8d2a8cf0b2392ef77c4251dbd512775d8030221f9600953d2f9e13f7839f367db5d1c61e3c46ba9ac1cdac415fc20e7a24698c69ba054983d7171bec50c2bed7aa8351fc5742bb771d91eb28002c841e2fb19d82344ca3f12511f0ed5a00d42390bae6b9ed5dc238506ed7c5745043b2de1f15b06a553d8be6b6b4d169fc522fd8fd8ece39fd156520fac5c067427754ac64b4047c169cf39168c3f933ecbe69281a0102247ac115a3cb0d812eba32a3c93801c152ca41f46fb3f1d3c9dd055fab584a7a58dc92d16e9aeaca180a17da9d1fea435f4e9cd1edbde6134018a483b79f0ba91a0a7e4288ea8b3fdb1adbaf068a62c02418113ff5ae096f984991f628fa9e6c980e41c7363905c907be4b2b19f8ffae3ce2d1e91d1c870018ebd1b535f79629dc4c9a5b640334310a05ca709fa662a0ea080a7ab6d82af784002902b0363ecb0f5b566c814d49204b756a7bf34892a4845ecae202bda55e409229d2d3ad43b15db5f3300a6277ea1352285afebb8b5b75db7b3a27289c4fa872fd1ed6cfd340e0b6da579a4b7e5407327d6f2926a6eaf5c8ced03649d5b8edf2205b3b8ba8a08a875d713a4a0c6c9eaad292bd310b119ba4a50a391b6ab7751fe38e02a6f2d86d8a1f1c21669e4719f502343d9600e5af5bc79b3a6baf50c47671235b5809a4949751ecde4aa557a9de8f08ea84e032a1ab6d25a6b24d9dd9bafe5877d333eddde64683240dfce3ff19e5889665f31fcfcf4f9e1aeff2a1e0dfe141d3b8af0343ee00c76b79b0adeed57e7a4fc501a488268157b8757b6de695db448f1319f113e621d636292c066cae3f770051a1a6c63a5bc4a89d559614cd3dd9ecebdbabe6a731618eb9a9c1fda6be16d213a1d5af0941c777025466a096987c89f11a0fbc941e5cad85bb1a6c95e0792f660e0988ca467563a972492215e06ce76ee463f77d628d1fadadc3b41a604234173fd8814fd89a69b8d627fc35ace65cae33f4fd5ab0030566c1d5aadd4a7f50e6a3b1b5c8e627d1068987d33d0785c01604b00ce29f58160e546b18c243f5e10622874d7ab07282e6889ade18c9ae470f6c5d66f40e61e06ddfc785c58b975388961b8b1e756598b078ffebb2631a99208b9654f13f7d92174006f53bc77c996b87a8303a64cc95a8b2d51f00e783ef15fb0b8c6dd643b44131e169b9af2f8f189b6c080e08ef6fd1af7005c0756ef4e7967ce8b94a2936e30c9f349164704315861c3c2fd9e47c2212d79a6b2fca587f46ad7dc9a638a8704e0da7a1900b14b7cef5fc2b45bda508708fd5db42daa0dd285c60a9e0409d249006e170cbfeb828a8baf265561b8ffa39ff9bf5ce2394b5a9931c72235d648d5835136dd2ab5f1b873c763a99372d2bced7b022dc9649eec9860927ade12d2a31e910537c102ec4614aabf93f8091da48373501a924c74932b63c5214b5a23cdbd10b5921bdfa3a70b92a94680510b5cb200f9160ccab84cb008687824dd1de73972502882c9a3a5fc7ece9e58986fc6c0425815a80d84dafdea68c48b1c8ecdaa45f2ab124be12defa94ceaba49d30a8e11f354d7cd09fe90030a21d1c021f264f38b5fbc67428c4de24b2c7a1c796fa72758833dedf0e73ec342939a0b70e94545556992d98683daa8a1deb7869829ac0bb8c7795b761e943b78373348786745e257a78cbde3229a30a2db216d8e3956d571b5512b6edee4607d6ae58e31ad92420aa1bec93ee1cf08bf85b984942b71a5e95a3b089309527b884e0dfc681ce6626ff3d789f082cf8bf3fba44e6f51d2461326b5514f197e85890dad200b0ed9033271c7de163c0089c80e06a30bf68e9ea0545e03314b17bb21fd0329951fb4d081df2bba8156401641f502b41b1003aa8851ad7a00bf4f01ae7bddbe89ffcd6b500f5574e3eb7f07f71141103e5e97697cbe453365b618a86eb33adc47aee6248727b056b81fedd92d024677ec67dd87aa4dd9427a64a3f4107db2c5f3e74d9463d5edcb9f0af0cbc4450dbff66cde0740a1e245273dfb3727bed86a0ba21e024c32e0eefe631d78951ebc4216816f9c454b65ebbf0c3cb3b00fa806089a1809e26b16ab726c5d13d3cc63d532b5f1bd5d2972892cf010d73f04507f3e35733bc31d3dfb5816aab7471c78c31e73d7d12d96cd77cc552648cb611dda843478cf56c11a888f98e23834d262b71a2823a1f71e5e93da7fa0c5e1fd98026440257f3baa76965a2140d284e75d4166a723aba56e7728514a2d9f5b2ed66adf91574ddbfe6b5d44a6cc5985d601990fd78e207e31d52ab18ff0d6a0f61d8ea734043bbc1c478c4f752bced74f45b3c7eab8108149df6a295ef55a7bffcb482981ed53490097102c0d34cea2af0f5639b3f4e1b7e884bcc0449cce4249ca074252c3a66d5e8895faa18c6903f155e506008147fc8ad4379cd6a033ce0d3a338ecc5ee260329db955608e27ef3855f1a0616ddbcafec15f87a21b7b0efca4b750bce81b7d7d5dbfded82b3f1c2cf581c32fdfff75b7098cf7c5798518f43bca65397cb2c7493be2872e7e3e251de55fb8fead521317c59fb14ccc3fd3e8e9ab68e8fd81a7529a631516df9bbf350865a492bf140fca05e534cec9d5f8c721ba144afe43beae7a64cbe40bc198140acb4be29a25165a9e4dabda176136bac51ce113329a4967ad3bec19722dcb2c0a6128dc3cb6e07dd4d8d61891f69d40848c8935258b0c2ce694e14584f8eaab81905a28958ef276f8abae889c684efab648d173b7d8e5b0f1c97a3742cce80523f143a08b2b0c6dd16c90432279f1d2aade79d8ad783b364dd8392a7ec2ee7900af3816e693f47e95fb705cfe714099d4bc7704c05ffbbddb706744455b058cd27bb531ae5e9299b5fda77b1241c614ad69da9fbe1288a3b139dab82212b0e4b99ff641b5bb45479babf4159484a8d9e133cc1c129068ba3ececb1a1eb6ab9302b5f6b0a61a2dc2b1389d08716d409040d02db023924c8b530fee0a3d508a9704d54a2578123558740b82fc751b0f8215e6463d32eed36a6f3b9a152a9b6b913cbcbd16f0c6f1954400c0e478297a963b3f201e2f2af9d8be364122343ca89d93caec752c6fc3253367c682de6f18c858182da19266501a2271ff74210e8642da891544c8e579092515673d53d05a598f83887bc6c1db4788ab91e4616f91db0575cb0d1b2d53d78e27b6aeff5f4347274a2c8a05e604e607e92141dba5f2c571a6471ce862f467b7649ec353fc2cf17261dd2628405b6c557315ab50ebbc8742e3a9c26ec85034aeadd65bfb4e4a9f11bee325bff0f85a9dedc16a9f383626b4bb395bdb9563d9baec53fa93d0950755bf3be50fdd71feffae63be2d2ce5c0f46f773b972575d3c6f364f03361e948d6f9efaf2bc63d56a349f262dea5bd3306b89ba7c6a2aedd87b13ec53527ddcf555da4855946b35411731c7cfa3dc1fbf15a985496c6e1e9f2266a28d0b052c24779f92393659808d8cd74a8512228fd30a909caf459e7fdb5654bae148574944b01a146a85a786ef90bcc4effa8be4755fc3c884dd3c51ffc5915cabbe7881d8c613c13164d1ceecaedd1f5cb50c7c1765d04316d102dd6c2250d47b1233f3794b83765888724a871d75e20fe91d524c1ff80d3e07d36fc973c3d5d3bdf556dbc0345b84e93d8cad0c71b80ee8da4831e6f787085aa060db4d7cb2298f2e358410b9184aa2c9760bdbb1e5cf976ae501b8a38c3394a3539f484b1dcc571ce4f69088eedfa7122d111aaf52c08904b53d7c014ed1573c534a72d51437a9cba742999995b053c7045b1970fb592eb63db153cb6d50a60964b29c0f3b4d56dcee5688932ec5172540dd5ddd61b390bd45a0f56d05e3ef9eea446d28cb5ec9ad3b10faffdeb9b8c286099f2066701385f3e2cfecceccdc1570681d77a14e7c88a6238b0dda19fe7dc74329025fa0dba5cfab6b1a85893a4c4ab9f98f0cdd4f937d5c7d73f8e3348ef285189949ba61fb88140617371122b6f23a109f0e2a2b60d05358a581e16911a38707c14fb0d6533000653278771ef176ee23f0cde0b001080ae41513c7587fc9409c8d57b2ec8338fda58e9c751e575fa1662770d15f1e66a49f9a3307f8daa78076021dba4236e449e423ea00837cd59447c949db5298627d9b077df29d13450f7ba1199012196bce47c299a0fd3b656e8eea2adeb71c7a15d5f7baf1776c85f2f36a3ac5ff800f0c3dc0b989bb865acccbe22c5dbcb4dd2cb97b455376a39385893b9419a1f2f235ba7e2aa78349dcbf37e254744dece073fcd49ec79783405ebb6daec1d7872a81b4e2daf12d0c5915f6ccdbe2fa49d503d1c2cd3dbe8f59127d3fb9e31c0630c900140c9faa508307d775ce8d8bd59f92ed4336fe06b80018911da02dc95453bc1caa4abf690fac34bab2e0a6c7ef17ff2da89867044730f426ed53fd82b9962f617faeab84f538d5e6d014860ab00dab200cc0ed3e2c4dba8f97a2d5901796660680bb64b0ac8f19fbda34a393b1ee0b8f3d1e632c66e9d425ececa445be9ada84b57cb80d4151622702e4288503bfd5292714bb076edd9ec289c64254144bc62d31fc8fd2135f671140ed6a6af8eca280fb12e6148dbc163065a02060700704d70c2899a4d5f472111979bf66cb2aab4b89fb612f9e613ef10126397bb1a0ae85329b46090ba8953feb59d272379253622b3f5dd42bc984f324e5286fcc03da821a43dc454fb48209ba1d009f06b2ee1fcf59fc9ed783d698492e98a84d9db152e9b61df2c0310555a42377ef9daa2dec46f4e6c67403446990e4b6a415ef2424f7a1d07977116039f9b4af2441e460fc425f7cfe627ce59f15c4bd79182081b107625e33953f6858487fdf66deaed8206bf240e79fd7d03eaed08bde06aba4112889fe5493511758126bde31ff88622b503d42bbc785b57f79b7da0771acdc8ad82597e7b80920c02fa2d9b44c4708550a62e9c4f95307e060807f2928dd132948d725c1df210908c4ff9347d1e0f42364cfd078751ca0e92fa276c2faf36585f7da77f6899cc892473dc2bd5837cb004563c43155e5995b77ae844a4e7d5329133972ed2f875a87f6fe8a0ad12341f37685fdffd2332d5504366af6d9f6a497491e40a75d261f2f3a15cb256cb98ee53b0f651abe69c9fc85ad3845fded6fe74dd33f7c7888994fb67485aea0cb86574fdb048df55a19fea049852597d9c080ba69b34975b5546a6a45b2cccd322b7a3c24e34d630f8f83e7b5a177fe44ebff6e803135330e6812a196283c2d2c1c2902532b3aaf8d9b068c7894d7a3c85b478a15e690e940bc72b71327f82e1f8c63f669c60957e111be09c5fbba8b12f640038d6cd8f392ed9f0cffdea86b321afe724414fe6e6304bc76ed6c56500d48ec0f11b9f8654be65787130dd129de7428a0cb31ef2b0d810ffaccd277776ac5acd88ec837c027bee215845060077803e0d2e02c8f6213b1e7890102459676590cbe730d1057d2481bfbc08eb20d5e000263213dce1f243ad1e6dc9afa12a5315a52d3447074b26cd515b0189baa8e603e32695133f5c5bae9d9c4a7e26227790427db50e1ddef47f53d224fd7eb9a61449c404d1afe7267decaa3dc8db2cbd8ee1dae1aaa7b2fcf22eaa5995f312b6ad0fa76362a52832bbe906620fec12fee1a92bd91b9b6bdc9541b8be51515c99108998a07969785acdb22a038b36cddb3291a97871dc3d20c2dcf1f1cb938ae16d2faa36fb6609ed19c131d71580a16a04e9b62178f8835b27cee54dc109e2aa91cb53ffa615d1be916ca32e052a63742c0309705cbd02699ca6a2d1a2226875f0abb8a28f92d00aa58ab8ea5bdd3bd5ef39c33adc40e7df2efa852e514c4f66af1ca60e060a887f68041b59735d687a857cf6df7739b5ce97f2c949b945a02771d70fb146e63ce8b081c79ba7efbfec9a01a2efce732dbaf0926c5e17a3ae637cff84e409a46916e8376558ccb8be4c854f156d0ca162a6d227ef89646619f936af55238dfd547ba3b229e15ed9a5988d37ef7a0eb33bec53c478699049d51a2f59508730586e9e4476059a510e5ca9ba66e33cfc10ee8ccd67db834d68b38ec2997bf5e05f6341b8b1f63cc7fb20a65ecdcb35a4e8d6a3f425cad6d68e53cf1ee9ecec707f79eb2b3ccb97dd4c545b55d11740a14c23a8601c8e2ed8b5023c71b06ee988bbe138178f44a24ed227627628751356290dc295cc159b8e328b201b795b7c7276f3f6ed1fc64d873f7b50f8321e27cbf05f5819733c3b5c2ccc028c863afd96201cf22bcf541c23cbe191a2199a346ed521a130a82b40df20353352aebf5045fabdeef9e84b6a95fa7ff06e2c529063937b4aeefa6df1c9627fe5cb3b1201645c21079c1cdd7d48efffcd9af980ce824dfd3eb9e54fadad6f161062f3bb66188cea2d1d100a1dc5d5b4d4d21117fac6b06637f3473562ad6be6b1de5f66c58bb049bc4c53066114a2d8804d19742d4e995441e4e3c54a3b773963b4dc1e168dfe9625337f8dda8e98cd70be9b94620d229bb0c9b9b0d10c992fd3429d5f4cc498ccac4326bc449b2a9ef0c436c7caa8e06b6a9cc12b36106c335d784dfe27b454a57a469b236dcbcf3a260685fc0cba454b47e7e1d5c1d200cb63a9a52ab56c1f99a9f0d09c0ad080730ba5ce0f702ee8ea3bc8f34138443ae727cf3a3c9605a0d2730a8e7b1141f346cbb7b309523e83bd73fd800fc42526c53f423eeac7e2b508dbfe4d7041d08ff9ba7d1820a8abb747a33f4d7c8aff77d4227455667124a076c0094b262cf1fde66e53529a5ac37fa516731f62e6d193dbe1955b020e5b05e152c9421154930dcdd131d6c4d96948a2d3a4e13c4434e4ec40b0c03fd8ddbee50559afcba78c4fa0f57c89c322b4c11361a4302342bbecd9b9b822b6de02b638aca819255a3db9ec91d2fb63f40c2d1c71a6a683bec453c93355832e7a067c35469bd35056f3d74dd0cab5344077fa3dcd80fe48acd1c84db7c4a4e9bbbdda4d5270d58644e47f254de6235b8e4ac8e2b861627056e775e2bc69fea967e6810d23e4a0f2e4f1f1a2563697c8d2f5e7f18413c5b12df79acd16a467393dd83ccbad707bc3bc0dddd02fdffbecdfb3373a577b5a9e6ca17069cf37aea3586017523e891aa68815987b821088889d81d655d60f4e90cf2e150f8f169250fd00d859610f6a230be77d5a85da54d3f39cb34239e511f1485bb115292ffae8764f449113cf81262e11fde764fced2c772e8f934bdb23fe88a367e30f362b22583d7633efbbf8a70d55d70d378fcba6e92cbd36e2a050d501824ad7271fcfe490c28e03aefbfdea5f1a5f3245d72f43ad8534f4e40cbe6658d4fd6e0a81f76924307d91e5960cf10064dd46641ab0abf0c0c78ea9f3741017c4493340de647453d1bcb89802d1ab5429e5765a5778990e6451078fea4425c63a1b5d14f74ae1bd167e4859bedf27bcada850cbbabc3696a84c38cec175e623c42ce08e27cb2449ae0b1c42633aad7d98229819e85e8b15b5fd93b1206d002de395189af49245cb0341a9ed5b54750805df4ec8fbf7db2cdd201ddebce81416bf0884c03c0bc680a81bc31741acb980faabde3ea2f7e13185a6661d7634cfb3b3f2859ac4b0052f4b7771d18434c50f8752beae3feb89189a0c077e703d1312f91426bdb413f74c628c5284e68cb4e8db114131e61b37991316f33eb97e64db21da8717cadea28c7acea931d90f0c47fad26f310a25fc6ee00bc0771902358cd2bd0fa9332e7561d013df947b0c4210c0e5b760aa47a82734a21c0ffe1cede6fb10c48b39ae574456919c42919fabe8ece369ad0d0a779b7303f6e9b00d45c870364d6e1afc05adb409c7921036318c3044ca39fa4d2e7c163e347940989b45604ff02f340af90855d4ed8e3258052691bf07c2652ffea3624981f3feeb97ca4af516569a422998eaa6abeb2053864c55e9028ff96f65e7a37bc445453b2c61439f12b57a344d9cc681d8a2546701d3950afb6333299930a9bb0e65537a584139c624789e241bc1107d117ea3143fc5ad534eaed95f076e97d378d52304fab25376434be580d2b60049a08ea9f8640c8b2615b08c4aa550df0f8955e529fd0531c1f311f10640056552ab9663e0e60f9c8539cd325fa5630866d7c5c8c9afe41a95073a14158b4523ac03433e2a03ae7cac24c2eacdaf7782a36911336815d554c7161ddbb13e24ee9925146cf78d0ffc4b3d69b442f108ad493389e8346cba7d325621c0ed78590f944d0399460527390482f5aca66fe329452bc8442e4481358fbfaec8dce80f7ad32ecee4d9bd296f87373f568fc3ed66381a3c1270ad8e8d49144162522663d5904aa6333cb74276ddad4141491385bc2acac5ec7a77e105fb016ffde6e50e70fe8c9cdf68478db0e5251310b3c9deefa062c4df1bddc1a07f28574705c49688f31d5bf1f1ab2ac45721e890c767105877840311915816da5c854dda80a78bf2de8e80b3433c5936ce53d0a53c717775941f82aa58823b810a6da2f51fc7b24eb36193e0a577feeb2f2b275c666d50e7e6dd6d0c0933665d01405c5b4eff136661993bde15daecd98d967fd599671532f1be7207baebd894696ebf6cb0a2ca8dcd6b71ed17b820be06e97f7a36db54783fedbcfd52dcef7671d2a75036ffc6d4b60e9ac4f0ee24c15169e756423f5cbad55ca45717c4d06cbb5bdbff54ef896e1ba5e0c6ad94b59d1fc2b70fa1a1fcbc1eb38195b8ecfa1212e4e959e96633e9b4d3cea07db2d13de767320c4531dd9773cc84b2daed4b9bbf232e50335f78acbe3527e40a804f75d84ed6ab9b0ff87b1ab2b5062bf2cb99c19ef374db4d8b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">密码输入框</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 日志 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> QQ空间备份 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 算法基础课 chapter 2</title>
      <link href="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/"/>
      <url>/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/</url>
      
        <content type="html"><![CDATA[<h1>lecture 2 数据结构</h1><h2 id="模板">模板</h2><h3 id="单链表">单链表</h3><p><strong>数组模拟</strong> 比 <strong>动态分配</strong>链表【struct Node {}; new Node();】 快</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/wpsAFC7.tmp.jpg" alt="单链表"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表">双链表</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈">栈</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列">队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈">单调栈</h3><p>常见模型：找出每个数左边离它最近的比它大/小的数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列">单调队列</h3><p>常见模型：找出滑动窗口中的最大值/最小值</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637721398.png" alt="单调队列"></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644637738675.png" alt="单调队列"></p><p>删除，直到它严格单调。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line"><span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP">KMP</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求Next数组：</span><br><span class="line"><span class="comment">// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line"><span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line"><span class="keyword">if</span> (j == m)</span><br><span class="line">&#123;</span><br><span class="line">j = ne[j];</span><br><span class="line"><span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Trie树">Trie树</h3><p>高效地存储和查找字符串集合的数据结构。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644760589784.png" alt="Trie树"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"><span class="comment">// idx 作用同单链表。 存的是我们当前用到了哪个节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line">cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p = son[p][u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集">并查集</h3><ol><li>将两个集合合并；</li><li>询问两个元素是否在一个集合当中。</li></ol><blockquote><p>普通暴力的做法：</p><p>belong[x] = a  集合编号</p><p>if(belong[x] == belong[y])</p><p>查询是否一个集合易 O(1) ，合并则比较复杂 O(n) 。</p><p>并查集可近似 O(1) 完成上述两个操作。</p></blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644832877691.png" alt="基本原理"></p><p><strong>基本原理</strong></p><p>每个集合用一棵树来表示。树根节点的编号就是当前集合的编号。每个节点存储它的父节点，p[x] 表示 x 的父节点。</p><ul><li><p>问题1：如何判断树根</p><p>if(p[x] == x)</p></li><li><p>问题2：如何求 x 的集合编号</p><p>while(p[x] != x) x = p[x];</p></li><li><p>问题3：如何合并两个集合</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644845624459.png" alt="合并集合"></p><p>px 是 x 的集合编号，py 是 y 的集合编号。p[x] = y。</p></li></ul><blockquote><p>问题 2 的时间复杂度较高，可进行 <strong>路径压缩</strong>(如图) 或 按值合并(让高度小的树接到高度大的树) 优化。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644844526239.png" alt="路径压缩"></p></blockquote><h4 id="朴素并查集">朴素并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><h4 id="维护size的并查集">维护size的并查集</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">size[b] += size[a];</span><br></pre></td></tr></table></figure><h4 id="维护到祖宗节点距离的并查集">维护到祖宗节点距离的并查集</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p[x] != x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    d[x] += d[p[x]];</span><br><span class="line">    p[x] = u;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[I] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><h3 id="堆">堆</h3><p>手写堆，STL中形式是优先队列。</p><p><strong>形式</strong></p><p>完全二叉树；小根堆(根节点 &lt;= 左右子节点)；大根堆</p><p><strong>存储</strong></p><p>一维数组</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917137772.png" alt="存储"></p><p><strong>操作</strong></p><ul><li><p>down(x) {}  往下调   [O(logn)]</p><p>使用场景：某一个值变大了，需要下移。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917379969.png" alt="1644917379969"></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644917390859.png" alt="1644917390859"></p></li><li><p>up(x) {}  往上调</p><p>使用场景：某一个值变小了，需要上移。</p></li></ul><ol><li>插入一个数  <code>heap[++size] = x;&amp;emsp;up(size);</code></li><li>求集合当中的最小值[O(1)] <code>heap[1];</code></li><li>删除最小值 <code>heap[1] = heap[size]; size--; down(1);</code></li><li>*删除任意一个元素 <code>heap[k] = heap[size]; size--; down(k); up(k);</code></li><li>*修改任意一个元素 <code>heap[k] = x; down(k); up(k);</code></li></ol><p><strong>建堆</strong></p><p>有两种建堆的方法:</p><ol><li>一种是从一个空树开始，每次输入一个数，就按照插入操作插入这个树，时间复杂度 <strong>nlogn</strong> (一共n个元素，每个元素logn)。</li><li>还有一种建堆方法是已经把数据都输入到了数组 a[N] ，怎么根据这个数组直接建堆。就是从 n/2 开始down()，因为 n/2 是倒数第二层，如果是倒数第一层其实每个节点自然成堆了，所以从倒数第二层开始，是最简单的一个二层树结构，down 完形成一个堆。从右下角往左边开始建堆，这样从下往上之后，轮到每个节点他下面的子树肯定已经成堆了，满足 down 的条件。</li></ol><p>复杂度分析：(以完全二叉树为例)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644933510031.png" alt="O(n)建堆"></p><p>为什么是 n/4 * 1 + n/8 * 2 +… ？</p><p>根据每一层的节点树乘以需要往下down的迭代次数（其实就是往下的层树）。假设一共有n个元素的完全二叉树，那么最后一层有n/2个元素(满二叉树情况)，不需要往下down()， 倒数第二层(含)之上总共n/2个节点。i = n / 2是最后一个拥有孩子的节点，n/2以下的节点一定是一个子节点，就从非子节点开始向上建立堆。</p><p>倒数第二层有n/4个元素，每个元素最多往下down一次，倒数第三层有n/8个元素，每个元素最多往下down两次……以此类推。最终是一个等差等比混合数列的求和，为**O(n)**的复杂度。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line"><span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line"><span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> t = u;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (u != t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, t);</span><br><span class="line"><span class="built_in">down</span>(t);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h3 id="哈希表">哈希表</h3><h4 id="一般哈希-存储结构">一般哈希(存储结构)</h4><p>x ∈ (-10<sup>9</sup>,10<sup>9</sup>)，h(x) ∈ (0,10<sup>5</sup>)</p><ol><li>x mod 10<sup>5</sup>  ∈  [0,10<sup>5</sup>]</li><li>冲突问题。</li></ol><p><strong>方法</strong></p><ol><li><p>拉链法</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646051867837.png" alt="拉链法"></p><p>操作：</p><ol><li><p>添加(插入)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646060882466.png" alt="插入"></p></li><li><p>查找</p></li><li><p>删除(一般不直接删除)。使用标识符</p></li></ol><p>关于哈希表长度选取：</p><blockquote><p>比如大部分是偶数，这时候如果HASH数组容量是偶数，容易使原始数据HASH后不会均匀分布。<br>比如 2 4 6 8 10 12这6个数，如果对 6 取余 得到 2 4 0 2 4 0 只会得到3种HASH值，冲突会很多<br>如果对 7 取余 得到 2 4 6 1 3 5 得到6种HASH值，冲突较小。</p><p>同样地，如果数据都是3的倍数，而HASH数组容量是3的倍数，HASH后也容易有冲突。</p><p>用一个质数则会减少冲突的概率。</p></blockquote><p>选素数操作</p> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100000</span>;;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j*j &lt;= i;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>)    <span class="comment">//质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板代码：</p> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开放寻址法</p><p>开辟长度应为题目给出的 2~3 倍，质数。</p><p>基本思路：</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646115363520.png" alt="开放寻址法"></p><p>操作：</p><ol><li>添加</li><li>查找</li><li>删除(打标志，同上)，可将之归为查找一种</li></ol> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="comment">// 如果x在哈希表中存在，返回x的所在的位置(下标)；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="字符串哈希">字符串哈希</h4><p>字符串前缀哈希法：</p><ol><li><p>先把每一个前缀的哈希值求出来(字符串 --&gt; 数字)。</p><ol><li><p>==将字符串看成 <strong>P进制</strong> 数。==</p></li><li><p>将 P进制 的数转为十进制的数。</p><p>小技巧：</p></li></ol><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646119205933.png" alt="字符串映射"></p><p>通过这样的方式，把任何一个字符串映射到从 0 ~ Q - 1 的一个数。</p><p>注意：</p><ol><li>一般情况下不能映射成 0。否则易冲突。   e.g. A 0; AA 0。</li><li>此类哈希不考虑冲突。<ol><li>P 的经验值是131或13331，取这两个值的冲突概率低；</li><li>取模的数 Q 用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果。</li></ol></li></ol></li><li><p>利用前缀哈希算出任意子串哈希</p><ol><li><p>将 h[L - 1] 往左移若干位，与 h[R] 对齐。</p></li><li><p>从 L ~ R 段的哈希值    h[R] - h[L-1] * p<sup>(R-L+1)</sup></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646154233456.png" alt="L~R段哈希值"></p><p>此处用 unsigned long long 存储，便无需对Q(2<sup>64</sup>)取模，溢出即为取模。</p></li><li><p>关于预处理    h[i] = h[i - 1] * p + str[i]</p></li></ol></li></ol><p>当要 <strong>判断两个字符串是否相等</strong> 的时候可以使用这种方法。</p><p>模板代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能用KMP者大都可以字符串哈希实现，<a href="https://www.acwing.com/problem/content/description/4063/">4060. 字符串循环节 - AcWing题库</a> 例外。</p><h3 id="STL简介">STL简介</h3><h4 id="vector">vector</h4><p>变长数组，倍增思想。</p><p>系统为某一程序分配空间时，所需时间与空间大小无关，与申请次数有关。故应减少倍增次数。</p><ol><li>size()   返回元素个数(所有容器都有)</li><li>empty()   返回是否为空(所有容器都有)</li><li>clear()  清空</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>begin()/end()   (end() 最后一个数的下一个位置)</li><li>[]</li><li>支持比较运算，按字典序(首字母)</li></ol><h4 id="pair-int-int">pair&lt;int, int&gt;</h4><p>存储二元组</p><ol><li><p>first, 第一个元素</p></li><li><p>second, 第二个元素</p></li><li><p>支持<strong>比较</strong>运算，以 <strong>first</strong> 为第一关键字，以 <strong>second</strong> 为第二关键字（字典序）</p></li><li><p>赋值</p><p>p = make_pair(10,“abc”);</p><p>p = {20,“abc”};</p></li><li><p>可以嵌套</p></li></ol><h4 id="string">string</h4><p>字符串</p><ol><li>szie()/length()  返回字符串长度</li><li>empty()</li><li>clear()</li><li>substr(起始下标(从零开始)，(子串长度))  返回子串</li><li>c_str()  返回字符串所在字符数组的起始地址(头指针)</li></ol><h4 id="queue">queue</h4><p>队列</p><ol><li>size()</li><li>empty()</li><li>push()  向队尾插入一个元素</li><li>front()  返回队头元素</li><li>back()  返回队尾元素</li><li>pop()  弹出队头元素</li><li><strong>没有</strong>clear</li></ol><h4 id="priority-queue">priority_queue</h4><p>优先队列，默认是大根堆</p><ol><li><p>push()  插入一个元素</p></li><li><p>top()  返回堆顶元素</p></li><li><p>pop()  弹出堆顶元素</p></li><li><p>定义成 <strong>小根堆</strong> 的方式：</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;</code></p><p>表示优先队列后面的元素都要大于优先队列前面的元素</p></li><li><p><strong>没有</strong>clear</p></li></ol><h4 id="stack">stack</h4><p>栈</p><ol><li>size()</li><li>empty()</li><li>push()  向栈顶插入一个元素</li><li>top()  返回栈顶元素</li><li>pop()  弹出栈顶元素</li><li><strong>没有</strong>clear</li></ol><h4 id="deque">deque</h4><p>(加强版vector) 双端队列。效率相对低</p><ol><li>size()</li><li>empty()</li><li>clear()</li><li>front()/back()</li><li>push_back()/pop_back()</li><li>push_front()/pop_front()</li><li>begin()/end()</li><li>[]</li></ol><h4 id="set-map-multiset-multimap">set, map, multiset, multimap</h4><p>基于平衡二叉树（红黑树），动态维护有序序列</p><ul><li>size()</li><li>empty()</li><li>clear()</li><li>begin()/end()</li><li>++, – 返回前驱和后继，时间复杂度 O(logn)</li></ul><p>multi- ：支持重复元素</p><ol><li><p>set/multiset</p><p>insert()  插入一个数<br>find()  查找一个数  (不存在返回end迭代器)<br>count()  返回某一个数的个数<br>erase()</p><ol><li>输入是一个数x，删除所有x   O(k + logn)     （k为个数)</li><li>输入一个迭代器，删除这个迭代器</li></ol><p><strong>==lower_bound()/upper_bound()==</strong></p><ol><li><p>lower_bound(x)  返回<strong>大于等于</strong>x的最小的数的迭代器</p></li><li><p>upper_bound(x)  返回<strong>大于</strong>x的最小的数的迭代器</p></li><li><p>lower_bound( begin,end,num,greater<type>() ):</type></p><p>二分查找第一个小于或等于num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。</p><p>upper_bound( begin,end,num,greater<type>() ):</type></p><p>查找第一个小于num的数字</p></li></ol></li><li><p>map/multimap</p><ol><li>insert()  插入的数是一个pair</li><li>erase()  输入的参数是pair或者迭代器</li><li>find()</li><li>[]   时间复杂度是 O(logn)      （数组是O(1))</li><li>lower_bound()/upper_bound()</li></ol></li></ol><h4 id="unordered-set-unordered-map-unordered-multiset-unordered-multimap">unordered_set, unordered_map, unordered_multiset, unordered_multimap</h4><p>哈希表</p><p>和上面类似，增删改查的时间复杂度是 O(1)。</p><p>不支持 lower_bound()/upper_bound()，迭代器的++，–</p><h4 id="bitset">bitset</h4><p>圧位</p><p>使用情况：bool 存储一个字节，使用压位。能够节省8倍空间。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bitset&lt;10000&gt; s;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">&gt;&gt;, &lt;&lt;</span><br><span class="line">==, !=</span><br><span class="line">[]</span><br><span class="line"><span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"><span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line"><span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"><span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line"><span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line"><span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line"><span class="built_in">flip</span>()  等价于~(所有位取反)</span><br><span class="line"><span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h2 id="题目">题目</h2><h3 id="单链表-v2">单链表</h3><h4 id="AcWing-826-单链表">AcWing 826. <a href="https://www.acwing.com/problem/content/828/">单链表</a></h4><p>实现一个单链表，链表初始为空，支持三种操作：</p><ol><li><p>向链表头插入一个数；</p></li><li><p>删除第 k 个插入的数后面的数；</p></li><li><p>在第 k 个插入的数后插入一个数。</p></li></ol><p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p><p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = head, head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插到下标为k点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x, ne[idx] = ne[k], ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k点的后一个点删除</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;            </span><br><span class="line">            <span class="keyword">if</span>(!k)  head = ne[head];        <span class="comment">//k为0的情况,删除头结点</span></span><br><span class="line">            <span class="built_in">remove</span>(k<span class="number">-1</span>);        <span class="comment">//第k个插入数字 下标对应k-1//如果初始化head = 0,idx = 1,则不用k-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(x,k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head;i != <span class="number">-1</span>;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;        <span class="comment">//当前值：e[i]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表-v2">双链表</h3><h4 id="AcWing-827-双链表">AcWing 827. <a href="https://www.acwing.com/problem/content/829/">双链表</a></h4><p><strong>输入格式</strong></p><p>第一行包含整数 M，表示操作次数。</p><p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p><ol><li><code>L x</code>，表示在链表的最左端插入数 x。</li><li><code>R x</code>，表示在链表的最右端插入数 x。</li><li><code>D k</code>，表示将第 k 个插入的数删除。</li><li><code>IL k x</code>，表示在第 k 个插入的数左侧插入一个数。</li><li><code>IR k x</code>，表示在第 k 个插入的数右侧插入一个数。</li></ol><p><strong>输出格式</strong></p><p>共一行，将整个链表从左到右输出。</p><p><strong>解析</strong></p><p>实际为<strong>两个</strong>操作。add,remove [ add(k,x),add(left,x),add(right,x) ]</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> e[N],r[N],l[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>,idx = <span class="number">2</span>;      <span class="comment">//下标的模拟习惯为0与1做首末</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span>   <span class="comment">//节点k右边插入一个数   注意先后顺序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = k,r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx,r[k] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span>      <span class="comment">//删除节点k</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;L&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;R&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IL&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(l[k+<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;IR&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k+<span class="number">1</span>,x);<span class="comment">//第 k 个插入的数, 对应 k+1 下标</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>];i != <span class="number">1</span>;i = r[i])   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,e[i]);     <span class="comment">//其实点为原首节点右一位，末节点为原末节点左一位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈-v2">栈</h3><h4 id="AcWing-828-模拟栈">AcWing 828. <a href="https://www.acwing.com/problem/content/830/">模拟栈</a></h4><p>实现一个栈，栈初始为空，支持四种操作：</p><ol><li>push x – 向栈顶插入一个数 x；</li><li>pop – 从栈顶弹出一个数；</li><li>empty – 判断栈是否为空；</li><li>query – 查询栈顶元素。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 5</span><br><span class="line">query</span><br><span class="line">push 6</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 4</span><br><span class="line">query</span><br><span class="line">empty</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">YES</span><br><span class="line">4</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stk[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tt--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tt == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; stk[tt] &lt;&lt; endl;            <span class="comment">//插入时为 stk[++tt] = x ，直接输出 stk[tt];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-3302-表达式求值">AcWing 3302. <a href="https://www.acwing.com/problem/content/3305/">表达式求值</a></h4><p>给定一个表达式，其中运算符仅包含 +,-,*,/（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(2+2)*(1+1)</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><strong>中间节点</strong>都是运算符，<strong>叶节点</strong>都是数字。<br><strong>中缀</strong>表达       <strong>后缀</strong>表达<br><img src="https://cdn.acwing.com/media/article/image/2021/11/21/95860_a66013284a-112101.png" alt="表达式.png"></p><img src="https://s2.loli.net/2022/02/07/hERxkJM9DwtKjOX.jpg" style="zoom:30%"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt;num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt;op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> b = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();                 <span class="comment">//注意a,b顺序</span></span><br><span class="line">    <span class="keyword">auto</span> a = num.<span class="built_in">top</span>() ; num.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> c = op.<span class="built_in">top</span>() ; op.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>)    x = a+b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>)   x = a-b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>)   x = a*b;</span><br><span class="line">    <span class="keyword">else</span> x = a/b;</span><br><span class="line">    num.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> c = str[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c))                                  <span class="comment">//数字</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>,j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                x = x*<span class="number">10</span> + str[j++] - <span class="string">&#x27;0&#x27;</span>;              <span class="comment">//注意要 - &#x27;0&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)                                  </span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)  <span class="built_in">eval</span>();</span><br><span class="line">            op.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                            <span class="comment">//符号情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[c])    <span class="built_in">eval</span>();     <span class="comment">//如果当前符号优先级高于栈顶，则入栈</span></span><br><span class="line">            op.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!op.<span class="built_in">empty</span>())  <span class="built_in">eval</span>();</span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列-v2">队列</h3><h4 id="AcWing-829-模拟队列">AcWing 829. <a href="https://www.acwing.com/problem/content/831/">模拟队列</a></h4><p>实现一个队列，队列初始为空，支持四种操作：</p><ol><li>push x – 向队尾插入一个数 x；</li><li>pop – 从队头弹出一个数；</li><li>empty – 判断队列是否为空；</li><li>query – 查询队头元素。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">push 6</span><br><span class="line">empty</span><br><span class="line">query</span><br><span class="line">pop</span><br><span class="line">empty</span><br><span class="line">push 3</span><br><span class="line">push 4</span><br><span class="line">pop</span><br><span class="line">query</span><br><span class="line">push 6</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">6</span><br><span class="line">YES</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> que[N],hh,tt = <span class="number">-1</span>;<span class="comment">//hh = 0，tt = -1 更方便操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    que[++tt] = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hh++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hh &lt;= tt)    cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; que[hh] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>)</span><br><span class="line">            <span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)</span><br><span class="line">            <span class="built_in">empty</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>)</span><br><span class="line">            <span class="built_in">query</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈-v2">单调栈</h3><h4 id="AcWing-830-单调栈">AcWing 830. <a href="https://www.acwing.com/problem/content/832/">单调栈</a></h4><p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>每一个元素只进栈一次，每一个元素最多只会出栈一次。总操作2n，复杂度为<strong>O(n)</strong>。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,skt[N],tt;   <span class="comment">//全局变量会自动初始化为0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//https://blog.csdn.net/king9666/article/details/103949090</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; skt[tt] &gt;= x)  tt--;    <span class="comment">//while     没 = 则错误</span></span><br><span class="line">        <span class="keyword">if</span>(tt)  cout &lt;&lt; skt[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>    cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        skt[++tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度：</p><p>内层循环每循环一次，tt-1；外层循环每循环一次，tt+1。</p><p>最多 +n 次，最多 -n 次。</p><p>整个时间复杂度是O(n)。</p><p>单调栈应用 —— <strong>Acwing 131. <a href="https://www.acwing.com/problem/content/133/">直方图中最大的矩形</a></strong></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/19_eac6c46017-2559_1.jpg" alt="直方图"></p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7 2 1 4 5 1 3 3</span><br><span class="line">4 1000 1000 1000 1000</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4000</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">int</span> l[N],r[N],h[N],q[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n) , n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line"></span><br><span class="line">        q[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)       <span class="comment">//第i个矩形的高度可向两侧扩展的左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            l[i] = i - q[tt];</span><br><span class="line">            q[++tt] = i;                <span class="comment">//q[tt]作为栈顶元素下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tt = <span class="number">0</span>,q[<span class="number">0</span>] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n;i &gt;= <span class="number">0</span>;--i)       <span class="comment">//第i个矩形的高度可向两侧扩展的右边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tt &amp;&amp; h[q[tt]] &gt;= h[i])   tt--;</span><br><span class="line">            r[i] = q[tt] - i;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LL res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)  res = <span class="built_in">max</span>(res, (LL)h[i] * (l[i] + r[i] - <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644674377127.png" alt="模拟过程"></p><h3 id="单调队列-v2">单调队列</h3><h4 id="AcWing-154-滑动窗口">AcWing 154. <a href="https://www.acwing.com/problem/content/156/">滑动窗口</a></h4><p>给定一个大小为 n≤106 的数组。有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。你只能在窗口中看到 k 个数字。每次滑动窗口向右移动一个位置。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3//两个整数 n 和 k，分别代表数组长度和滑动窗口的长度</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3//从左至右，每个位置滑动窗口中的最小值。</span><br><span class="line">3 3 5 5 6 7//从左至右，每个位置滑动窗口中的最大值。</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;   <span class="comment">//视情况，或while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;<span class="comment">//注意是q[tt]而不是q[hh]</span></span><br><span class="line">        q[++tt] = i;                            <span class="comment">//当前可能为最小值，故应在输出前插入</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);<span class="comment">//注意等于号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[N],q[N];      </span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;     <span class="comment">//hh队列头 tt队列尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="comment">//维持滑动窗口的大小  判断队头是否已经划出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;           <span class="comment">//while亦可，但此题只有一次。不确定可使用while</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt--;       <span class="comment">//单调队列</span></span><br><span class="line">        <span class="comment">//当队列不为空(hh &lt;= tt) 且 当队列队尾元素&gt;=当前元素时,那么队尾元素一定不是当前窗口最小值,删去队尾元素,加入当前元素</span></span><br><span class="line">        q[++tt] = i;            <span class="comment">//q[i]保存的是下标</span></span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);     <span class="comment">//个数&gt;=k时才输出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i-q[hh]+<span class="number">1</span> &gt; k)   hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt--;       <span class="comment">//大----&gt;小</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span> &gt;= k)    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[hh]]);<span class="comment">//队头就是最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP-v2">KMP</h3><h4 id="AcWing-831-KMP字符串">AcWing 831. <a href="https://www.acwing.com/problem/content/833/">KMP字符串</a></h4><p>给定一个模式串 S，以及一个模板串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。模板串 P 在模式串 S 中多次作为子串出现。求出模板串 P 在模式串 S 中所有出现的位置的起始下标。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">aba</span><br><span class="line">5</span><br><span class="line">ababa</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">1000010</span>;</span><br><span class="line"><span class="comment">// int p[N],s[M];</span></span><br><span class="line"><span class="type">char</span> p[N],s[M];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p+<span class="number">1</span> &gt;&gt; m &gt;&gt; s+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n);</span><br><span class="line">            j = ne[j];                  <span class="comment">//重新开始匹配时，可以把j最多移动多少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下标从0开始</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    ne[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//求next</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">-1</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//KMP匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">-1</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j != <span class="number">-1</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>])  j = ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>])  j++;</span><br><span class="line">        <span class="keyword">if</span>(j == n - <span class="number">1</span>)<span class="comment">//全往前挪了一位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i-n + <span class="number">1</span>);</span><br><span class="line">            j = ne[j];                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>j = ne[j];————重新开始匹配时，可以把j最多移动多少<br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_9b4e5e4a48-111804.png" alt="KMP"><br><img src="https://cdn.acwing.com/media/article/image/2021/11/18/95860_86296c8048-111802.png" alt="KMP"></p><p>时间复杂度是O(n)。以第二个循环的j为例。j最多加m次,最多减m次.O(2m)-----&gt;O(m)。</p><p>上述方法所得下标：</p><table><thead><tr><th style="text-align:left">字符串</th><th style="text-align:left">    a  b  a</th><th style="text-align:left">    a  b  a  b  a</th></tr></thead><tbody><tr><td style="text-align:left">下标</td><td style="text-align:left">0  1  2  3</td><td style="text-align:left">0  1  2  3  4  5</td></tr><tr><td style="text-align:left">next[]</td><td style="text-align:left">0  0  1</td><td style="text-align:left">0  0  1  2  3</td></tr></tbody></table><hr><p><strong>法二</strong></p><p>严版KMP字符串匹配算法 <a href="https://www.bilibili.com/video/BV16X4y137qw?from=search&amp;seid=16643420370716168727&amp;spm_id_from=333.337.0.0">求next数组</a>（单次匹配）<br><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/95860_5b7ce5f648-111801.png" alt="KMP"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_next</span><span class="params">(String T,<span class="type">int</span> next[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || T.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(String S,String T,<span class="type">int</span> next[],<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.<span class="built_in">size</span>() &amp;&amp; j &lt;= T.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;++j;            <span class="comment">//继续比较后继字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = next[j];        <span class="comment">//模式串向右移动</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> i-T.<span class="built_in">size</span>();  <span class="comment">//匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法对应next数组</p><table><thead><tr><th>字符串</th><th>a  b  a  a  b  c  a  c</th></tr></thead><tbody><tr><td>下标</td><td>1  2  3  4  5  6  7  8</td></tr><tr><td>next[]</td><td>0  1  1  2  2  3  1  2</td></tr></tbody></table><p>推荐 <strong>法一</strong> 。</p><h3 id="Trie">Trie</h3><h4 id="AcWing-835-Trie字符串统计">AcWing 835. <a href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></h4><p>维护一个字符串集合，支持两种操作：</p><ol><li>I x 向集合中插入一个字符串 x；</li><li>Q x 询问一个字符串在集合中出现了多少次。</li></ol><p>共有 N 个操作，输入的字符串总长度不超过 105，字符串仅包含小写英文字母。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I abc</span><br><span class="line">Q abc</span><br><span class="line">Q ab</span><br><span class="line">I ab</span><br><span class="line">Q ab</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx;  <span class="comment">//下标是0的点，既是根节点，也是空节点</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>],str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)    <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-143-最大异或对">AcWing 143. <a href="https://www.acwing.com/problem/content/145/">最大异或对</a></h4><p>在给定的 N 个整数 A1，A2……AN 中选出两个进行 xor（异或）运算，得到的结果最大是多少？</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p>暴力 O(n) * n</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)<span class="comment">//枚举第一个数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; i;++j)<span class="comment">//枚举第二个数</span></span><br><span class="line">    res = <span class="built_in">max</span>(res,a[i] ^ a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Trie树  O(31) * n(十万) ≈ nlogn</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645087093192.png" alt="保存与筛选"></p><p>思路：从前往后枚举，先 <strong>插入</strong> 再 <strong>查询</strong> (也可先查询再插入，但开始空要加判断)。</p><p>​查询：查询 ai 前面和 ai 异或最大的值。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645103981023.png" alt="思路"></p></li></ol><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">31</span> * N;</span><br><span class="line"><span class="type">int</span> n,a[N],son[M][<span class="number">2</span>],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])             </span><br><span class="line">            son[p][u] = ++idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">        <span class="comment">/* 循环之内的内容也可以写为</span></span><br><span class="line"><span class="comment">        int &amp;s = son[p][x &gt;&gt; i &amp; 1];</span></span><br><span class="line"><span class="comment">        if (!s) s = ++ idx;</span></span><br><span class="line"><span class="comment">        p = s;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">            res = res * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">            res = res * <span class="number">2</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!u])  </span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = son[p][u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    </span><br><span class="line">        res = <span class="built_in">max</span>(res,<span class="built_in">search2</span>(a[i]));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集-v2">并查集</h3><h4 id="AcWing-836-合并集合">AcWing 836. <a href="https://www.acwing.com/problem/content/838/">合并集合</a></h4><p>一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。</p><p>现在要进行 m 个操作，操作共有两种：</p><ol><li>M a b，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；</li><li>Q a b，询问编号为 a 和 b 的两个数是否在同一个集合中。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">M 1 2</span><br><span class="line">M 3 4</span><br><span class="line">Q 1 2</span><br><span class="line">Q 1 3</span><br><span class="line">Q 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">//返回 x 的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;a, &amp;b);<span class="comment">//同时输入字符串和数字的最合适方法</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>)    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;Q&#x27;</span>)  <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911891583.png" alt="优化过程"></p><p>find() 函数 <code>p[x] = find(p[x])</code> 在回溯过程中路径压缩优化</p></blockquote><h4 id="AcWing-837-连通块中点的数量">AcWing 837. <a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></h4><p>给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。</p><p>现在要进行 m 个操作，操作共有三种：</p><ol><li>C a b，在点 a 和点 b 之间连一条边，a 和 b 可能相等；</li><li>Q1 a b，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；</li><li>Q2 a，询问点 a 所在连通块中点的数量。</li></ol><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">C 1 2</span><br><span class="line">Q1 1 2</span><br><span class="line">Q2 1</span><br><span class="line">C 2 5</span><br><span class="line">Q2 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><blockquote><p>同一个连通块之意：从 a 可以走到 b ，从 b 可以走到 a。</p></blockquote><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1644911365103.png" alt="所给样例"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)   p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b))  <span class="keyword">continue</span>;</span><br><span class="line">            cnt[<span class="built_in">find</span>(b)] += cnt[<span class="built_in">find</span>(a)];</span><br><span class="line">            p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="comment">//若不使用下面的 a = find(a), b = find(b); 上面两个语句次序不能兑换。否则 p[find(a)] 改变值会影响到 cnt[find(a)] 的值。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// cin &gt;&gt; a &gt;&gt; b;</span></span><br><span class="line">            <span class="comment">// a = find(a), b = find(b);</span></span><br><span class="line">            <span class="comment">// if (a != b)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     p[a] = b;</span></span><br><span class="line">            <span class="comment">//     cnt[b] += cnt[a];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="built_in">find</span>(a) == <span class="built_in">find</span>(b) ? <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[<span class="built_in">find</span>(a)]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-240-食物链">AcWing 240. <a href="https://www.acwing.com/problem/content/242/">食物链</a></h4><p>动物王国中有三类动物 A,B,C，这三类动物的食物链构成了有趣的环形。A 吃 B，B 吃 C，C 吃 A。</p><p>有人用两种说法对这 N 个动物所构成的食物链关系进行描述：</p><p>第一种说法是 <code>1 X Y</code>，表示 X 和 Y 是同类。</p><p>第二种说法是 <code>2 X Y</code>，表示 X 吃 Y。</p><p>此人对 N 个动物，用上述两种说法，一句接一句地说出 K 句话，这 K 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。</p><ol><li>当前的话与前面的某些真的话冲突，就是假话；</li><li>当前的话中 X 或 Y 比 N 大，就是假话；</li><li>当前的话表示 X 吃 X，就是假话。</li></ol><p>你的任务是根据给定的 N 和 K 句话，输出假话的总数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100 7</span><br><span class="line">1 101 1 </span><br><span class="line">2 1 2</span><br><span class="line">2 2 3 </span><br><span class="line">2 3 3 </span><br><span class="line">1 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">1 5 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>样例图示</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645199664162.png" alt="样例图示"></p><p><strong>思路</strong>：</p><p>并查集中，维护每个点到根节点的 <strong>距离</strong> 。将距离分为三大类：</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250329339.png" alt="三类距离"></p><ol><li>何为距离，即是 <code>关于代的关系</code> ，对 <strong>3</strong> 取模以示之。</li></ol><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250388289.png" alt="关于代的关系"></p><ol start="2"><li><p>每个点到父节点距离如何维护？</p><p>存的时候存其对父节点距离。在做 <strong>路径压缩</strong> 时，将每个点到 <strong>父节点</strong> 的距离更新成对 <strong>根节点</strong> 的距离。</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645250849185.png" alt="距离维护"></p></li><li><p>只需要知道每个点与根的关系，即可判断两个点之间的关系。</p></li><li><p>关于find</p></li><li><p>存下父节点的根节点；</p><p>再加上父节点到其根节点的距离(把d[x]更新成到根节点的距离)；</p><p>把当前节点的根节点指向最终根节点。</p><p><strong>d[i]：第 i 个节点到其父节点距离</strong> <a href="https://www.acwing.com/solution/content/15938/">ref：find()函数调用过程</a></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/41774_bd485030c0-JIE.jpg" alt="find函数"></p></li></ol><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> p[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t,x,y;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; x &gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n)  res++;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> px = <span class="built_in">find</span>(x),py = <span class="built_in">find</span>(y);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x]-d[y]) % <span class="number">3</span> )  res++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span> )    res ++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(px != py)</span><br><span class="line">                &#123;</span><br><span class="line">                    p[px] = py;</span><br><span class="line">                    d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆-v2">堆</h3><h4 id="AcWing-838-堆排序">AcWing 838. <a href="https://www.acwing.com/problem/content/840/">堆排序</a></h4><p>输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 5 1 3 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,a[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>] &lt; a[t]) t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; a[u*<span class="number">2</span>+<span class="number">1</span>] &lt; a[t]) t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u],a[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; a[u/<span class="number">2</span>] &gt; a[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(a[u/<span class="number">2</span>],a[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i ;--i)    <span class="built_in">down</span>(i);</span><br><span class="line">    <span class="comment">//for(int i = 1; i &lt;= n ;++i)    up(i);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[<span class="number">1</span>]);</span><br><span class="line">        a[<span class="number">1</span>] = a[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-839-模拟堆">AcWing 839. <a href="https://www.acwing.com/problem/content/841/">模拟堆</a></h4><p>维护一个集合，初始时集合为空，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 x；</li><li><code>PM</code>，输出当前集合中的最小值；</li><li><code>DM</code>，删除当前集合中的最小值（数据保证此时的最小值唯一）；</li><li><code>D k</code>，删除第 k 个插入的数；</li><li><code>C k x</code>，修改第 k 个插入的数，将其变为 x；</li></ol><p>现在要进行 N 次操作，对于所有第 2 个操作，输出当前集合的最小值。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">I -10</span><br><span class="line">PM</span><br><span class="line">I -10</span><br><span class="line">D 1</span><br><span class="line">C 2 8</span><br><span class="line">I 6</span><br><span class="line">PM</span><br><span class="line">DM</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-10</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><p>难点</p><p>从第 k 个插入点找到对应元素，又要从堆里的元素找回来。</p><p>ph[k] 与 hp[j] ：<code>第 k 个插入点的对应下标</code> 与 <code>堆中下标为j的点对应的k</code>。(两者如反函数关系)</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1645004854237.png" alt="交换第k个插入数"></p><p>[如何理解模拟堆中的heap_swap，hp<a href="https://www.acwing.com/solution/content/5661/">N], ph[N]？ - AcWing</a></p><ol><li><p>idx</p><p><code>h[k] = x</code>, h数组存的是节点的值，按理来说应该<code>h[idx]</code>来存，但是节点<strong>位置</strong>总是在变的，因此需维护k和idx的映射关系。</p><p>用<code>ph数组</code>来表示<code>ph[idx] = k</code>(idx到下标), 那么结点值为<code>h[ph[idx]]</code>, 儿子为<code>ph[idx] * 2</code>和<code>ph[idx] * 2 + 1</code>, 这样值和儿子结点通过idx联系在一起。</p></li><li><p>hp与ph数组</p><ol><li><p><strong>ph数组</strong> 主要用于帮助从idx映射到下标k；</p></li><li><p>在<code>swap</code>操作中我们输入是堆数组的下标，需要hp数组方便查找idx。即：</p><p><strong>hp数组</strong> 查找每个<strong>堆数组的k下标</strong> 对应idx（第idx个<strong>插入</strong>）</p></li></ol></li><li><p>操作实例</p><p>交换函数</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); </span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    size ++ ;</span><br><span class="line">    idx ++ ; <span class="comment">//记录第几次插入（设置新的idx）</span></span><br><span class="line">    ph[idx] = size, hp[size] = idx;<span class="comment">//每次插入都是在堆尾插入（设置ph与hp）</span></span><br><span class="line">    h[ph[idx]] = x; <span class="comment">//记录插入的值 </span></span><br><span class="line">    <span class="built_in">up</span>(ph[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除</p><ol><li>找到第idx个插入元素在堆数组中的位置（堆数组下标）</li><li>与堆尾元素交换</li><li>在原来第idx个元素所在的位置进行down和up操作。（up，down，swap操作的都输入都是<strong>下标</strong>）</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;D&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;idx);</span><br><span class="line">    k = ph[idx]; <span class="comment">//必须要保存当前被删除结点的下标</span></span><br><span class="line">    <span class="built_in">heap_swap</span>(k, size);<span class="comment">//第idx个插入的元素移到了堆尾，此时ph[idx]指向堆尾 </span></span><br><span class="line">    size --;  <span class="comment">//删除堆尾</span></span><br><span class="line">    <span class="built_in">up</span>(k);<span class="comment">//k是之前记录被删除的结点的下标</span></span><br><span class="line">    <span class="built_in">down</span>(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>整体代码</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>] &lt; h[t])   t = u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(u*<span class="number">2</span>+<span class="number">1</span> &lt;= cnt &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>] &lt; h[t])   t = u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u != t)  </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>] &gt; h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> x,k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;</span><br><span class="line">            ph[m] = cnt,hp[cnt] = m;</span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// scanf(&quot;%d&quot;, &amp;k);</span></span><br><span class="line">            <span class="comment">// heap_swap(ph[k],idx);</span></span><br><span class="line">            <span class="comment">// idx --;</span></span><br><span class="line">            <span class="comment">// down(ph[k]),up(ph[k]);//0223这么做错误,k已经改变</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];              <span class="comment">//0216遗漏</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);<span class="comment">//这两个函数有且只有一个执行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op, <span class="string">&quot;C&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哈希表-v2">哈希表</h3><h4 id="AcWing-840-模拟散列表">AcWing 840. <a href="https://www.acwing.com/problem/content/842/">模拟散列表</a></h4><p>维护一个集合，支持如下几种操作：</p><ol><li><code>I x</code>，插入一个数 x；</li><li>Q x，询问数 x 是否在集合中出现过；</li></ol><p>现在要进行 N 次操作，对于每个询问操作输出对应的结果。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">I 1</span><br><span class="line">I 2</span><br><span class="line">I 3</span><br><span class="line">Q 2</span><br><span class="line">Q 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ol><li><p>拉链法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;<span class="comment">//此处 e 和 ne 同单链表是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N ) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[k];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    <span class="comment">//h[k]存的链表第一个节点下标，e[i]为当前点的值；做完操作后，ne[i]为下一个点的下标。空指针的下标为 -1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>开放寻址法</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>;</span><br><span class="line"><span class="type">int</span> h[N],null = <span class="number">0x3f3f3f3f</span>;<span class="comment">//null 不在 x 范围内的数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>(k == N)  k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);<span class="comment">//memset函数按字节，h为int，四个字节，每个皆是0x3f(8位)</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">            h[k] = x;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[k] != null)  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="AcWing-841-字符串哈希">AcWing 841. <a href="https://www.acwing.com/problem/content/843/">字符串哈希</a></h4><p>给定一个长度为 n 的字符串，再给定 m 个询问，每个询问包含四个整数 l1,r1,l2,r2，请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。字符串中只包含大小写英文字母和数字。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">aabbaabb</span><br><span class="line">1 3 5 7</span><br><span class="line">1 3 6 8</span><br><span class="line">1 2 1 2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>p 数组的意义，便是用来存储 p 的次方。因为公式内有 p 的次方，故先将 p 预处理出来。</p><p>h 数组：某一个前缀的哈希值。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,P = <span class="number">131</span>;</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>] * p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    cin &gt;&gt; str + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>] * P;</span><br><span class="line">        h[i] = h[i<span class="number">-1</span>] * P + str[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2))    <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用：<a href="https://www.acwing.com/problem/content/141/">139. 回文子串的最大长度 - AcWing题库</a></p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">abcbabcbabcba</span><br><span class="line">abacacbaaaab</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Case 1: 13</span><br><span class="line">Case 2: 6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646209987825.png" alt="回文子串的最大长度"></p><p>前期步骤同上，而后</p><ul><li>长度是奇数</li></ul><ol><li><p>枚举中点；</p></li><li><p>二分半径。</p><p>每次二分一个长度，判断左右两边的哈希值是否一样。若同，扩长度；否，缩。</p></li></ol><ul><li><p>长度是偶数</p><pre><code>  在每一个字母之间插入符号 ，将其化为奇数。</code></pre></li></ul><p>下标的计算</p><p><img src="/2022/03/03/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter2/1646213451004.png" alt="逆序下标转换"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hl 正序字符串所有前缀的哈希值；hr 逆序字符串所有前缀的哈希值。</span></span><br><span class="line"><span class="comment">//逗号表达式返回值为最后一式的值。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2000010</span>,P = <span class="number">131</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL hl[N],hr[N],p[N];</span><br><span class="line"><span class="type">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(ULL h[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s+<span class="number">1</span> , <span class="built_in">strcmp</span>(s+<span class="number">1</span>,<span class="string">&quot;END&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);                    </span><br><span class="line">        <span class="comment">//size_t strlen(const char *str)</span></span><br><span class="line">        <span class="comment">//从str开始到第一个&#x27;\0&#x27;为止的字符串的长度，长度不包括&#x27;\0&#x27;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n*<span class="number">2</span>;i &gt; <span class="number">0</span>;i -= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i] = s[i/<span class="number">2</span>];</span><br><span class="line">            s[i<span class="number">-1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">        <span class="comment">//a b c b a</span></span><br><span class="line">        <span class="comment">//# a # b # c # b # a</span></span><br><span class="line"></span><br><span class="line">        p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = n;i &lt;= n,j &gt; <span class="number">0</span>;++i,--j)</span><br><span class="line">        &#123;</span><br><span class="line">            hl[i] = hl[i<span class="number">-1</span>]*P + s[i];</span><br><span class="line">            hr[i] = hr[i<span class="number">-1</span>]*P + s[j];</span><br><span class="line">            p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求以s[i]为对称中心的回文串的最大半径。 二分回文串的半径</span></span><br><span class="line">        <span class="comment">//mid为回文串半径[...]S[i][...]  --&gt;  [长度mid][长度1][长度mid]  --&gt;  s[i-mid]...s[i-1] s[i] s[i+1]...s[i+mid]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;++i)           <span class="comment">//扩容后的字符串起始下标应为 2</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(i<span class="number">-2</span>,n-i);</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;                               <span class="comment">//注意 + 1</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">get</span>(hl,i-mid,i<span class="number">-1</span>) == <span class="built_in">get</span>(hr,n-(i+mid)+<span class="number">1</span>,n-(i+<span class="number">1</span>)+<span class="number">1</span>)) l = mid;     <span class="comment">//回文串半径可以变大</span></span><br><span class="line">                <span class="keyword">else</span>    r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//s[i-l]...s[i-1] s[i] s[i+1]...s[i+l]</span></span><br><span class="line">            <span class="comment">//回文串总长度2*l+1=l+1+l</span></span><br><span class="line">            <span class="keyword">if</span>(s[i-l] == <span class="string">&#x27;#&#x27;</span>)   res = <span class="built_in">max</span>(res,l);   <span class="comment">//回文串两边为&#x27;#&#x27;，即字母比&#x27;#&#x27;少一个</span></span><br><span class="line">            <span class="keyword">else</span>    res = <span class="built_in">max</span>(res,l+<span class="number">1</span>);             <span class="comment">//回文串两边为字母，即字母比&#x27;#&#x27;多一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,t++,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>chapter 2 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/03/hello-world/"/>
      <url>/2021/12/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bulid my blog by Hexo</title>
      <link href="/2021/12/03/Make%20Hexo%20Blog/"/>
      <url>/2021/12/03/Make%20Hexo%20Blog/</url>
      
        <content type="html"><![CDATA[<h3 id="Hexo-Github">Hexo &amp; Github</h3><h4 id="Download">Download</h4><ol><li><a href="https://git-scm.com/">git</a></li><li><a href="https://nodejs.org/">nodejs</a></li></ol><h4 id="Step">Step</h4><ol><li><p><code>node -v</code>查看node版本</p><p><code>npm -v</code>查看npm版本</p><p><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code><strong>安装</strong>cnpm 管理器<strong>镜像</strong>源</p><p><code>cnpm -v</code>查看cnpm版本</p></li><li><p><code>cnpm install -g hexo-cli</code>    <strong>安装hexo</strong>框架</p><p><code>hexo -v</code>查看hexo版本</p><p><code>mkdir blog</code><strong>创建</strong>blog目录</p><p><code>cd blog</code> <strong>进入</strong>blog目录</p><p>(<code>npm install</code>进一步安装<strong>hexo</strong>所需文件  )</p></li><li><p><code>sudo hexo init (+文件夹名)</code>   生成博客 初始化<strong>创建</strong>博客文件夹</p><p>hexo就安装完成，可以启动。</p><p>1.<code>hexo clean</code>清除所有记录</p><p>2.<code>hexo generate</code>生成静态网页</p><p>3.<code>hexo server -p 80</code>启动服务   或<code>hexo s</code>启动本地博客服务</p><p>4.<code>http://localhost:4000/</code>本地访问地址</p></li></ol><h4 id="绑定远程">绑定远程</h4><p>Github创建一个新的仓库，命名 <code>YourGithubName.github.io</code></p><p>在blog目录下安装git部署插件</p><p><code>cnpm install --save hexo-deployer-git</code></p><p><strong>或者</strong> <code>npm install hexo-deployer-git  --save</code></p><p>复制URL，到hexo的配置文件<code>_config.yml</code>。注：Http已经无法直接通过github账户密码访问，<a href="https://blog.csdn.net/weixin_41010198/article/details/119698015">github设置令牌</a> ,直接使用SSH链接更简便。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: git@github.com:YourGithubName/YourGithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>部署到Github仓库 <code>hexo d</code></p><p>访问地址查看博客 <code>https://YourGithubName.github.io/</code></p><h4 id="问题">问题</h4><ol><li><p><strong>不能识别git的SSL证书</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: OpenSSL SSL_connect: Connection was reset in connection to github.com:443</span><br></pre></td></tr></table></figure><p><code>git config --global http.sslVerify &quot;false&quot;</code></p></li><li><p>fatal: unable to access ‘xxxxx’: OpenSSL SSL_connect: Connection was reset in connection to <a href="http://github.com:443">github.com:443</a></p><p>法一：git bash命令</p><p><code>git config --global http.sslBackend &quot;openssl&quot;</code><br><code>git config --global http.sslCAInfo &quot;C:\Program Files\Git\mingw64\ssl\cert.pem&quot;</code>(git安装路径)</p><p>法二：VPN导致</p><p>1.查看自己的VPN端口号，例:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 127.0.0.1:7890</span><br><span class="line">git config --global https.proxy 127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>2.取消再进行配置</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>查看命令</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy#查看git的http代理配置</span><br><span class="line">git config --global https.proxy#查看git的https代理配置</span><br><span class="line">git config --global -l         #查看git的所有配置</span><br></pre></td></tr></table></figure></li><li><p><code> Warning: Accessing non-existent property 'lineno' of module exports inside circular dependency bash: syntax error near unexpected token Warning:'  .</code></p><p>Node版本太高，可修改 \node_modules\stylus\lib\nodes\index.js ，代码最前面加：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">exports.lineno = null;</span><br><span class="line">exports.column = null;</span><br><span class="line">exports.filename = null;</span><br></pre></td></tr></table></figure><p>无用，则：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vim node_modules/nib/package.json</span><br><span class="line">  <span class="string">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;stylus&quot;</span>: <span class="string">&quot;0.54.8&quot;</span>    # 将 stylus 版本由原来<span class="number">0.54</span><span class="number">.4</span>改成 <span class="number">0.54</span><span class="number">.8</span></span><br><span class="line">  &#125;</span><br><span class="line">保存退出，执行 npm install </span><br></pre></td></tr></table></figure></li><li><p><code>hexo init blog</code> 错误，失败,ssh改了问题1以及<a href="https://blog.csdn.net/qq_37555071/article/details/114260533">443 error</a>还是错。</p><p><strong>拆解</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/hexojs/hexo-starter.git blog  （此步失败换ssh链接)</span></span><br><span class="line"><span class="function">cd blog</span></span><br><span class="line"><span class="function">git submodule init</span></span><br><span class="line"><span class="function">git submodule update</span></span><br><span class="line"><span class="function">npm <span class="title">i</span>   <span class="params">(==install)</span> </span></span><br></pre></td></tr></table></figure><p>或换源</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//gitee.com/weilining/hexo-starter.git blog</span></span><br><span class="line">cd blog</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">npm config set registry http:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">npm i</span><br></pre></td></tr></table></figure></li><li><p>字体乱码</p><p><img src="/2021/12/03/Make%20Hexo%20Blog/1643357305658-166057744661233.png" alt="1643357305658"></p><p>用VSCode打开对应.yml文件，切换编码为<strong>UTF-8</strong>，重新输入中文字符。</p></li></ol><h4 id="修改主题">修改主题</h4><ol><li><p>如不喜欢blog ，可删除文件再创建。</p></li><li><p>克隆目标主题</p><p><code>git clone git@github.com:litten/hexo-theme-yilia.git themes/yilia</code></p></li><li><p>配置文件</p><p><code>_config.yml</code> 改 theme ----&gt; theme: yilia</p></li><li><p>清理 生成  推送远端</p><p><code>hexo c</code> <code>hexo g</code> <code>hexo s</code> <code>hexo d</code></p></li><li><p><a href="https://tholman.com/github-corners/">GitHub 角 </a>  设置<code>z-index: 1031</code>属性值避免被上层覆盖</p></li></ol><h5 id="butterfly">butterfly</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">git clone -b master https:<span class="comment">//github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span></span><br><span class="line"><span class="comment">//stylus 主题的依赖，必须安装</span></span><br><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure><h4 id="使用">使用</h4><p><strong>新建文章</strong></p><p><code>hexo new test</code>生成主页,在test/source/_posts下会生成test.md文件</p><p><strong>文内图片</strong></p><ol><li><p>把主页配置文件 <code>_config.yml</code>  里的 <code>post_asset_folder </code>设置为true；</p></li><li><p>在hexo目录下执行 <code>npm install hexo-asset-image --save</code> ；</p></li><li><p>运<code>hexo n &quot;xxxx&quot;</code> 生成md博文，<code>/source/_posts</code> 文件夹内除了 <code>xxxx.md</code> 文件还有一个同名文件夹；</p></li><li><p>在<code>xxxx.md</code>中插入图片时，把图片复制到xxxx文件夹中，然后在<code>xxxx.md</code>中按照markdown的格式引入图片。</p></li></ol><h4 id="参考">参考</h4><p><a href="https://www.cnblogs.com/somata/p/11255547.html">gitee+hexo搭建个人博客 - 乾坤盘 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty">手把手教你从0开始搭建自己的个人博客 bilibili</a></p><p><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">Butterfly美化 - MoYu-zc - 博客园 (cnblogs.com)</a></p><p><a href="https://butterfly.js.org/posts/4aa8abbe/">butterfly官方文档</a></p><p><a href="https://blog.csdn.net/qq_33384402/article/details/107200465">Gittalk评论系统配置</a>   &amp;   <a href="https://github.com/lsqstudy/hexo-theme-amazing">gitalk</a></p><p><a href="https://www.jianshu.com/p/1054736bd3ab">检索</a></p><p><a href="https://sm.ms/">url链接生成</a></p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Butterfly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing 算法基础课 chapter 1</title>
      <link href="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/"/>
      <url>/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/</url>
      
        <content type="html"><![CDATA[<h1>lecture 1 基础算法</h1><h2 id="模板-v2">模板</h2><h3 id="快速排序算法模板">快速排序算法模板</h3><p>——分治</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225414615-99406498.png" alt></p><p>②的实现</p><p>1）暴力——开辟额外空间：</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225454794-747346755.png" alt></p><p>2）双指针</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序算法模板">归并排序算法模板</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225506781-1597839794.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数二分算法模板">整数二分算法模板</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225528019-1930741038.png" alt></p><p>有<strong>单调性</strong>可以二分，题目不一定有单调性。两者无决定关系。</p><p>如果找到一个性质可以将整个区间一分为二，二分可寻找划分边界。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225542686-657322707.png" alt></p><p>每次<strong>选择答案所在</strong>的区间进行下一步处理。直至区间长度为1。（二分一定有解，题目不一定有解。因为定义边界，二分能够算出中点。）</p><p>区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="浮点数二分算法模板">浮点数二分算法模板</h3><p>精度经验值  <strong>多2</strong>：</p><p>保留6位小数   r-l &gt; 1e-8</p><p>保留4位小数   r-l &gt; 1e-6</p><p>保留5位小数   r-l &gt; 1e-7</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度加法">高精度加法</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225604388-410296783.png" alt></p><p><strong>大整数存储</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225616459-441909897.png" alt></p><p>逆存，进位、高位补数更方便操作。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225625411-1680669889.png" alt></p><p><img src="https://img2020.cnblogs.com/blog/2335982/202112/2335982-20211231225745947-1294263317.png" alt></p><p>// C = A + B, A &gt;= 0, B &gt;= 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法">高精度减法</h3><p>(需转为 A&gt;=B)</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225839450-1060680784.png" alt></p><p>若有<strong>负数</strong>，则两数相减A-B，一定可以转换成|A|-|B|或|A|+|B|，分情况讨论。</p><p>// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘低精度">高精度乘低精度</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225853377-1314137168.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225904106-821632396.png" alt></p><p>// C = A * b, A &gt;= 0, b &gt; 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度乘高精度——<a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode43</a></p><h3 id="高精度除以低精度">高精度除以低精度</h3><p>区别前者，从最高位开始算。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225928738-478677729.png" alt></p><p>// A / b = C … r, A &gt;= 0, b &gt; 0</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一维前缀和">一维前缀和</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231225951690-602744695.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="二维前缀和">二维前缀和</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230005489-1633726927.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为 S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="一维差分">一维差分</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230021806-155619005.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230027349-2128206738.png" alt></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230033769-1350180452.png" alt></p><p>完成+c ——&gt; 只要O(1)时间去给原数组中间某一个连续区间全加一个固定值。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230051278-1158349634.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">B[i] = a[i] - a[i - <span class="number">1</span>]</span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h3 id="二维差分">二维差分</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230116312-1640207519.png" alt></p><p>(a数组是b数组的前缀和)</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><h3 id="双指针">双指针</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230152163-1561872434.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">(<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">(<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h3 id="位运算">位运算</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230211383-1673648993.png" alt></p><blockquote><p>10</p><p>for(int k = 3;k &gt;= 0;k–) cout &lt;&lt; (n&gt;&gt;k&amp;1)&lt;&lt;endl;</p><p>1010</p></blockquote><p><strong>lowbit(x)</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230222309-1420076420.png" alt></p><p>0000 0011=3，它的相反数为-3=1000 0011，但0000 0011 + 1000 0011 != 0000 0000。计算机就引入了<strong>补码</strong>，相当于上面的相反数的表示。将人容易理解的二进制称为<strong>原码</strong>，计算机实际使用时用的是补码。<strong>正数的补码就是自己，负数的补码为按位取反加1</strong>。</p><p>对于1000 0011来说，若其为原码，则表示-3；若其为补码，则表示(-1)<em>2^7 + 1</em>2^1 + 1*2^0 = -125。</p><p>应用：求x里面1的个数。</p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230237375-1030858540.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><h3 id="离散化">离散化</h3><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/2335982-20211231230258277-1318058867.png" alt></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());<span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并">区间合并</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目-v2">题目</h2><h3 id="快速排序">快速排序</h3><h4 id="AcWing-785-快排实例">AcWing 785. 快排实例</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>注意<strong>边界问题</strong>。下面用<strong>j</strong>，上面不能取到 <strong>q[r]</strong>。下面用<strong>i</strong>,上面不能取到 <strong>q[l]</strong>，可能出现 ∅和[0,1]的死循环。可以用q[r]或q[(l+r)/2]。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;             <span class="comment">////补等于号</span></span><br><span class="line">    <span class="type">int</span> x = q[(l+r)/<span class="number">2</span>],i = l<span class="number">-1</span>,j = r+<span class="number">1</span>;     <span class="comment">//x应当固定q</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>改进</strong>的快排</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partiton</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//荷兰国旗问题</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> less = l - <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> more = r;</span><br><span class="line"><span class="keyword">while</span> (l&lt;more)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[l] &lt; arr[r])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, ++less, l++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, --more, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(arr, more, r);<span class="comment">//默认以arr[r]做划分，不可遗漏最后一位数！</span></span><br><span class="line"><span class="keyword">return</span> &#123; less + <span class="number">1</span>,more &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> l, <span class="type">int</span> r)</span><span class="comment">//改进的快排，随机取数字做划分值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(arr, l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>), r);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;p = <span class="built_in">partiton</span>(arr, l, r);<span class="comment">//返回划分区域（如[5 5 5]）的左边界和右边界</span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);<span class="comment">//&lt;区</span></span><br><span class="line"><span class="built_in">quickSort</span>(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);<span class="comment">//&gt;区</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">q</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quickSort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-786-第k个数">AcWing 786. 第k个数</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>3</code></p><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &gt;= r)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> x = q[l+(r-l&gt;&gt;<span class="number">1</span>)],i = l<span class="number">-1</span>,j =r+<span class="number">1</span>;       <span class="comment">//注意(r-l&gt;&gt;1)括号位置。</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> --j;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q[k<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_50deed4916-3.png" alt="3.png"><br>降低复杂度。若左边数量已大于k，则只对左边进行排序；否则对右边。<strong>分治</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">// #include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)      <span class="comment">// if(l == r)</span></span><br><span class="line">        <span class="keyword">return</span> q[l];</span><br><span class="line">    <span class="type">int</span> x = q[(l+r)&gt;&gt;<span class="number">1</span>],i = l<span class="number">-1</span>,j = r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> ++i;<span class="keyword">while</span>(q[i] &lt; x);     <span class="comment">//while(q[++i] &lt; x)</span></span><br><span class="line">        <span class="keyword">do</span> --j;<span class="keyword">while</span>(q[j] &gt; x);     <span class="comment">//while(q[--j] &gt; x)</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)   <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(k &lt;= sl)  <span class="built_in">quick_sort</span>(q,l,j,k);</span><br><span class="line">    <span class="keyword">else</span>    <span class="keyword">return</span> <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r,k-sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>,k)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序">归并排序</h3><h4 id="AcWing-787-归并排序">AcWing 787. 归并排序</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>1 2 3 4 5</code></p><p><strong>解析</strong></p><p>归并排序：<br>1.确定分界点<br>2.递归排序<br>3.归并————合二为一</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;    </span><br><span class="line"><span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">tmp</span>(N);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">q</span>(N);</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;q,<span class="type">int</span> l,<span class="type">int</span> r)</span>  <span class="comment">//闭区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+(r-l&gt;&gt;<span class="number">1</span>);   <span class="comment">//或 l+r&gt;&gt;1</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt; q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = q[j++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l,j = <span class="number">0</span>; i &lt;= r; i ++,j++ )    q[i] = tmp[j];  <span class="comment">//注意q[i]条件 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-788-逆序对的数量">AcWing 788. 逆序对的数量</h4><p><strong>输入</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><p><code>5</code></p><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_b8e943dd17-4.png" alt="4.png"><br>4 5 6 | 1 2 3<br>当你发现 4 比 3 大的时候，也就是说右边最大的元素都小于左边最小的元素，那么左边剩下的5和6都必然比右边的所有元素大。因此就可以不用数5和6的情形了，直接分别加上右半边的元素个数就可以了，这一步就降低到了<strong>O(n)</strong><br>即 位置6(mid) - 位置4(i) + 1。为3的情况。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> tmp[N];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> res = <span class="number">0</span>;      <span class="comment">//int则溢出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,l,mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q,mid+<span class="number">1</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tmp[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span>    </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = q[j++];</span><br><span class="line">            res +=( mid - i + <span class="number">1</span>);       <span class="comment">//逆序对对比归并排序只加了这一句。 //是i,非l</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k++] = q[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l,j = <span class="number">0</span>; i &lt;= r; i ++,j++ )     q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分">二分</h3><h4 id="AcWing-789-数的范围">AcWing 789. 数的范围</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l+r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid;        <span class="comment">//注意是q[mid]而非mid</span></span><br><span class="line">            <span class="keyword">else</span>    l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l]!=x) cout&lt;&lt;<span class="string">&quot;-1 -1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l+r+<span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span>    r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另：<br>二分应用<br><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字</a></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==mid)  l = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>    r = mid<span class="number">-1</span>;          <span class="comment">//这里减一，while内加 = 不再死循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>亦可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int l = 0,r = nums.size();      //-1是不会执行循环的</span><br><span class="line">while(l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">    int mid = l+r&gt;&gt;1;</span><br><span class="line">    if(nums[mid]==mid)  l = mid+1;</span><br><span class="line">    else    r = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-790-数的三次方根">AcWing 790. 数的三次方根</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1000.00</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.000000</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-100.0</span>,r = <span class="number">100.0</span>;        <span class="comment">//r不为n，负数情况下结果大于n</span></span><br><span class="line">    <span class="keyword">while</span>(r - l &gt; <span class="number">1e-8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>((mid*mid*mid) &gt;= n)    r = mid;</span><br><span class="line">        <span class="keyword">else</span>    l = mid;            <span class="comment">//结合while条件，此情况无需加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度">高精度</h3><h4 id="AcWing-791-高精度加法">AcWing 791. 高精度加法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>()||i &lt; B.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())    t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>())    t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t)   C.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);    <span class="comment">//不要忘了-&#x27;0&#x27;，字符--&gt; 数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-792-高精度减法">AcWing 792. 高精度减法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>两者都是<strong>正整数</strong>的情况，需转为 <strong>A&gt;=B</strong>。若有负数，则两数相减A-B，一定可以转换成**|A|-|B|<strong>或</strong>|A|+|B|**，分情况讨论。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否 A&gt;=B</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>())    <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C = A - B</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>())    t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>)   t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>    t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除前导0</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);    <span class="comment">//不要忘记-&#x27;0&#x27;,字符--&gt;数字</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);            <span class="comment">//记得加符号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-793-高精度乘法">AcWing 793. 高精度乘法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><strong>高</strong>精度乘<strong>低</strong>精度<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_e84b7dee0f-%E5%9B%BE%E7%89%871.png" alt="图片1.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>() || t;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>())    t += A[i]*b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();   <span class="comment">//去除前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] -<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>高</strong>精度乘以<strong>高</strong>精度    参考<a href="https://leetcode-cn.com/problems/multiply-strings/">LeetCode-43</a><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_1a93ea880f-1627700273-JdpAic-image.png" alt="1627700273-JdpAic-image.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,vector&lt;<span class="type">int</span>&gt;&amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = A.<span class="built_in">size</span>(),len2 = B.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">C</span>(len1+len2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; len1;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; len2;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            C[i+j] += A[i]*B[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; C.<span class="built_in">size</span>();++i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += C[i];</span><br><span class="line">        C[i] = t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  B.<span class="built_in">push_back</span>(b[i]- <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AcWing-794-高精度除法">AcWing 794. 高精度除法</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>区别前者，从<strong>最高位</strong>开始算。也可以不用从后往前存，此处为统一操作都从后向前存。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;bits/stdc++.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A/b,商为C,余数是r</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> &amp;b,<span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;  <span class="comment">//商</span></span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r*<span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()==<span class="number">0</span>)  C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;--i)  A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;=<span class="number">0</span>;--i)   <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和与差分">前缀和与差分</h3><h4 id="AcWing-795-前缀和">AcWing 795. 前缀和</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 1 3 6 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>做题的时候一般使用 <strong>scanf printf</strong>。<br>cin 和 cout 比 scanf printf 慢的多。因为cin cout与stdin stdout总是保持同步，这个兼容性的特性，导致 cin 有许多额外开销。<br>ios::sync_with_stdio(false);这条语句作用是关掉scanf 和cin 的同步，加快效率；劣势是scanf和cin 无法混用。</p><hr><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ios::sync_with_stdio(false);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i ++ )    s[i] = s[i<span class="number">-1</span>] + q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_03004b0d17-5.png" alt="5.png"><br>1.预处理前缀和数组<br>2.用公式求区间和</p><p>有f(i-1)等 -1 的操作一般循环从 <strong>1</strong> 开始。</p><h4 id="AcWing-796-子矩阵的和">AcWing 796. 子矩阵的和</h4><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 7 2 4</span><br><span class="line">3 6 2 8</span><br><span class="line">2 1 2 3</span><br><span class="line">1 1 2 2</span><br><span class="line">2 1 3 4</span><br><span class="line">1 3 3 4</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">17</span><br><span class="line">27</span><br><span class="line">21</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>下标从 <strong>1</strong> 开始<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_84a126e716-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20210915214026.png" alt="微信图片_20210915214026.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N],s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            s[i][j] = s[i<span class="number">-1</span>][j]+s[i][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];  <span class="comment">//求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s[x2][y2]-s[x2][y1<span class="number">-1</span>]-s[x1<span class="number">-1</span>][y2]+s[x1<span class="number">-1</span>][y1<span class="number">-1</span>]); <span class="comment">//算子矩阵</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_d652c3ff17-6.png" alt="2"><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_2936066c17-7.png" alt="1"></p><h4 id="AcWing-797-差分">AcWing 797. 差分</h4><p>输入一个长度为 n 的整数序列。</p><p>接下来输入 m 个操作，每个操作包含三个整数 l,r,c，表示将序列中 [l,r] 之间的每个数加上 c。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 1 2 1</span><br><span class="line">1 3 1</span><br><span class="line">3 5 1</span><br><span class="line">1 6 1</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 5 3 4 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>差分无需专门考虑<strong>构造</strong>问题，考虑如何 <strong>更新</strong> 即可。构造与修改操作可统一</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r+<span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">insert</span>(i,i,a[i]);   <span class="comment">//构造b[i]矩阵(差分)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   b[i] += b[i<span class="number">-1</span>];     <span class="comment">//前缀和计算(原数组) 或 a[i] = a[i-1] + b[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)   <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i]); <span class="comment">//接上 或 a[i]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_a5cadb3217-8.png" alt="8.png"><br>构造同 [1,1] a1     [2,2] a2 …</p><h4 id="AcWing-798-差分矩阵">AcWing 798. 差分矩阵</h4><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p><p>每个操作都要将选中的子矩阵中的每个元素的值加上 c。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_225d688716-2.png" alt="2.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line"><span class="type">int</span> a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2+<span class="number">1</span>] -= c;</span><br><span class="line">    b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">            <span class="built_in">insert</span>(i,j,i,j,a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(x1,y1,x2,y2,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i<span class="number">-1</span>][j] + b[i][j<span class="number">-1</span>] - b[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(习题课)<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_83ed2cff17-10.png" alt="10.png"></p><h3 id="双指针算法">双指针算法</h3><h4 id="AcWing-799-最长连续不重复子序列">AcWing 799. 最长连续不重复子序列</h4><p>给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>1 2 2 3 5<br>——i<br>j<br><strong>s[a[j]]–</strong>;  //除去1<br>**j++;  **      //j右移</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,a[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;++i)    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; i &amp;&amp; s[a[i]] &gt; <span class="number">1</span>) <span class="comment">//注意是 s[a[i]] &gt; 1      i</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] -- ;            <span class="comment">//注意是 s[a[j]]--        j</span></span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res,i-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="AcWing-800-数组元素的目标和">AcWing 800. 数组元素的目标和</h4><p>给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。数组下标从 0 开始。求出满足 A[i]+B[j]=x 的数对 (i,j)。数据保证有唯一解。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m,x;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = m<span class="number">-1</span>;i &lt; n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i]+b[j] &gt; x)  j--;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] == x)  cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>双指针时间复杂度 <strong>O(n+m)</strong>。<br>如果题有多个答案，不能用双指针，复杂度为O(nm)。</p><h4 id="AcWing-2816-判断子序列">AcWing 2816. 判断子序列</h4><p>给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。判断 a 序列是否为 b 序列的子序列。子序列指序列的一部分项按原有次序排列而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )   <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[j])    i++;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == n)  <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>    <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算-v2">位运算</h3><h4 id="AcWing-801-二进制中1的个数">AcWing 801. 二进制中1的个数</h4><p>给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 1 2 1 2</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>1.求 n 第 k 位数字：<strong>n&gt;&gt;k&amp;1</strong><br>2.返回 n 最后一位1：<strong>lowbit(n) = n &amp; -n</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)    x -= <span class="built_in">lowbit</span>(x),res++;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_9e468e514c-112301.png" alt="112301.png"></p><blockquote><p>10<br>for(int k = 3;k &gt;= 0;k–) cout &lt;&lt; (n&gt;&gt;k&amp;1)&lt;&lt;endl;<br>1010</p></blockquote><p><strong>lowbit(x)</strong><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_c803d1274c-112302.png" alt="112302.png"></p><blockquote><p>0000 0011=3，它的相反数为-3=1000 0011，但0000 0011 + 1000 0011 != 0000 0000。计算机就引入了<strong>补码</strong>，相当于上面的相反数的表示。将人容易理解的二进制称为<strong>原码</strong>，计算机实际使用时用的是补码。<strong>正数的补码就是自己，负数的补码为按位取反加1</strong>。<br>对于1000 0011来说，若其为原码，则表示-3；若其为补码，则表示(-1)<em>2^7 + 1</em>2^1 + 1*2^0 = -125。<br>应用：求x里面1的个数。</p></blockquote><h3 id="离散化-v2">离散化</h3><h4 id="AcWing-802-区间和">AcWing 802. 区间和</h4><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p>总共 2×10^9 个数，但最多只使用 <strong>3×10^5</strong>。故开三十万：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_33788bee2e-QQ%E5%9B%BE%E7%89%8720211012124535.png" alt="QQ图片20211012124535.png"><br>基本做法：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_d11cb8bb2e-QQ%E5%9B%BE%E7%89%8720211016120845.png" alt="QQ图片20211016120845.png"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[N],s[N];  <span class="comment">//a[N]为存的数。s[N]为前缀和</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;alls;    <span class="comment">//存的所有要离散化的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line">vector&lt;PII&gt; add,query;  <span class="comment">//插入操作。求操作</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//用于求 x 离散化的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x)  r = mid;    <span class="comment">//&gt;=x最小的数</span></span><br><span class="line">        <span class="keyword">else</span>    l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>; <span class="comment">//映射的数值为从1开始的自然数。方便前缀和运算 </span></span><br><span class="line">    <span class="comment">//若不想写二分，可以写lower_board</span></span><br><span class="line">    <span class="comment">//return lower_board(alls.begin(),alls.end(),x) - alls.begin() + 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="comment">//先把所有要操作的数先读进来，将其中用到的下标离散化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读入所有的左右区间</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r; </span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">        <span class="comment">//区间两个端点都应该离散化</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//至此，所有需要用到下标皆已存。下一步 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;    <span class="comment">//在离散化后的坐标位置上加上要加的数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理询问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> item:query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first),r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unique的实现：<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_c6c8d4b22e-4.png" alt="4.png"><br>双指针<br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_28fd9b262e-5.png" alt="5.png"></p><h3 id="区间合并-v2">区间合并</h3><h4 id="AcWing-803-区间合并">AcWing 803. 区间合并</h4><p>给定 n 个区间 [li,ri]，要求合并所有有交集的区间。注意如果在端点处相交，也算有交集。输出合并完成后的区间个数。例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">7 8</span><br><span class="line">7 9</span><br></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><p><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_90945ece2e-1.png" alt="1.png"><br><img src="/2021/10/17/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BEchapter1/95860_fa7453d62f-2.png" alt="2.png"><br>pair在sort时优先左端点排序，再右端点排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line">vector&lt;PII&gt;segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt;&amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt;res;</span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>,ed = <span class="number">-2e9</span>;            <span class="comment">//起始维护值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg:segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st!=<span class="number">-2e9</span>)    res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(st!=<span class="number">-2e9</span>)    res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);     <span class="comment">//加上最后一次</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>chapter 1 END。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Acwing算法基础课 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
